{
	"person": {
		"name": "Benji Encalada Mora",
		"githubUsername": "benjifs",
		"imageURL": "https://avatars.githubusercontent.com/u/4167938?v=4",
		"bio": "ðŸ‡ªðŸ‡¨",
		"primary": true
	},
	"plugins": [
		{
			"files": [
				{
					"path": "Tools/Slack/slack-team-notifications.1m.js",
					"filename": "slack-team-notifications.1m.js",
					"content": "#!/usr/bin/env /usr/local/bin/node\n/* jshint esversion: 8 */\n/* jshint asi: true */\n\n// \u003cbitbar.title\u003eSlack Team Notifications\u003c/bitbar.title\u003e\n// \u003cbitbar.version\u003ev1.1.0\u003c/bitbar.version\u003e\n// \u003cbitbar.author\u003eBenji Encalada Mora\u003c/bitbar.author\u003e\n// \u003cbitbar.author.github\u003ebenjifs\u003c/bitbar.author.github\u003e\n// \u003cbitbar.image\u003ehttps://i.imgur.com/ORbsRBx.jpg\u003c/bitbar.image\u003e\n// \u003cbitbar.desc\u003eShow notifications for Slack teams and channels with option to mark as read. See https://github.com/benjifs/bitbar-slack-team-notifications for configuration instructions.\u003c/bitbar.desc\u003e\n// \u003cbitbar.dependencies\u003enode.js superagent\u003c/bitbar.dependencies\u003e\n\nconst request = require('superagent');\nconst tokens = require('./.tokens.js');\n\n// CONFIG\n// BITBAR_SLACK_ICON defines which Slack Icon is shown\n// 0 -\u003e Original Slack Icon\n// 1 -\u003e White Slack Icon\n// 2 -\u003e Black Slack Icon\nconst BITBAR_SLACK_ICON = process.env.BitBarDarkMode ? 1 : 2;\n// If MENTIONS_ONLY is true, the count only includes mentions and DMs.\n// If MENTIONS_ONLY is false, the count includes all unread messages.\nconst MENTIONS_ONLY = false;\n// MAX_LENGTH of channel name or user name\nconst MAX_LENGTH = 18;\n// Show `No new notifications` message\nconst SHOW_ZERO_NOTIFICATIONS = true;\n\n// Is Slack.app installed?\nlet SLACK_INSTALLED = true;\nconst { exec } = require('child_process');\nexec('ls /Applications | grep Slack | wc -l', (err, stdout, stderr) =\u003e {\n\tif (!err \u0026\u0026 stdout == 0) {\n\t\tSLACK_INSTALLED = false;\n\t}\n});\n\nconst DEBUG = process.argv.indexOf('--debug') \u003e 0;\nconst SCRIPT = process.argv[1];\n\n// Slack App Credentials\nconst SLACK_OAUTH_AUTHORIZE = 'https://slack.com/oauth/authorize?scope=client\u0026client_id=';\nconst SLACK_CLIENT_ID = '11708641376.684689498789';\n\n// Slack API\nconst SLACK_API = 'https://slack.com/api/';\nconst SLACK_CONVERSATIONS = 'conversations';\nconst SLACK_CHANNELS = 'channels';\nconst SLACK_GROUPS = 'groups';\nconst SLACK_IM = 'im';\nconst SLACK_TEAM = 'team';\nconst SLACK_USERS = 'users';\nconst SLACK_INFO = '.info';\nconst SLACK_LIST = '.list';\nconst SLACK_MARK = '.mark';\nconst SLACK_HISTORY = '.history';\nconst SLACK_AUTH_TEST = 'auth.test';\n\n// ICONS {\n// Original Slack icon (unused)\nconst SLACK_ICON = 'image=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';\n\n// Dark Slack Icon\nconst SLACK_ICON_B = 'image=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';\n\n// White Slack Icon\nconst SLACK_ICON_W = 'image=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'\n// }\n\nlet unread_count = 0;\nconst slack_output = {};\nconst errors = [];\nlet call_log = {};\n\ndebug('Debugging');\n\nif (process.argv.indexOf('--mark') \u003e 0) {\n\tconsole.log('Mark as read');\n\n\tlet token;\n\tfor (let i = 3; i \u003c process.argv.length; i++) {\n\t\tif (process.argv[i].indexOf('--token=') === 0) {\n\t\t\ttoken = process.argv[i].split('=')[1];\n\t\t}\n\t}\n\tif (!token) {\n\t\tconsole.log('Error: Missing token');\n\t\treturn;\n\t}\n\n\tfor (let i = 3; i \u003c process.argv.length; i++) {\n\t\tlet args = process.argv[i].split('=');\n\t\tif (args.length != 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ([SLACK_CHANNELS, SLACK_GROUPS, SLACK_IM].indexOf(args[0]) \u003c 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet channels = args[1].split(',');\n\t\tfor (let j in channels) {\n\t\t\tconsole.log('/' + args[0] + SLACK_MARK + ' (' + channels[j] + ')');\n\t\t\tslack_request(SLACK_CONVERSATIONS + SLACK_MARK, {\n\t\t\t\t'token': token,\n\t\t\t\t'channel': channels[j],\n\t\t\t\t'ts': Math.floor(Date.now() / 1000) + '.000000'\n\t\t\t})\n\t\t\t\t.then((body) =\u003e {\n\t\t\t\t\t// console.log('  Success: ' + args[0] + ':' + channels[j]);\n\t\t\t\t});\n\t\t}\n\t}\n\treturn;\n}\n\nfunction debug(message) {\n\treturn DEBUG \u0026\u0026 console.log(message);\n}\n\nfunction slack_request(URL, query) {\n\tdebug('  /' + URL + (query.channel ? ' (' + query.channel + ')' : ''));\n\t// The following is to keep track of how many calls are being made\n\t// for each token to each method. Should help debug the rate limits\n\tif (!call_log[query.token]) {\n\t\tcall_log[query.token] = {};\n\t}\n\tif (!call_log[query.token][URL]) {\n\t\tcall_log[query.token][URL] = 0;\n\t}\n\tcall_log[query.token][URL]++;\n\treturn request\n\t\t.get(SLACK_API + URL)\n\t\t.query(query)\n\t\t.then((res) =\u003e {\n\t\t\tdebug(res.body);\n\t\t\tif (res \u0026\u0026 res.body \u0026\u0026 res.body.ok === true) {\n\t\t\t\treturn Promise.resolve(res.body);\n\t\t\t}\n\t\t\treturn Promise.reject(res.body.error);\n\t\t})\n\t\t.catch((err) =\u003e {\n\t\t\tdebug('ERROR: ' + err);\n\t\t\tdebug('  ' + URL);\n\t\t\tdebug('  ' + JSON.stringify(query));\n\t\t\terrors.push(URL + ': ' + err + ' | color=red');\n\t\t});\n}\n\nfunction output() {\n\tunread_count = unread_count \u003e 10 ? '10+' : unread_count \u003e 0 ? unread_count : '';\n\tconst slack_icon = BITBAR_SLACK_ICON == 2 ? SLACK_ICON_B : BITBAR_SLACK_ICON == 1 ? SLACK_ICON_W : SLACK_ICON;\n\tif (errors.length \u003e 0) {\n\t\tconsole.log('! |color=red ' + slack_icon);\n\t} else {\n\t\tconsole.log(unread_count + ' | ' + slack_icon);\n\t}\n\n\tif (Object.keys(slack_output).length) {\n\t\tfor (let i in slack_output) {\n\t\t\tlet team = slack_output[i];\n\n\t\t\tif (SHOW_ZERO_NOTIFICATIONS || team.notifications.length \u003e 0) {\n\t\t\t\tconsole.log('---');\n\t\t\t\tconsole.log(team.name + ' | size=12');\n\t\t\t}\n\t\t\tif (team.notifications.length \u003e 0) {\n\t\t\t\tfor (let j in team.notifications) {\n\t\t\t\t\tconsole.log(team.notifications[j]);\n\t\t\t\t}\n\t\t\t\tconsole.log('Mark all as read ' +\n\t\t\t\t\t'|bash=' + SCRIPT +\n\t\t\t\t\t' param1=--mark' +\n\t\t\t\t\t' param2=--token=' + team.token +\n\t\t\t\t\t(team.params[SLACK_IM] ? ' param3=' + SLACK_IM + '=' + team.params[SLACK_IM].join() : '') +\n\t\t\t\t\t(team.params[SLACK_GROUPS] ? ' param4=' + SLACK_GROUPS + '=' + team.params[SLACK_GROUPS].join() : '') +\n\t\t\t\t\t(team.params[SLACK_CHANNELS] ? ' param5=' + SLACK_CHANNELS + '=' + team.params[SLACK_CHANNELS].join() : '') +\n\t\t\t\t\t' refresh=true' +\n\t\t\t\t\t' terminal=false');\n\t\t\t} else if (SHOW_ZERO_NOTIFICATIONS) {\n\t\t\t\tconsole.log('No new notifications');\n\t\t\t}\n\t\t}\n\t}\n\tif (errors.length \u003e 0) {\n\t\tconsole.log('---');\n\t\tconsole.log('Errors');\n\t\tfor (let i in errors) {\n\t\t\tconsole.log('--' + errors[i]);\n\t\t}\n\t}\n\tconsole.log('---');\n\tconsole.log('Add New Workspace');\n\tconsole.log('--Generate OAuth Token | href=' + SLACK_OAUTH_AUTHORIZE + SLACK_CLIENT_ID);\n\tdebug(call_log);\n}\n\nfunction channel_output(channel) {\n\tunread_count += channel.count;\n\n\tlet output_str = (channel.is_im ? '@' : '#') + channel.name;\n\tif (output_str.length \u003e MAX_LENGTH) {\n\t\toutput_str = output_str.substring(0, MAX_LENGTH - 1) + 'â€¦';\n\t}\n\toutput_str += ' '.repeat(MAX_LENGTH + 2 - output_str.length);\n\toutput_str += (channel.count \u003e 10 ? '10+' : channel.count);\n\n\tlet key = channel.is_im ? SLACK_IM : channel.is_channel ? SLACK_CHANNELS : SLACK_GROUPS;\n\tlet href;\n\tif (SLACK_INSTALLED) {\n\t\thref = 'slack://channel?team=' + channel.team + '\u0026id=' + channel.id;\n\t} else {\n\t\thref = 'https://app.slack.com/client/' + channel.team + '/' + channel.id;\n\t}\n\n\tslack_output[channel.token].notifications.push(output_str + '|font=Menlo size=13 href=' + href);\n\n\tslack_output[channel.token].notifications.push('Mark as read ' +\n\t\t'|alternate=true' +\n\t\t' font=Menlo size=13' +\n\t\t' bash=' + SCRIPT +\n\t\t' param1=--mark' +\n\t\t' param2=--token=' + channel.token +\n\t\t' param3=' + key + '=' + channel.id +\n\t\t' refresh=true' +\n\t\t' terminal=false');\n\n\tif (!slack_output[channel.token].params[key]) {\n\t\tslack_output[channel.token].params[key] = [];\n\t}\n\tslack_output[channel.token].params[key].push(channel.id);\n}\n\nasync function run() {\n\tif (typeof tokens === 'undefined' || !tokens || !tokens.length) {\n\t\terrors.push('Missing Slack Legacy Token | color=red href=https://api.slack.com/custom-integrations/legacy-tokens');\n\t\terrors.push('Generate OAuth Token | color=red href=' + SLACK_OAUTH_AUTHORIZE + SLACK_CLIENT_ID);\n\t\treturn output();\n\t}\n\n\tfor (let i in tokens) {\n\t\tawait get_team_notifications(tokens[i]);\n\t}\n\toutput();\n}\n\nfunction get_team_notifications(token) {\n\treturn get_team_info(token)\n\t\t.then((team) =\u003e {\n\t\t\tif (team) {\n\t\t\t\tslack_output[token] = {\n\t\t\t\t\t'id': team.id,\n\t\t\t\t\t'name': team.name,\n\t\t\t\t\t'token': token,\n\t\t\t\t\t'notifications': [],\n\t\t\t\t\t'params': {},\n\t\t\t\t\t'errors': []\n\t\t\t\t};\n\t\t\t\treturn get_auth_info(token);\n\t\t\t} else {\n\t\t\t\tthrow 'Invalid token';\n\t\t\t}\n\t\t})\n\t\t.then((user_id) =\u003e {\n\t\t\tslack_output[token]['user_id'] = user_id;\n\t\t\treturn get_team_conversations(token);\n\t\t})\n\t\t.then((channels) =\u003e {\n\t\t\treturn check_channels_unread(channels, token);\n\t\t})\n\t\t.then((channels) =\u003e {\n\t\t\tfor (let i in channels) {\n\t\t\t\tif (channels[i]) {\n\t\t\t\t\tchannel_output(channels[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t.catch((errors) =\u003e {\n\t\t\tdebug(errors);\n\t\t})\n}\n\nfunction get_team_info(token) {\n\tdebug('Fetching team info for ' + token);\n\treturn slack_request(SLACK_TEAM + SLACK_INFO, {\n\t\t'token': token\n\t})\n\t\t.then((body) =\u003e {\n\t\t\tif (body \u0026\u0026 body.team) {\n\t\t\t\treturn Promise.resolve(body.team);\n\t\t\t}\n\t\t});\n}\n\nfunction get_auth_info(token) {\n\tdebug('Fetch auth info for ' + token);\n\treturn slack_request(SLACK_AUTH_TEST, {\n\t\t'token': token\n\t}).\n\t\tthen((body) =\u003e {\n\t\t\tif (body \u0026\u0026 body.user_id) {\n\t\t\t\treturn Promise.resolve(body.user_id);\n\t\t\t}\n\t\t});\n}\n\nfunction get_team_conversations(token) {\n\tdebug('Fetching conversations for ' + token);\n\treturn slack_request(SLACK_CONVERSATIONS + SLACK_LIST, {\n\t\t'token': token,\n\t\t'exclude_archived': true,\n\t\t'limit': 200,\n\t\t'types': 'public_channel,private_channel,mpim,im'\n\t})\n\t\t.then((body) =\u003e {\n\t\t\tif (body \u0026\u0026 body.channels) {\n\t\t\t\treturn Promise.resolve(body.channels);\n\t\t\t}\n\t\t});\n}\n\nasync function check_channels_unread(channels, token) {\n\tlet req = [];\n\tfor (let i in channels) {\n\t\tif (channels[i]) {\n\t\t\treq.push(is_channel_unread(channels[i], token));\n\t\t}\n\t}\n\treturn await Promise.all(req);\n}\n\nfunction is_channel_unread(channel, token) {\n\treturn get_unread_count(channel, token)\n\t\t.then((unread_count) =\u003e {\n\t\t\tif (channel \u0026\u0026 unread_count \u003e 0) {\n\t\t\t\tif (channel.is_im) {\n\t\t\t\t\treturn get_user(channel.user, token)\n\t\t\t\t\t\t.then((user) =\u003e {\n\t\t\t\t\t\t\tif (user) {\n\t\t\t\t\t\t\t\treturn Promise.resolve({\n\t\t\t\t\t\t\t\t\t'id': channel.id,\n\t\t\t\t\t\t\t\t\t'name': user.name,\n\t\t\t\t\t\t\t\t\t'count': unread_count,\n\t\t\t\t\t\t\t\t\t'team': user.team_id,\n\t\t\t\t\t\t\t\t\t'is_im': true,\n\t\t\t\t\t\t\t\t\t'token': token\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t} else if (channel.is_member || channel.is_group) {\n\t\t\t\t\tlet team = channel.shared_team_ids \u0026\u0026 channel.shared_team_ids.length \u003e 0 ? channel.shared_team_ids[0] : '';\n\t\t\t\t\treturn Promise.resolve({\n\t\t\t\t\t\t'id': channel.id,\n\t\t\t\t\t\t'name': channel.name,\n\t\t\t\t\t\t'count': unread_count,\n\t\t\t\t\t\t'team': team,\n\t\t\t\t\t\t'is_channel': channel.is_member \u0026\u0026 channel.is_channel,\n\t\t\t\t\t\t'is_group': channel.is_group || (channel.is_channel \u0026\u0026 channel.is_private),\n\t\t\t\t\t\t'token': token\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n}\n\nfunction get_unread_count(channel, token) {\n\t// unread_count_display is a count of messages that the calling user has\n\t// yet to read that matter to them (this means it excludes things like\n\t// join/leave messages)\n\t// unread_count_display does not show up consistently.\n\t// In the case unread_count_display is not present, check conversations.history\n\tif (channel \u0026\u0026 !('unread_count_display' in channel)) {\n\t\treturn check_conversation_history(channel, token)\n\t\t\t.then((unread_count) =\u003e {\n\t\t\t\treturn Promise.resolve(unread_count);\n\t\t\t})\n\t} else {\n\t\treturn Promise.resolve(channel.unread_count_display);\n\t}\n}\n\nfunction check_conversation_history(channel, token) {\n\tdebug('Fetch history for ' + channel.id);\n\treturn slack_request(SLACK_CONVERSATIONS + SLACK_HISTORY, {\n\t\t'token': token,\n\t\t'channel': channel.id,\n\t\t'oldest': channel.last_read != '0000000000.000000' ? channel.last_read : 0,\n\t\t'unreads': true\n\t})\n\t\t.then((body) =\u003e {\n\t\t\tif (body \u0026\u0026 body.unread_count_display \u003e 0) {\n\t\t\t\tconst user_id = slack_output[token]['user_id'];\n\t\t\t\tif (channel.is_im || channel.is_mpim) {\n\t\t\t\t\treturn Promise.resolve(body.unread_count_display);\n\t\t\t\t}\n\t\t\t\treturn Promise.resolve(count_mentions(body, user_id));\n\t\t\t}\n\t\t\treturn Promise.resolve(0);\n\t\t});\n}\n\nfunction count_mentions(body, user_id) {\n\tif (MENTIONS_ONLY \u0026\u0026 body.messages \u0026\u0026 body.messages.length \u003e 0) {\n\t\tlet count = 0;\n\t\tfor (let i in body.messages) {\n\t\t\tif (i \u003e= body.unread_count_display) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (body.messages[i].text.indexOf(user_id) \u003e= 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\treturn body.unread_count_display;\n}\n\nfunction get_user(user, token) {\n\tdebug('Fetch user info for ' + user);\n\treturn slack_request(SLACK_USERS + SLACK_INFO, {\n\t\t'token': token,\n\t\t'user': user\n\t})\n\t\t.then((body) =\u003e {\n\t\t\tif (body \u0026\u0026 body.user) {\n\t\t\t\treturn Promise.resolve(body.user);\n\t\t\t}\n\t\t});\n}\n\nrun();\n\n"
				}
			],
			"path": "Tools/Slack/slack-team-notifications.1m.js",
			"filename": "slack-team-notifications.1m.js",
			"dir": "Tools/Slack",
			"docsPlugin": "Tools/Slack/slack-team-notifications.1m.js.html",
			"docsCategory": "Tools/Slack.html",
			"pathSegments": [
				"Tools",
				"Slack"
			],
			"categoryPathSegments": [
				{
					"path": "Tools",
					"text": "Tools",
					"isLast": false
				},
				{
					"path": "Tools/Slack",
					"text": "Slack",
					"isLast": true
				}
			],
			"title": "Slack Team Notifications",
			"version": "v1.1.0",
			"author": "Benji Encalada Mora",
			"authors": [
				{
					"name": "Benji Encalada Mora",
					"githubUsername": "benjifs",
					"imageURL": "https://avatars.githubusercontent.com/u/4167938?v=4",
					"bio": "ðŸ‡ªðŸ‡¨",
					"primary": true
				}
			],
			"desc": "Show notifications for Slack teams and channels with option to mark as read. See https://github.com/benjifs/bitbar-slack-team-notifications for configuration instructions.",
			"imageURL": "https://i.imgur.com/ORbsRBx.jpg",
			"dependencies": [
				"node.js superagent"
			],
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:22:07.303048Z",
			"vars": null
		}
	]
}