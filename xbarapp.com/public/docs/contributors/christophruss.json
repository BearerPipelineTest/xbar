{
	"person": {
		"name": "Christoph Russ",
		"githubUsername": "christophruss",
		"imageURL": "https://avatars.githubusercontent.com/u/12080753?v=4",
		"bio": "",
		"primary": true
	},
	"plugins": [
		{
			"files": [
				{
					"path": "Lifestyle/taskwarrior.4m.py",
					"filename": "taskwarrior.4m.py",
					"content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# Taskwarrior\n#\n# \u003cbitbar.title\u003eTaskwarrior\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev2.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003eChristoph Russ\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003echristophruss\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eTask managment through your menu-bar.\u003c/bitbar.desc\u003e\n# \u003cbitbar.dependencies\u003etask,python\u003c/bitbar.dependencies\u003e\n# \u003cbitbar.image\u003ehttp://i.imgur.com/vjEt7Is.jpg\u003c/bitbar.image\u003e\n#\n# Dependencies:\n#   taskwarrior (http://taskwarrior.org)\n#      available via homebrew `brew install task`\n\n#\n# TODO\n# * In a sub-menu (at the bottom) Allow to restart previously completed tasks\n# * Allow to delete tasks (also in a sub-menu?)\n#\n\nimport os\nimport re\nimport subprocess\nfrom subprocess import Popen, PIPE\n\n\ndef trigger_actions(argv):\n    t_id = argv[-1]\n    action = argv[-2]\n    subprocess.call(['/usr/local/bin/task', t_id, action])\n\n\ndef build_command(t_id, action, refresh=True):\n    cmd = ''\n\n    if refresh:\n        cmd = cmd + ' refresh=true'\n\n    cmd = cmd + ' bash=/usr/bin/python param1=' + __file__ + ' param2='\n\n    cmd = cmd + action\n\n    cmd = cmd + ' param3=' + str(t_id)\n\n    cmd = cmd + ' terminal=false'\n\n    return cmd\n\n\ndef print_output(\n        cmd,\n        color,\n        head,\n        print_content=True,\n        command='',\n        ignore_id_list=[],\n        highlight_id_list=[],\n        highlight_color=' color=Red',\n        highlight_command='',\n        alternate_command=''):\n    output = ''\n\n    # important: PIPE the stderr, since task likes to use that - a lot ...\n    p = Popen(['/usr/local/bin/task', cmd],\n              stdin=None, stdout=PIPE, stderr=PIPE)\n    output, err = p.communicate()\n\n    output_lines = output.split('\\n')\n\n    id_list = []\n    content_lines = []\n\n    for output_line in output_lines:\n        output_line = output_line.rstrip()\n        if not output_line:\n            continue\n        # When looking for 'active' or 'next' tasks, we want to look only at\n        # lines that start with a digit or a -. Other line are likely extra\n        # data like annotations from bugwarrior sync\n        content_id = output_line.split()[0]\n        if not content_id.isdigit() and content_id not in ['--', '-', 'ID']:\n            continue\n        line_groups = re.match('^(\\s*\\d+|\\s*ID|\\s*-+)(.*)', output_line)\n        content_lines.append('[{}]{}'.format(*line_groups.groups()))\n\n    content_count = len(content_lines[2:-1])\n\n    if head:\n        if content_count == 0:\n            print 'ⓣ'  # ⓪ #⓿\n        elif content_count \u003c 21:\n            circle_number = ['⓪', '①', '②', '③', '④', '⑤', '⑥',\n                             '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬',\n                             '⑭', '⑮', '⑯', '⑰', '⑱', '⑲', '⑳']\n            print circle_number[content_count]  # + '|' + color_pending\n        else:\n            print str(content_count)  # + '| color=Red'\n\n        print '---'\n\n    if content_count \u003c 1:\n        return id_list\n\n    table_head = content_lines[0]\n\n    # total_number_of_tasks = content_lines[-1]\n\n    content_formatting = ' | size=12 font=Courier'\n\n    if print_content:\n        print table_head + content_formatting\n        print '---'\n\n    for content_line in content_lines[2:-1]:\n        content_re = re.match('^\\[\\s*(.+)\\]\\s+([0-9A-Fa-f]+)?', content_line)\n        content_id = content_re.group(1)\n        \n        if content_id == '-':\n            # should be the UUID in this case\n            content_id = content_re.group(2)\n\n        if content_id in ignore_id_list:\n            continue\n\n        id_list.append(content_id)\n\n        if print_content:\n            cmd = ''\n\n            if len(command) \u003e 0:\n                cmd = build_command(t_id=content_id, action=command)\n\n            if content_id in highlight_id_list:\n                if len(highlight_command) \u003e 0:\n                    cmd = build_command(\n                        t_id=content_id, action=highlight_command)\n                print content_line + content_formatting + highlight_color + cmd\n            else:\n                print content_line + content_formatting + color + cmd\n\n            # adding an alternative command (press ALT for this!)\n            # printing the same stuff again, only with a different action\n            # attached\n            if len(alternate_command) \u003e 0:\n                alt_cmd = build_command(\n                    t_id=content_id, action=alternate_command)\n\n                if content_id in highlight_id_list:\n                    print content_line + content_formatting + highlight_color + alt_cmd + ' alternate=true'\n                else:\n                    print content_line + content_formatting + color + alt_cmd + ' alternate=true'\n\n    return id_list\n\n\ndef is_darkmode():\n    FNULL = open(os.devnull, 'w')\n    return_code = subprocess.call(['/usr/bin/defaults', 'read', '-g',\n                                   'AppleInterfaceStyle'], stdout=FNULL, stderr=subprocess.STDOUT)\n    if (return_code == 1):\n        return False\n    else:\n        return True\n\n\ndef main(argv):\n\n    if len(argv) \u003e 1:\n        trigger_actions(argv)\n        exit()\n\n    if is_darkmode():\n        color_running = ' color=Red'\n        color_pending = ' color=Yellow'\n        color_completed = ' color=Green'\n    else:\n        color_running = ' color=Red'\n        color_pending = ' color=Black'\n        color_completed = ' color=Green'\n\n    id_list = print_output('active', color_running, True, print_content=False)\n\n    if len(id_list) \u003e 0:\n        print '---'\n\n    print_output(\n        'next',\n        color_pending,\n        False,\n        command='start',\n        highlight_id_list=id_list,\n        highlight_color=color_running,\n        highlight_command='stop',\n        alternate_command='done')\n\n    print '---'\n\n    # ok, so if you want to delete a command, you have to press done first ...\n    # sorry, but there is only one alternative command I can provide above ...\n    print_output(\n        'completed',\n        color_completed,\n        False,\n        command='start',\n        alternate_command='delete')\n\n    return\n\nif __name__ == \"__main__\":\n    import sys\n    main(sys.argv)\n"
				}
			],
			"path": "Lifestyle/taskwarrior.4m.py",
			"filename": "taskwarrior.4m.py",
			"dir": "Lifestyle",
			"docsPlugin": "Lifestyle/taskwarrior.4m.py.html",
			"docsCategory": "Lifestyle.html",
			"pathSegments": [
				"Lifestyle"
			],
			"categoryPathSegments": [
				{
					"path": "Lifestyle",
					"text": "Lifestyle",
					"isLast": true
				}
			],
			"title": "Taskwarrior",
			"version": "v2.0",
			"author": "Christoph Russ",
			"authors": [
				{
					"name": "Christoph Russ",
					"githubUsername": "christophruss",
					"imageURL": "https://avatars.githubusercontent.com/u/12080753?v=4",
					"bio": "",
					"primary": true
				}
			],
			"desc": "Task managment through your menu-bar.",
			"imageURL": "http://i.imgur.com/vjEt7Is.jpg",
			"dependencies": [
				"task",
				"python"
			],
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:21:56.297012Z",
			"vars": null
		},
		{
			"files": [
				{
					"path": "Lifestyle/transmission.4m.py",
					"filename": "transmission.4m.py",
					"content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# Transmission Remote\n#\n# \u003cbitbar.title\u003eTransmission Remote\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev1.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003eChristoph Russ\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003echristophruss\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003e\n# Checking transmission status, info and allowing adjustment to alternative speed.\n# Requires a single initial setup: `python transmission.4m.py init`\n# This plugin displays all not yet completed torrents using \"transmission-remote\" cli.\n# You can pause any torrent in the list by selecting them.\n# If all active downloads have completed, but some torrents had been paused, the oldest one will be unpaused automatically.\n# \u003c/bitbar.desc\u003e\n# \u003cbitbar.dependencies\u003etransmission-remote,python,keyring\u003c/bitbar.dependencies\u003e\n# \u003cbitbar.image\u003ehttp://i.imgur.com/hUWGq3u.jpg\u003c/bitbar.image\u003e\n#\n# Dependencies:\n#   transmission-remote (https://trac.transmissionbt.com/wiki/Building)\n#      available via homebrew `brew install transmission`\n#   keyring (https://github.com/jaraco/keyring)\n\nimport sys\nimport subprocess\nimport keyring\n\ndef init():\n    import getpass\n    print \"Enter your Transmission Server IP (e.g. 192.168.1.10 or 10.0.1.10): \"\n    host_ip = raw_input()\n    keyring.set_password(\"transmission-bitbar\", \"ip\", host_ip)\n    print \"Enter your Transmission port (default: 9091): \"\n    host_port = raw_input()\n    keyring.set_password(\"transmission-bitbar\", \"port\", host_port)\n    print \"Enter your Transmission user name: \"\n    usr = raw_input()\n    keyring.set_password(\"transmission-bitbar\", \"username\", usr)\n    print \"Enter your Transmission password: \"\n    pswd = getpass.getpass()\n    keyring.set_password(\"transmission-bitbar\", usr, pswd)\n    pswd = ''\n\ndef check_transmission(argv):\n    remote_bin = '/usr/local/bin/transmission-remote' # also make this configurable ?\n    host_ip = keyring.get_password(\"transmission-bitbar\", \"ip\")\n    host_port = keyring.get_password(\"transmission-bitbar\", \"port\")\n    host_user = keyring.get_password(\"transmission-bitbar\", \"username\")\n    host_pswd = keyring.get_password(\"transmission-bitbar\", host_user)\n\n    if 'slowdown' in argv:\n        subprocess.check_output(remote_bin+' '+host_ip+':'+host_port+' --auth '+host_user+':'+host_pswd+' -as', shell=True)\n        exit()\n    elif 'speedup' in argv:\n        subprocess.check_output(remote_bin+' '+host_ip+':'+host_port+' --auth '+host_user+':'+host_pswd+' -AS', shell=True)\n        exit()\n    elif 'pause' in argv:\n        subprocess.check_output(remote_bin+' '+host_ip+':'+host_port+' --auth '+host_user+':'+host_pswd+' -t ' + argv[-1] + ' -S', shell=True)\n    elif 'resume' in argv:\n        subprocess.check_output(remote_bin+' '+host_ip+':'+host_port+' --auth '+host_user+':'+host_pswd+' -t ' + argv[-1] + ' -s', shell=True)\n\n    session_info = subprocess.check_output(remote_bin+' '+host_ip+':'+host_port+' --auth '+host_user+':'+host_pswd+' -si -st', shell=True)\n    session_info_lines = session_info.split('\\n')\n\n    slow_speed = False\n\n    for session_info_line in session_info_lines:\n        if 'speed limit' in session_info_line:\n            if not 'Unlimited' in session_info_line:\n                slow_speed = True\n\n    info = subprocess.check_output(remote_bin+' '+host_ip+':'+host_port+' --auth '+host_user+':'+host_pswd+' -l', shell=True)\n    info_lines = info.split('\\n')\n\n    host_pswd = ''\n\n    return slow_speed,info_lines\n\ndef info_output(slow_speed, info_lines, auto_resume=True):\n    unfinished_lines = []\n    paused_lines = []\n\n    for info_line in info_lines:\n        if not '100%' in info_line and len(info_line)\u003e0:\n            if 'Stopped' in info_line:\n                paused_lines.append(info_line)\n            else:\n                unfinished_lines.append(info_line)\n\n    formatting = ''\n\n    if len(unfinished_lines) \u003c 3:\n        if len(paused_lines) \u003e 0:\n            if not auto_resume:\n                # nothing is actively downloading, but there are paused items in your queue\n                # red means - warning - you need to check this ...\n                formatting = formatting + ' | color=red'\n            else:\n                # with auto_resume we will automatically resume ONE of the items in the queue\n                # it could make sense to resume the smallest download with the simple assumtion that it will download the fastest\n                # of course this can and will lead to larger items being stuck in the queue forever\n                # it's also more work to actually query all info and parse it to find the smallest item in the paused queue\n                # it is a lot easier to just unpause the first (or last) item added to the queue (smallest ID)\n                # the items should already be in order, so we just pick the first one !\n                t_id = paused_lines[0].strip().split(' ')[0]\n                check_transmission([__file__, 'resume', t_id]) # file arg isn't really needed, but it's more consistent this way\n                unfinished_lines.insert(1, paused_lines[0]) #this may not be ordered by ID anymore after this step\n                paused_lines.pop(0) # or del(0) or [1:]\n\n        else:\n            # nothing is actually happening ... all downloads finished\n            formatting = formatting + ' | color=green'\n\n    # PRINTING \u003e.\u003c\n    if slow_speed:\n        print \"¶\" + formatting # | color=#808080 #grey: 999999 #lighter grey: b3b3b3\n    else:\n        print \"∞\" + formatting # | color=white\n\n    print \"---\"\n\n    if slow_speed:\n        print '∞ Unlimited Speed | refresh=true bash=/usr/bin/python param1='+__file__+' param2=speedup terminal=false'\n    else:\n        print '¶ Limit Speed | refresh=true bash=/usr/bin/python param1='+__file__+' param2=slowdown terminal=false'\n\n    print '---'\n\n    content_formatting = ' | size=12 font=Arial'\n    print unfinished_lines[0] + content_formatting\n\n    click_command = ' refresh=true bash=/usr/bin/python param1='+__file__+' param2=pause param3='\n\n    content_formatting = content_formatting + ' color=yellow'\n    for info_line in unfinished_lines[1:-1]:\n        t_id = info_line.strip().split(' ')[0]\n        print info_line + content_formatting + click_command + t_id + ' terminal=false'\n    content_formatting = content_formatting[:-13]\n\n    click_command = ' refresh=true bash=/usr/bin/python param1='+__file__+' param2=resume param3='\n\n    if len(paused_lines) \u003e 0:\n        content_formatting = content_formatting + ' color=red'\n        print '---'\n        for paused_line in paused_lines:\n            t_id = paused_line.strip().split(' ')[0]\n            print paused_line + content_formatting + click_command + t_id + ' terminal=false'\n    content_formatting = content_formatting[:-10]\n\n    print '---'\n    print unfinished_lines[-1] + content_formatting\n\ndef main(argv):\n    if 'init' in argv:\n        # this is an init call to setup account details, which should only have to be done once\n        # simply call:\n        # python ../transmission.4m.py init\n        # then enter your account details, which will be stored in your keychain !\n        # please note for this to work system level access to the created keychain items is REQUIRED\n        # technically any other app can thus read out this information from your keychain\n        # there is no easy way around this if you do not want to enter your password every time\n        init()\n\n    try:\n        slow_speed,info_lines = check_transmission(argv)\n        info_output(slow_speed,info_lines)\n    except Exception as e:\n        print \"¶ | color=yellow\" #error occured\n        print \"---\"\n        print \"Exception caught. Have you initialized this script?\"\n        print \"python \" + __file__ + \" init | refresh=true bash=/usr/bin/python param1=\" + __file__ + \" param2=init terminal=true\"\n        print \"---\"\n        print e\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n"
				}
			],
			"path": "Lifestyle/transmission.4m.py",
			"filename": "transmission.4m.py",
			"dir": "Lifestyle",
			"docsPlugin": "Lifestyle/transmission.4m.py.html",
			"docsCategory": "Lifestyle.html",
			"pathSegments": [
				"Lifestyle"
			],
			"categoryPathSegments": [
				{
					"path": "Lifestyle",
					"text": "Lifestyle",
					"isLast": true
				}
			],
			"title": "Transmission Remote",
			"version": "v1.0",
			"author": "Christoph Russ",
			"authors": [
				{
					"name": "Christoph Russ",
					"githubUsername": "christophruss",
					"imageURL": "https://avatars.githubusercontent.com/u/12080753?v=4",
					"bio": "",
					"primary": true
				}
			],
			"desc": "",
			"imageURL": "http://i.imgur.com/hUWGq3u.jpg",
			"dependencies": [
				"transmission-remote",
				"python",
				"keyring"
			],
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:21:56.436343Z",
			"vars": null
		}
	]
}