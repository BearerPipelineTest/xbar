{
	"person": {
		"name": "Henrik Nyh",
		"githubUsername": "henrik",
		"imageURL": "https://avatars.githubusercontent.com/u/216?v=4",
		"bio": "Swedish web developer and pug automator in West Yorkshire, UK.",
		"primary": true
	},
	"plugins": [
		{
			"files": [
				{
					"path": "Lifestyle/sureflap.15s.rb",
					"filename": "sureflap.15s.rb",
					"content": "#!/usr/bin/env ruby\n\n# \u003cbitbar.title\u003eSureFlap Pet Status\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev1.2.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003eHenrik Nyh\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003ehenrik\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eShow inside/outside status of pets using a SureFlap smart cat flap or pet door. Can also show notifications.\u003c/bitbar.desc\u003e\n# \u003cbitbar.dependencies\u003eruby\u003c/bitbar.dependencies\u003e\n\n# By Henrik Nyh \u003chttps://henrik.nyh.se\u003e 2019-12-16 under the MIT license.\n# Heavily based on the https://github.com/alextoft/sureflap PHP code by Alex Toft.\n#\n# Has no dependencies outside the Ruby standard library (uses Net::HTTP directly and painfully).\n\n\n# NOTE: You can configure these if you like:\n\n# You can exclude e.g. indoor-only pets from the menu bar by listing their names here. (But all pets show if you click the menu bar item.)\n# Example: [ \"Foocat\", \"Bardog\" ]\nHIDE_PETS_IN_MENU_BAR = [ ]\n\n# You can ignore pets entirely by listing their names here. They won't be listed anywhere, and no notifications sent.\n# Example: [ \"Foocat\", \"Bardog\" ]\nIGNORE_PETS_ENTIRELY = [ ]\n\n# Show a notification when in/out state changes?\nNOTIFICATIONS = true\n\n# Increase this number when you add üòª, remove üòø or rename pets or flaps/doors. You don't need to increase it if you just change the configuration above.\n# As long as this number remains unchanged, we will assume nothing's changed, which makes things faster and means we can check status more frequently.\nCACHE_VERSION = 1\n\n# End of configuration.\n\n\nrequire \"net/http\"\nrequire \"json\"\nrequire \"pp\"\nrequire \"time\"\nrequire \"fileutils\"\nrequire \"digest\"\n\nENDPOINT = \"https://app.api.surehub.io\"\nTOKEN_PATH = File.expand_path(\"~/.sureflap_token\")\nAUTH_PATH = File.expand_path(\"~/.sureflap_auth\")\n\nunless File.exist?(AUTH_PATH)\n  puts \":warning: Run: echo \\\"me@example.com / my_pw\\\" \u003e ~/.sureflap_auth\"\n  exit\nend\n\nEMAIL, PASSWORD = File.read(AUTH_PATH).strip.split(\" / \")\nAUTH_DATA = { email_address: EMAIL, password: PASSWORD, device_id: \"0\" }\n\n# From https://github.com/barsoom/net_http_timeout_errors/blob/master/lib/net_http_timeout_errors.rb\nNETWORK_ERRORS = [\n  EOFError,\n  Errno::ECONNREFUSED,\n  Errno::ECONNRESET,\n  Errno::EHOSTUNREACH,\n  Errno::EINVAL,\n  Errno::ENETUNREACH,\n  Errno::EPIPE,\n  Errno::ETIMEDOUT,\n  Net::HTTPBadResponse,\n  Net::HTTPHeaderSyntaxError,\n  Net::ProtocolError,\n  Net::ReadTimeout,\n  SocketError,\n  Timeout::Error,  # Also covers subclasses like Net::OpenTimeout.\n]\n\nclass StaleTokenError \u003c StandardError; end\n\ndef handle_network_errors\n  yield\nrescue *NETWORK_ERRORS =\u003e e\n  puts \"üôÄ\"\n  puts \"---\"\n  puts \"Network error when trying to communicate with the SureFlap API!\"\n  puts \"Check that you're not offline.\"\n  puts \"---\"\n  puts \"Technical details:\"\n  puts \"#{e.class.name}: #{e.message}\"\n  exit 1\nend\n\ndef post(path, data)\n  handle_network_errors do\n    uri = URI.join(ENDPOINT, path)\n    req = Net::HTTP::Post.new(uri, \"Content-Type\" =\u003e \"application/json\")\n    req.body = data.to_json\n\n    res = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(req) }\n    hash = JSON.parse(res.body)\n\n    raise \"HTTP error!\\n#{res.code} #{res.message}\\n#{hash.pretty_inspect}\" unless res.code == \"200\"\n\n    hash\n  end\nend\n\ndef get(path, token:, cache:)\n  if cache\n    cache_file = \"/tmp/sureflap_#{Digest::SHA256.hexdigest(\"#{path}-#{token}\")}_v#{CACHE_VERSION}\"\n    return JSON.parse(File.read(cache_file)) if File.exist?(cache_file)\n  end\n\n  handle_network_errors do\n    uri = URI.join(ENDPOINT, path)\n    req = Net::HTTP::Get.new(uri,\n      \"Content-Type\" =\u003e \"application/json\",\n      \"Authorization\" =\u003e \"Bearer #{token}\",\n    )\n\n    res = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(req) }\n    raw_json = res.body\n    hash = JSON.parse(raw_json)\n\n    error_message = \"HTTP error!\\n#{res.code} #{res.message}\\n#{hash.pretty_inspect}\" unless res.code == \"200\"\n\n    if res.code == \"401\" \u0026\u0026 hash.dig(\"error\", \"message\") == [ \"Token Signature could not be verified.\" ]\n      raise StaleTokenError, error_message\n    elsif res.code != \"200\"\n      raise error_message\n    end\n\n    File.write(cache_file, raw_json) if cache\n    hash\n  end\nend\n\ndef refresh_token\n  token = post(\"/api/auth/login\", AUTH_DATA).dig(\"data\", \"token\")\n  File.write(TOKEN_PATH, token)\n  token\nend\n\n# This method reuses an existing token until it becomes stale.\ndef with_fresh_token\n  retried = false\n\n  begin\n    token = File.exist?(TOKEN_PATH) \u0026\u0026 File.read(TOKEN_PATH) || refresh_token()\n    yield(token)\n  rescue StaleTokenError\n    raise if retried  # Avoid endless loops.\n    retried = true\n\n    FileUtils.rm(TOKEN_PATH)\n    retry\n  end\nend\n\nwith_fresh_token do |token|\n  # We assume a single household.\n  household_id = get(\"/api/household\", token: token, cache: true).dig(\"data\", 0, \"id\")\n\n  data =\n    get(\"/api/household/#{household_id}/pet\", token: token, cache: true).fetch(\"data\").map { |pet_data|\n      id = pet_data.fetch(\"id\")\n      name = pet_data.fetch(\"name\")\n      next if IGNORE_PETS_ENTIRELY.include?(name)\n\n      position_data = get(\"/api/pet/#{id}/position\", token: token, cache: false).fetch(\"data\")\n\n      is_inside = (position_data.fetch(\"where\") == 1)\n      since = Time.parse(position_data.fetch(\"since\")).localtime  # Convert from UTC to local time.\n\n      [ name, [ id, is_inside, since ] ]\n    }.compact.to_h\n\n  pets_in_summary = data.keys - HIDE_PETS_IN_MENU_BAR - IGNORE_PETS_ENTIRELY\n  raise \"There are no pets to summarize!\" if pets_in_summary.empty?\n\n  icon = -\u003e(is_inside) { is_inside ? \"üè†\" : \"üå≥\" }\n\n  puts pets_in_summary.map { |name|\n    _id, is_inside, _since = data.fetch(name)\n    \"#{icon.(is_inside)} #{name}\"\n  }.join(\"  \")\n\n  puts \"---\"\n\n  today = Date.today\n  data.each do |name, (id, is_inside, since)|\n    if NOTIFICATIONS\n      inside_state_path = \"/tmp/sureflap_#{id}_is_inside\"\n      previous_is_inside_string = File.read(inside_state_path) rescue nil\n\n      if previous_is_inside_string \u0026\u0026 previous_is_inside_string != is_inside.to_s\n        system(\"osascript\", \"-e\", %{display notification \"#{icon.(is_inside)} #{name} #{is_inside ? \"has entered‚Ä¶ Hi #{name}!\" : \"has left‚Ä¶ Bye #{name}!\" }\" with title \"Cat flap\"})\n      end\n\n      File.write(inside_state_path, is_inside)\n    end\n\n    formatting_string =\n      case since.to_date\n      when today then \"%H:%M\"\n      when today - 1 then \"yesterday at %H:%M\"\n      when (today - 2)..(today - 6) then \"%a at %H:%M\"\n      else \"%b %-d %Y at %H:%M\"\n      end\n    puts \"#{icon.(is_inside)} #{name} is #{is_inside ? \"inside\" : \"outside\"} since #{since.strftime(formatting_string)}.\"\n  end\nend\n"
				}
			],
			"path": "Lifestyle/sureflap.15s.rb",
			"filename": "sureflap.15s.rb",
			"dir": "Lifestyle",
			"docsPlugin": "Lifestyle/sureflap.15s.rb.html",
			"docsCategory": "Lifestyle.html",
			"pathSegments": [
				"Lifestyle"
			],
			"categoryPathSegments": [
				{
					"path": "Lifestyle",
					"text": "Lifestyle",
					"isLast": true
				}
			],
			"title": "SureFlap Pet Status",
			"version": "v1.2.0",
			"author": "Henrik Nyh",
			"authors": [
				{
					"name": "Henrik Nyh",
					"githubUsername": "henrik",
					"imageURL": "https://avatars.githubusercontent.com/u/216?v=4",
					"bio": "Swedish web developer and pug automator in West Yorkshire, UK.",
					"primary": true
				}
			],
			"desc": "Show inside/outside status of pets using a SureFlap smart cat flap or pet door. Can also show notifications.",
			"imageURL": "https://xbarapp.com/public/img/xbar-2048.png",
			"dependencies": [
				"ruby"
			],
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:21:55.957563Z",
			"vars": null
		}
	]
}