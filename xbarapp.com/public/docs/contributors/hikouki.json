{
	"person": {
		"name": "Kouki Higashikawa",
		"githubUsername": "hikouki",
		"imageURL": "https://avatars.githubusercontent.com/u/15326035?v=4",
		"bio": ":airplane:",
		"primary": true
	},
	"plugins": [
		{
			"files": [
				{
					"path": "Dev/backlog-show-my-task.1m.rb",
					"filename": "backlog-show-my-task.1m.rb",
					"content": "#!/usr/bin/env ruby\n# coding: utf-8\n\n# \u003cbitbar.title\u003eBacklog Show My Task\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev1.0.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003ehikouki\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003ehikouki\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eShow Backlog open ticket for mine\u003c/bitbar.desc\u003e\n# \u003cbitbar.image\u003ehttps://raw.githubusercontent.com/hikouki/bitbar-backlog/master/preview.png\u003c/bitbar.image\u003e\n# \u003cbitbar.dependencies\u003eruby\u003c/bitbar.dependencies\u003e\n# \u003cbitbar.abouturl\u003ehttps://github.com/hikouki\u003c/bitbar.abouturl\u003e\n\nrequire 'net/http'\nrequire 'uri'\nrequire 'json'\n\n# a6140cbf6e84a0bAffb0cX49138fc5687310b518\n#   or\n# launchctl setenv BACKLOG_ACCESS_TOKEN a6140cbf6e84a0bAffb0cX49138fc5687310b518\nTOKEN = ENV[\"BACKLOG_ACCESS_TOKEN\"] || ''\n# https://xxxx.backlog.jp\n#   or\n# launchctl setenv BACKLOG_URL https://xxxx.backlog.jp\nBACKLOG_URL = ENV[\"BACKLOG_URL\"] || ''\n\nbegin\n\n  myself_api = URI.parse(\"#{BACKLOG_URL}/api/v2/users/myself\")\n  myself_api.query = URI.encode_www_form(apiKey: TOKEN)\n\n  myself_res = Net::HTTP.start(myself_api.host, myself_api.port, use_ssl: myself_api.scheme == 'https') do | http |\n    http.get(myself_api.request_uri)\n  end\n\n  raise \"error #{myself_res.code} #{myself_res.message}\" if myself_res.code != '200'\n\n  me = JSON.parse(myself_res.body, symbolize_names: true)\n\n  issues_api = URI.parse(\"#{BACKLOG_URL}/api/v2/issues\")\n  issues_api.query = URI.encode_www_form(apiKey: TOKEN, 'assigneeId[]' =\u003e me[:id], count: 100)\n\n  issues_res = Net::HTTP.start(issues_api.host, issues_api.port, use_ssl: issues_api.scheme == 'https') do | http |\n    http.get(issues_api.request_uri)\n  end\n\n  raise \"error #{issues_res.code} #{issues_res.message}\" if issues_res.code != '200'\n\n  issues = JSON.parse(issues_res.body, symbolize_names: true)\n\n  projects = Hash.new do | h, k |\n    h[k] = {\n      name: \"\u003cproject name\u003e\",\n      issue_count: 0,\n      issue_type_groups: Hash.new do | h1, k1 |\n        h1[k1] = {\n          name: \"\u003ctype name\u003e\",\n          color: \"\u003ctype color\u003e\",\n          issue_status_groups: Hash.new do | h2, k2 |\n            h2[k2] = {\n              name: \"\u003cstatus name\u003e\",\n              issues: []\n            }\n          end\n        }\n      end\n    }\n  end\n\n  issues.each do | issue |\n    project_id = issue[:projectId]\n    issue_type_id = issue[:issueType][:id]\n    issue_status_id = issue[:status][:id]\n\n    projects[project_id][:issue_count] += 1\n    projects[project_id][:issue_type_groups][issue_type_id][:name] = issue[:issueType][:name]\n    projects[project_id][:issue_type_groups][issue_type_id][:color] = issue[:issueType][:color]\n    projects[project_id][:issue_type_groups][issue_type_id][:issue_status_groups][issue_status_id][:name] = issue[:status][:name]\n    projects[project_id][:issue_type_groups][issue_type_id][:issue_status_groups][issue_status_id][:issues].push(\n      {\n        key: issue[:issueKey],\n        summary: issue[:summary]\n      }\n    )\n  end\n\n  puts issues.empty? ? \"◈ | color=#7d7d7d\" : \"◈ #{issues.count}\"\n  puts \"---\"\n  puts \"Backlog | color=black href=#{BACKLOG_URL}\"\n  puts \"---\"\n\n  projects.each do | project_id, project |\n    project_api = URI.parse(\"#{BACKLOG_URL}/api/v2/projects/#{project_id}\")\n    project_api.query = URI.encode_www_form(apiKey: TOKEN)\n\n    project_res = Net::HTTP.start(project_api.host, project_api.port, use_ssl: project_api.scheme == 'https') do | http |\n      http.get(project_api.request_uri)\n    end\n\n    raise \"error #{project_res.code} #{project_res.message}\" if project_res.code != '200'\n\n    project_info = JSON.parse(project_res.body, symbolize_names: true)\n\n    puts \"#{project_info[:name]}: #{project[:issue_count]} | size=11\"\n    project[:issue_type_groups].each do | _, type_group |\n      puts \"➠ #{type_group[:name]} | color=#{type_group[:color]} size=11\"\n      type_group[:issue_status_groups].each do | _, status_group |\n        puts \"[#{status_group[:name]}] | color=#58BE89 size=11\"\n        status_group[:issues].each do | issue |\n          prefix = status_group[:issues].last == issue ? \"└\" : \"├\"\n          puts \"#{prefix} #{issue[:summary]} | color=black href=#{BACKLOG_URL}/view/#{issue[:key]} size=11\"\n        end\n      end\n    end\n    puts \"---\"\n  end\n\n  puts \"---\"\n  puts \"Refresh | color=#7d7d7d refresh=true\"\n\nrescue =\u003e e\n  puts \"◈ ! | color=#ECB935\"\n  puts \"---\"\n  puts \"Exception: #{$!}\"\n  puts e.backtrace\nend\n"
				}
			],
			"path": "Dev/backlog-show-my-task.1m.rb",
			"filename": "backlog-show-my-task.1m.rb",
			"dir": "Dev",
			"docsPlugin": "Dev/backlog-show-my-task.1m.rb.html",
			"docsCategory": "Dev.html",
			"pathSegments": [
				"Dev"
			],
			"categoryPathSegments": [
				{
					"path": "Dev",
					"text": "Dev",
					"isLast": true
				}
			],
			"title": "Backlog Show My Task",
			"version": "v1.0.0",
			"author": "hikouki",
			"authors": [
				{
					"name": "Kouki Higashikawa",
					"githubUsername": "hikouki",
					"imageURL": "https://avatars.githubusercontent.com/u/15326035?v=4",
					"bio": ":airplane:",
					"primary": true
				}
			],
			"desc": "Show Backlog open ticket for mine",
			"imageURL": "https://raw.githubusercontent.com/hikouki/bitbar-backlog/master/preview.png",
			"dependencies": [
				"ruby"
			],
			"aboutURL": "https://github.com/hikouki",
			"lastUpdated": "2021-03-08T15:21:50.89196Z",
			"vars": null
		},
		{
			"files": [
				{
					"path": "Dev/redmine-show-my-task.1m.rb",
					"filename": "redmine-show-my-task.1m.rb",
					"content": "#!/usr/bin/env ruby\n# coding: utf-8\n\n# \u003cbitbar.title\u003eRedmine Show My Task\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev1.0.1\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003ehikouki\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003ehikouki\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eShow Redmine open ticket for mine\u003c/bitbar.desc\u003e\n# \u003cbitbar.image\u003ehttps://raw.githubusercontent.com/hikouki/bitbar-redmine/master/preview.png\u003c/bitbar.image\u003e\n# \u003cbitbar.dependencies\u003eruby\u003c/bitbar.dependencies\u003e\n# \u003cbitbar.abouturl\u003ehttps://github.com/hikouki\u003c/bitbar.abouturl\u003e\n\nrequire 'net/http'\nrequire 'uri'\nrequire 'json'\n\n# a6140cbf6e84a0bAffb0cX49138fc5687310b518\n#   or\n# launchctl setenv REDMINE_ACCESS_TOKEN a6140cbf6e84a0bAffb0cX49138fc5687310b518\ntoken = ENV[\"REDMINE_ACCESS_TOKEN\"] || ''\n# https://redmine.xxxx.com\n#   or\n# launchctl setenv REDMINE_URL https://redmine.xxxx.com\nredmine_url = ENV[\"REDMINE_URL\"] || ''\n\nuri = URI.parse(\"#{redmine_url}/issues.json?key=#{token}\u0026limit=100\u0026status_id=open\u0026assigned_to_id=me\")\n\nbegin\n  http = Net::HTTP.new(uri.host, uri.port)\n  http.use_ssl = true if(uri.scheme == 'https')\n  res = http.start {\n    http.get(uri.request_uri)\n  }\n\n  raise \"error #{res.code} #{res.message}\" if res.code != '200'\n\n  result = JSON.parse(res.body, symbolize_names: true)\n  issues = result[:issues]\n\n  projects = Hash.new do | h, k |\n    h[k] = {\n      issues_count: 0,\n      trackers: Hash.new do | h1, k1 |\n        h1[k1] = {\n          name: \"tracker name.\",\n          issues: Hash.new {| h2, k2 | h2[k2] = []}\n        }\n      end\n    }\n  end\n\n  dark_mode = `defaults read -g AppleInterfaceStyle 2\u003e/dev/null`\n  if dark_mode.include? \"Dark\" then\n    main_color = \"#FFFFFF\"\n    project_color = \"#FEFEFE\"\n    issue_color = \"#CCCCCC\"\n    tracker_color = \"#33BFDB\"\n    status_color = \"#58BE89\"\n  else\n    main_color = \"black\"\n    project_color = \"black\"\n    issue_color = \"black\"\n    tracker_color = \"#33BFDB\"\n    status_color = \"#58BE89\"\n  end\n\n  last_issue_id = 0\n\n  issues.each do | v |\n    last_issue_id = v[:id] if last_issue_id == 0 \n    project_id   = v[:project][:id]\n    project_name = v[:project][:name]\n    status_id    = v[:status][:id]\n    tracker_id   = v[:tracker][:id]\n    tracker_name = v[:tracker][:name]\n    projects[project_id][:issues_count] += 1\n    projects[project_id][:id] = project_id\n    projects[project_id][:name] = project_name\n    projects[project_id][:trackers][tracker_id][:name] = tracker_name\n    projects[project_id][:trackers][tracker_id][:issues][status_id].push(v)\n  end\n\n  issue_total_count = result[:total_count] \u003e 99 ? '99+' : result[:total_count]\n  issue_last = last_issue_id != 0 ? \" - ##{last_issue_id}\" : \"\"\n  puts issues.empty? ? \"✦ | color=#7d7d7d\" : \"✦ #{issue_total_count}#{issue_last}\"\n  puts \"---\"\n  puts \"Redmine | color=#{main_color} href=#{redmine_url}\"\n  puts \"---\"\n\n  projects.each do | _, project |\n    puts \"#{project[:name]}: #{project[:issues_count]} | color=#{project_color} size=11\"\n    project[:trackers].each do | _, tracker |\n      puts \"➠ #{tracker[:name]} | color=#{tracker_color} size=11\"\n      tracker[:issues].each do | _, status |\n        puts \"[#{status.first[:status][:name]}] | color=#{status_color} size=11\"\n        status.each do | issue |\n          prefix = status.last == issue ? \"└\" : \"├\"\n          puts \"#{prefix} ##{issue[:id]} #{issue[:subject]} | color=#{issue_color} href=#{redmine_url}/issues/#{issue[:id]} size=11\"\n        end\n      end\n    end\n    puts \"---\"\n  end\nrescue\n  puts \"✦ ! | color=#ECB935\"\n  puts \"---\"\n  puts \"Exception: #{$!}\"\nend\n"
				}
			],
			"path": "Dev/redmine-show-my-task.1m.rb",
			"filename": "redmine-show-my-task.1m.rb",
			"dir": "Dev",
			"docsPlugin": "Dev/redmine-show-my-task.1m.rb.html",
			"docsCategory": "Dev.html",
			"pathSegments": [
				"Dev"
			],
			"categoryPathSegments": [
				{
					"path": "Dev",
					"text": "Dev",
					"isLast": true
				}
			],
			"title": "Redmine Show My Task",
			"version": "v1.0.1",
			"author": "hikouki",
			"authors": [
				{
					"name": "Kouki Higashikawa",
					"githubUsername": "hikouki",
					"imageURL": "https://avatars.githubusercontent.com/u/15326035?v=4",
					"bio": ":airplane:",
					"primary": true
				}
			],
			"desc": "Show Redmine open ticket for mine",
			"imageURL": "https://raw.githubusercontent.com/hikouki/bitbar-redmine/master/preview.png",
			"dependencies": [
				"ruby"
			],
			"aboutURL": "https://github.com/hikouki",
			"lastUpdated": "2021-03-08T15:21:52.146697Z",
			"vars": null
		}
	]
}