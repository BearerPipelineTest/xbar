{
	"person": {
		"name": "Simeon Cheeseman",
		"githubUsername": "simeonc",
		"imageURL": "https://avatars.githubusercontent.com/u/1085899?v=4",
		"bio": "",
		"primary": true
	},
	"plugins": [
		{
			"files": [
				{
					"path": "Dev/Gitlab/gitlab_merge_requests.js",
					"filename": "gitlab_merge_requests.js",
					"content": "#!/usr/bin/env /usr/local/bin/node\n// jshint asi:true\n// jshint esversion: 8\n// \u003cbitbar.title\u003eGitLab Merge Requests\u003c/bitbar.title\u003e\n// \u003cbitbar.version\u003ev1.0\u003c/bitbar.version\u003e\n// \u003cbitbar.author\u003eSimeon Cheeseman\u003c/bitbar.author\u003e\n// \u003cbitbar.author.github\u003esimeonc\u003c/bitbar.author.github\u003e\n// \u003cbitbar.desc\u003eList of your assigned and created merge requests.\n// The menu bar shows a count of MRs requiring your approval (üîé), WIP MRs (üõ†Ô∏è), Un-mergable MRs (‚õî), MRs with failed pipelines (‚ö†Ô∏è), MRs with unresolved discussions (üöß), MRs with running pipeline (üöÄ), MRs pending approval (üí¨) and Approved/Ready to Merge (‚ùáÔ∏è).\n// Each MR in the dropdown is grouped by project and displays `\u003cUnmergable\u003e \"Title\"; \"Pipeline Status\" : \"Approval Status\"`, clicking on an MR opens it in the browser\u003c/bitbar.desc\u003e\n// \u003cbitbar.dependencies\u003enode.js\u003c/bitbar.dependencies\u003e\n// \u003cbitbar.image\u003ehttps://i.imgur.com/t0TtQXO.png\u003c/bitbar.image\u003e\n\n/**\n * Information\n *\n * This was inspired by the work of Shelton Koskie (@eightygrit), who made the\n * first version of the \"GITLAB Projects\" for API v4.\n *\n * @see   GitLab API Documentation    https://docs.gitlab.com/ee/api/README.html\n * @see   Create GitLab Access Token  https://gitlab.com/profile/personal_access_tokens\n * @see   BitBar Node Module Docs     https://github.com/sindresorhus/bitbar\n */\n\n/**\n * The domain your instance is hosted on. Leave the default if using gitlab.com\n *\n * @const       {string}\n */\nconst gitlab_domain = 'gitlab.com';\n\n/**\n * Your private access token.\n *\n * @const       {string}\n * @see       Create a token  https://gitlab.com/profile/personal_access_tokens\n */\nconst private_token = '7Tkm2aLMxk8q-M9TaJz1';\n\n/**\n * Font size of the project list\n *\n * @const       {string}\n */\nconst font_size = '15';\n\n/**\n * Change this array to choose which statuses show and in what order on the menu bar.\n *\n * @type {string[]}\n */\nconst MENU_BAR_ORDER = [\n  'newMR',\n  'reviewer',\n  'wip',\n  'unmergable',\n  'failed',\n  'unresolved',\n  'ciRunning',\n  'pending',\n  'approved'\n];\n\n/**\n * MAX length of the title string in the toolbar\n *\n * @type {number}\n */\nconst MAX_LENGTH = 60;\n\n/////////////////////////////////////////////////////////////////////////\n// Do not edit below this line unless you know what you're doing. :)  //\n///////////////////////////////////////////////////////////////////////\nlet bitbar;\nconst fs = require('fs');\nconst path = require('path');\nconst SETTINGS_FILE_PATH = path.resolve(\n  __dirname,\n  './.gitlab_merge_requests.settings.json'\n);\n\n// Verify bitbar node module is available or try to install it globally.\ntry {\n  bitbar = require('bitbar');\n} catch (e) {\n  try {\n    bitbar = globalRequire('bitbar');\n  } catch (e) {\n    installBitbarModule();\n\n    // Not catching error if one is thrown.\n    bitbar = globalRequire('bitbar');\n  }\n}\n\n// Converts the gitlab status to emoji\n// see https://emojipedia.org/ for customisation\nfunction stateIcon(status) {\n  return {\n    created: 'üí§',\n    pending: 'üí§',\n    running: 'üöÄ',\n    failed: '‚ö†Ô∏è',\n    success: '‚úÖ',\n    skipped: 'üöÄ',\n    manual: '‚èØÔ∏è'\n  }[status];\n}\n\nconst gitlabIconBase64 =\n  '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';\n\nfunction request(path) {\n  const httpTransport = require('https');\n  const responseEncoding = 'utf8';\n  const httpOptions = {\n    hostname: gitlab_domain,\n    port: '443',\n    path,\n    method: 'GET',\n    headers: { 'PRIVATE-TOKEN': private_token }\n  };\n  httpOptions.headers['User-Agent'] =\n    'bitbar/gitlab_projects - node ' + process.version;\n\n  return new Promise((resolve, reject) =\u003e {\n    const request = httpTransport\n    .request(httpOptions, (res) =\u003e {\n      let responseBufs = [];\n      let responseStr = '';\n\n      res\n      .on('data', (chunk) =\u003e {\n        if (Buffer.isBuffer(chunk)) {\n          responseBufs.push(chunk);\n        } else {\n          responseStr = responseStr + chunk;\n        }\n      })\n      .on('end', () =\u003e {\n        if (responseBufs.length \u003e 0) {\n          responseStr = Buffer.concat(responseBufs).toString(responseEncoding);\n        } else {\n          responseStr = responseStr;\n        }\n\n        resolve(JSON.parse(responseStr));\n      });\n    })\n    .setTimeout(0)\n    .on('error', (error) =\u003e {\n      reject(error);\n    });\n    request.write('');\n    request.end();\n  });\n}\n\nconst cachedProjectNames = {};\nasync function registerProject(project_id) {\n  if (!cachedProjectNames[project_id]) {\n    const project = await request(`/api/v4/projects/${project_id}`);\n    cachedProjectNames[project_id] = project.name_with_namespace;\n  }\n}\n\nasync function getMRs() {\n  if (!fs.existsSync(SETTINGS_FILE_PATH)) {\n    const myUser = await request('/api/v4/user');\n    fs.writeFileSync(\n      SETTINGS_FILE_PATH,\n      JSON.stringify({\n        userId: myUser.id\n      })\n    );\n  }\n\n  const statusCount = {};\n  function incrementStatusCount(key) {\n    statusCount[key] = statusCount[key] || 0;\n    statusCount[key] += 1;\n  }\n\n  const mergeRequestsByProjectId = {};\n\n  const yesterday = new Date();\n  yesterday.setDate(yesterday.getDate() - 1);\n  const yesterdayParam = `${yesterday.getFullYear()}-${yesterday.getMonth() + 1}-${yesterday.getDate()}`;\n\n  const { userId, todaysUUID, todaysExcludedEvents = [] } = JSON.parse(fs.readFileSync(SETTINGS_FILE_PATH));\n  let excludedEvents = [];\n  if (todaysUUID === yesterdayParam) {\n    excludedEvents = todaysExcludedEvents;\n  }\n\n  const createdMRs = await request(\n    '/api/v4/merge_requests?scope=created_by_me\u0026state=opened'\n  );\n  const assignedMRs = await request(\n    '/api/v4/merge_requests?scope=assigned_to_me\u0026state=opened'\n  );\n  const approvalMRs = await request(\n    `/api/v4/merge_requests?scope=all\u0026state=opened\u0026approver_ids[]=${userId}`\n  );\n\n  const allMRs = assignedMRs\n  .concat(approvalMRs, createdMRs)\n  .reduce((uniqueMRs, currentMR) =\u003e {\n    if (!uniqueMRs.find(({ id }) =\u003e id === currentMR.id)) {\n      uniqueMRs.push(currentMR);\n    }\n    return uniqueMRs;\n  }, []);\n\n  const bitbar = globalRequire('bitbar');\n\n  if (allMRs.length === 0) {\n    // Hide when no open MRs\n    return bitbar([\n      {\n        image: gitlabIconBase64,\n        text: `0 MR`,\n        color: bitbar.darkMode ? 'white' : 'black',\n        dropdown: true\n      }\n    ]);\n  }\n\n\n  await Promise.all(\n    allMRs.map(async (mergeRequest) =\u003e {\n      const {\n        web_url,\n        merge_when_pipeline_succeeds,\n        merge_status,\n        title,\n        project_id,\n        iid,\n        blocking_discussions_resolved,\n        work_in_progress,\n        assignee,\n        assignees,\n        author,\n        source_branch\n      } = mergeRequest;\n      excludedEvents.push(`${project_id}_${source_branch}`);\n\n      const isReviewer =\n        (!author || author.id !== userId) \u0026\u0026\n        (!assignee || assignee.id !== userId) \u0026\u0026\n        (!assignees || !assignees.find(({ id }) =\u003e id === userId));\n\n      await registerProject(project_id);\n\n      mergeRequestsByProjectId[project_id] =\n        mergeRequestsByProjectId[project_id] || [];\n\n      const pipelines = await request(\n        `/api/v4/projects/${project_id}/merge_requests/${iid}/pipelines`\n      );\n      let pipelineStatus = '';\n      if (pipelines.length) {\n        pipelineStatus = stateIcon(pipelines[0].status);\n      }\n      const approvals = await request(\n        `/api/v4/projects/${project_id}/merge_requests/${iid}/approval_state`\n      );\n      const isApproved = approvals.rules.reduce(\n        (isApproved, { approved }) =\u003e isApproved \u0026\u0026 approved,\n        true\n      );\n      const hasCurrentUserApproved = approvals.rules.reduce(\n        (currentUserHasApproved, { approved_by }) =\u003e\n          currentUserHasApproved ||\n          !!approved_by.find(({ id }) =\u003e id === userId),\n        false\n      );\n      const canMerge = merge_status === 'can_be_merged';\n      if (isReviewer \u0026\u0026 (work_in_progress || !canMerge || isApproved || hasCurrentUserApproved))\n        return;\n      let mergeStatus = '  ';\n      if (!canMerge) {\n        mergeStatus = '‚õî ';\n      } else if (isReviewer) {\n        mergeStatus = 'üîé ';\n      }\n      let approvalStatus = 'üí¨';\n      if (work_in_progress) {\n        approvalStatus = 'üõ†Ô∏è';\n      } else if (!blocking_discussions_resolved) {\n        approvalStatus = 'üöß';\n      } else if (isApproved) {\n        approvalStatus = '‚ùáÔ∏è';\n      }\n      if (isReviewer) {\n        incrementStatusCount('reviewer');\n      } else if (work_in_progress) {\n        incrementStatusCount('wip');\n      } else if (merge_status !== 'can_be_merged') {\n        incrementStatusCount('unmergeable');\n      } else if (pipelines.length \u0026\u0026 pipelines[0].status === 'failed') {\n        incrementStatusCount('failed');\n      } else if (!blocking_discussions_resolved) {\n        incrementStatusCount('unresolved');\n      } else if (pipelines.length \u0026\u0026 pipelines[0].status === 'running') {\n        incrementStatusCount('ciRunning');\n      } else if (!isApproved) {\n        incrementStatusCount('pending');\n      } else {\n        incrementStatusCount('approved');\n      }\n\n      let statusString = '';\n      if (pipelineStatus || approvals.rules.length) {\n        const statusStrings = [];\n        if (pipelineStatus) statusStrings.push(pipelineStatus);\n        if (approvals.rules.length) statusStrings.push(approvalStatus);\n        statusString = `  ${statusStrings.join(' ')}`;\n      }\n      let trimmedTitle = title.substring(0, MAX_LENGTH);\n      if (title.length \u003e MAX_LENGTH) {\n        trimmedTitle += '...';\n      }\n      mergeRequestsByProjectId[project_id].push(\n        `${mergeStatus}!${iid}: ${trimmedTitle}${statusString} | href=\"${web_url}\" size=${font_size}`\n      );\n    })\n  );\n\n  const todaysEvents = await request(\n    `/api/v4/users/4557473/events?after=${yesterdayParam}\u0026action=pushed`\n  );\n  for (let i = 0; i \u003c todaysEvents.length; i += 1) {\n    const { project_id, push_data: {action, ref, ref_type, commit_to} } = todaysEvents[i];\n    if (excludedEvents.indexOf(`${project_id}_${ref}`) !== -1) continue;\n    if (!(action === 'created' \u0026\u0026 ref_type === 'branch')) continue;\n\n    const mrCheck = await request(`/api/v4/projects/${project_id}/repository/commits/${commit_to}/merge_requests`);\n    if (mrCheck.length) {\n      excludedEvents.push(`${project_id}_${ref}`);\n      continue;\n    }\n    await registerProject(project_id);\n    const { web_url } = await request(`/api/v4/projects/${project_id}`);\n    const params = [\n      `merge_request%5Bsource_branch%5D=${ref}`,\n      `merge_request%5Bsource_project_id%5D=${project_id}`,\n      `merge_request%5Btarget_project_id%5D=${project_id}`\n    ];\n    const createMRUrl = `${web_url}/-/merge_requests/new?${params.join('\u0026')}`;\n    mergeRequestsByProjectId[project_id] = mergeRequestsByProjectId[project_id] || [];\n    mergeRequestsByProjectId[project_id].unshift(\n      `üìù: ${ref} | href=\"${createMRUrl}\" size=${font_size}`\n    );\n    incrementStatusCount('newMR');\n  }\n\n  const content = [];\n\n  const statusMap = {\n    reviewer: 'üîé',\n    unmergable: '‚õî',\n    failed: '‚ö†Ô∏è',\n    ciRunning: 'üöÄ',\n    pending: 'üí¨',\n    approved: '‚ùáÔ∏è',\n    wip: 'üõ†Ô∏è',\n    unresolved: 'üöß',\n    newMR: 'üìù'\n  };\n  const statusString = MENU_BAR_ORDER\n  .map((key) =\u003e {\n    if (statusCount[key]) {\n      return `${statusMap[key]}[${statusCount[key]}]`;\n    }\n  })\n  .filter((s) =\u003e !!s)\n  .join(', ');\n\n  content.push({\n    image: gitlabIconBase64,\n    text: `${statusString}`,\n    color: bitbar.darkMode ? 'white' : 'black',\n    dropdown: true\n  });\n\n  Object.keys(mergeRequestsByProjectId).forEach((projectId) =\u003e {\n    if (!mergeRequestsByProjectId[projectId].length) return;\n    content.push(bitbar.separator);\n    content.push({\n      text: cachedProjectNames[projectId]\n    });\n    mergeRequestsByProjectId[projectId].forEach((text) =\u003e\n      text ? content.push({ text }) : null\n    );\n  });\n\n  // Update settings file for speed later\n  fs.writeFileSync(\n    SETTINGS_FILE_PATH,\n    JSON.stringify({\n      userId,\n      todaysUUID: yesterdayParam,\n      todaysExcludedEvents: excludedEvents.reduce((uniqueEvents, event) =\u003e {\n        if (uniqueEvents.indexOf(event) === -1) {\n          uniqueEvents.push(event);\n        }\n        return uniqueEvents;\n      }, [])\n    })\n  );\n\n  try {\n    bitbar(content);\n  } catch (error) {\n    console.log(content);\n    throw error;\n  }\n}\n\ngetMRs().catch((error) =\u003e {\n  console.error(error);\n});\n\n/**\n * Sets up the ability to require global node packages.\n *\n * @return     {object}  Returns the required node package object\n */\nfunction globalRequire(package) {\n  const childProcess = require('child_process');\n  const path = require('path');\n  const fs = require('fs');\n  const env = Object.assign({}, process.env);\n  env.PATH = path.resolve('/usr/local/bin') + ':' + env.PATH;\n\n  const globalNodeModulesDir =\n    childProcess\n    .execSync(npmBin() + ' root -g', { env: env })\n    .toString()\n    .trim() + '/';\n  let packageDir = path.join(globalNodeModulesDir, package, '/');\n\n  //find package required by older versions of npm\n  if (!fs.existsSync(packageDir)) {\n    packageDir = path.join(globalNodeModulesDir, 'npm/node_modules/', package);\n  }\n\n  // Package not found\n  if (!fs.existsSync(packageDir)) {\n    throw new Error(\"Cannot find global module '\" + package + \"'\");\n  }\n\n  const packageMeta = JSON.parse(\n    fs.readFileSync(path.join(packageDir, 'package.json')).toString()\n  );\n  const main = path.join(packageDir, packageMeta.files[0]);\n\n  return require(main);\n}\n\n/**\n * Installs Bitbar node module if it doesn't exits.\n *\n * @see    BitBar node module on github    https://github.com/sindresorhus/bitbar\n */\nfunction installBitbarModule() {\n  // Allows one to run the npm command as if on the command line.\n  const childProcess = require('child_process');\n  const execSync = childProcess.execSync;\n  const path = require('path');\n  const fs = require('fs');\n\n  const env = Object.assign({}, process.env);\n  env.PATH = path.resolve('/usr/local/bin') + ':' + env.PATH;\n\n  // Get the path to npm bin\n  const npm = npmBin();\n\n  // The install command\n  const cmd = npm + ' install -g bitbar';\n\n  console.log('Installing the BitBar Node module...');\n\n  const output = execSync(cmd, {\n    cwd: process.cwd(),\n    env: env\n  })\n  .toString('utf8')\n  .trim();\n\n  console.log('Installation complete.');\n}\n\n/**\n * Gets the path to your npm executable.\n *\n * @return  {string}  The full path to your npm executable\n */\nfunction npmBin() {\n  const path = require('path');\n  const childProcess = require('child_process');\n  const execSync = childProcess.execSync;\n  const env = Object.assign({}, process.env);\n  env.PATH = path.resolve('/usr/local/bin') + ':' + env.PATH;\n  const buffs = [];\n\n  // Get the path to npm bin\n  return execSync('which npm', { env: env })\n  .toString('utf8')\n  .trim();\n}\n"
				}
			],
			"path": "Dev/Gitlab/gitlab_merge_requests.js",
			"filename": "gitlab_merge_requests.js",
			"dir": "Dev/Gitlab",
			"docsPlugin": "Dev/Gitlab/gitlab_merge_requests.js.html",
			"docsCategory": "Dev/Gitlab.html",
			"pathSegments": [
				"Dev",
				"Gitlab"
			],
			"categoryPathSegments": [
				{
					"path": "Dev",
					"text": "Dev",
					"isLast": false
				},
				{
					"path": "Dev/Gitlab",
					"text": "Gitlab",
					"isLast": true
				}
			],
			"title": "GitLab Merge Requests",
			"version": "v1.0",
			"author": "Simeon Cheeseman",
			"authors": [
				{
					"name": "Simeon Cheeseman",
					"githubUsername": "simeonc",
					"imageURL": "https://avatars.githubusercontent.com/u/1085899?v=4",
					"bio": "",
					"primary": true
				}
			],
			"desc": "",
			"imageURL": "https://i.imgur.com/t0TtQXO.png",
			"dependencies": [
				"node.js"
			],
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:21:48.895054Z",
			"vars": null
		}
	]
}