{
	"person": {
		"name": "Yann Milin",
		"githubUsername": "ymilin",
		"imageURL": "https://avatars.githubusercontent.com/u/3737075?v=4",
		"bio": "",
		"primary": true
	},
	"plugins": [
		{
			"files": [
				{
					"path": "Travel/travel-time.5m.php",
					"filename": "travel-time.5m.php",
					"content": "#!/usr/bin/env php\n\u003c?php\n/**\n * Provides travel distance and time for your favorite destination, with traffic conditions.\n *\n * A Google Developer Account is required with access to \"Google Maps Distance Matrix API\" and \"Google Maps Geolocation API\"\n *\n * How does it work:\n * - perform a Wifi Access Point scan using airport utility command\n * - Get current position (lat,lng) with Geolocation API using collected AP data\n * - Get distance, time and traffic delay using the Distance Matrix API\n *\n * @link https://console.developers.google.com/apis/enabled\n * @link https://developers.google.com/maps/documentation/geolocation/\n * @link https://developers.google.com/maps/documentation/distance-matrix/\n *\n * \u003cbitbar.title\u003eTravel time\u003c/bitbar.title\u003e\n * \u003cbitbar.version\u003e1.1\u003c/bitbar.version\u003e\n * \u003cbitbar.author\u003eYann Milin\u003c/bitbar.author\u003e\n * \u003cbitbar.author.github\u003eymilin\u003c/bitbar.author.github\u003e\n * \u003cbitbar.desc\u003eProvides travel distance and time to your favorite destination, with traffic conditions. A Google Developer Account is required with access to \"Google Maps Distance Matrix API\" and \"Google Maps Geolocation API\"\u003c/bitbar.desc\u003e\n * \u003cbitbar.image\u003ehttp://i.imgur.com/Ui6I4YH.png\u003c/bitbar.image\u003e\n * \u003cbitbar.dependencies\u003ephp \u003e= 5.4.0\u003c/bitbar.dependencies\u003e\n */\n\nnamespace BitbarPlugins\\Travel;\n\n// Required : Your Google Developer Project's API Key\nconst API_KEY = \"YOUR_API_KEY\";\nconst DESTINATION = \"Tour Eiffel\";\n\n/*\n * Use airport to perform a scan of nearby wifi access points, provides better geolocation accuracy but makes script\n * slower by a few seconds.\n * false: fallback to current IP, resulting in less accurate geolocation\n */\nconst SCAN_NEARBY_WIFI_ACCESS_POINTS = true;\nconst LANGUAGE = \"en\"; // list of supported languages https://developers.google.com/maps/faq#languagesupport\nconst UNITS = \"metric\"; // metric, imperial\n\nconst AIRPORT_PATH = \"/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport\";\nconst DEBUG = false; // optimize output for console instead of bitbar\n\n/**\n * Class TravelTimePlugin\n *\n * Renders plugin output\n *\n * @package BitbarPlugins\\Travel\n */\nclass TravelTimePlugin\n{\n    const GOOGLE_MAP_URL                     = \"https://www.google.com/maps\";\n    const GOOGLE_MAP_URL_SOURCE_ADDRESS      = 'saddr';\n    const GOOGLE_MAP_URL_DESTINATION_ADDRESS = 'daddr';\n\n    const ICON_PIN     = \"üìç\";\n    const ICON_FLAG    = \"üèÅ\";\n    const ICON_CIRCLE  = \"‚≠ïÔ∏è\";\n    const ICON_WARNING = \"‚ö†Ô∏è\";\n    const COLOR_BLACK  = \"#000000\";\n    const COLOR_ORANGE = \"#FF9900\";\n    const COLOR_RED    = \"#FF0000\";\n\n    const ONE_MINUTES_IN_SECONDS     = 60;\n    const FIVE_MINUTES_IN_SECONDS    = 300;\n    const FIFTEEN_MINUTES_IN_SECONDS = 900;\n\n    private $durationInTraffic = [];\n    private $duration = [];\n    private $distance = [];\n    private $delay = null;\n    private $originAddress = null;\n    private $destinationAddress = null;\n    private $latitude = null;\n    private $longitude = null;\n    private $accuracy = null;\n    private $googleMapsLink = null;\n    private $accessPointCount = 0;\n    private $errors = [];\n    private $warnings = [];\n\n    private $distanceMatrixErrorMessages = [\n        DistanceMatrixResponse::STATUS_CODE_INVALID_REQUEST =\u003e \"Invalid Request.\",\n        DistanceMatrixResponse::STATUS_CODE_MAX_ELEMENTS_EXCEEDED =\u003e \"Origins and destinations per-query limit exceeded.\",\n        DistanceMatrixResponse::STATUS_CODE_OVER_QUERY_LIMIT =\u003e \"Too many requests.\",\n        DistanceMatrixResponse::STATUS_CODE_REQUEST_DENIED =\u003e \"Service denied\",\n        DistanceMatrixResponse::STATUS_CODE_UNKNOWN_ERROR =\u003e \"Server error, try again.\",\n    ];\n\n    private $distanceMatrixElementErrorMessages = [\n        DistanceMatrixResponseElement::STATUS_CODE_NOT_FOUND =\u003e \"Destination could not be geocoded.\",\n        DistanceMatrixResponseElement::STATUS_CODE_ZERO_RESULTS =\u003e \"No route could be found.\",\n    ];\n\n    public function __construct()\n    {\n        // Scan and create WifiAccessPoints\n        $wifiAccessPoints = [];\n        if (SCAN_NEARBY_WIFI_ACCESS_POINTS === true) {\n            try {\n                $wifiAccessPoints = WifiAccessPoints::fromAccessPointScannerResponse(AccessPointScanner::scan());\n                $this-\u003eaccessPointCount = count($wifiAccessPoints);\n            } catch (AccessPointScannerException $apse) {\n                $this-\u003ewarnings[] = $apse-\u003egetMessage();\n            }\n\n            if (count($wifiAccessPoints) \u003c 2) {\n                $this-\u003ewarnings[] = \"Less than two Wifi Access Points in proximity.\";\n            }\n        }\n\n        // Geolocation\n        try {\n            $geolocationApi = new GeolocationAPI();\n            $geolocationResponse = $geolocationApi-\u003ecall(GeolocationRequest::fromArrayDefinition([\n                GeolocationRequest::DEFINITION_WIFI_ACCESS_POINTS =\u003e $wifiAccessPoints\n            ]));\n\n            $this-\u003elatitude = $geolocationResponse-\u003egetLatitude();\n            $this-\u003elongitude = $geolocationResponse-\u003egetLongitude();\n            $this-\u003eaccuracy = $geolocationResponse-\u003egetAccuracy();\n        } catch (GeolocationResponseException $gre) {\n            $this-\u003eerrors[] = \"Geolocation API Error status {$gre-\u003egetStatusCode()}: {$gre-\u003egetMessage()}\";\n        }\n\n        if ($this-\u003elatitude \u0026\u0026 $this-\u003elongitude) {\n            // distanceMatrix\n            try {\n                $distanceMatrixAPI = new DistanceMatrixAPI();\n                $distanceMatrixResponse = $distanceMatrixAPI-\u003ecall(DistanceMatrixRequest::fromArrayDefinition([\n                    DistanceMatrixRequest::DEFINITION_ORIGINS =\u003e $this-\u003elatitude . ',' . $this-\u003elongitude,\n                    DistanceMatrixRequest::DEFINITION_DESTINATIONS =\u003e DESTINATION,\n                    DistanceMatrixRequest::DEFINITION_KEY =\u003e API_KEY,\n                    DistanceMatrixRequest::DEFINITION_LANGUAGE =\u003e LANGUAGE,\n                    DistanceMatrixRequest::DEFINITION_UNITS =\u003e UNITS,\n                ]));\n\n                $this-\u003edurationInTraffic = $distanceMatrixResponse-\u003egetRows()-\u003egetDurationInTraffic();\n                $this-\u003eduration = $distanceMatrixResponse-\u003egetRows()-\u003egetDuration();\n                $this-\u003edistance = $distanceMatrixResponse-\u003egetRows()-\u003egetDistance();\n                $this-\u003eoriginAddress = $distanceMatrixResponse-\u003egetOriginAddresses();\n                $this-\u003edestinationAddress = $distanceMatrixResponse-\u003egetDestinationAddresses();\n\n                $this-\u003ecomputeDelay();\n                $this-\u003ecomputeGoogleMapsLink();\n            } catch (DistanceMatrixResponseException $e) {\n                $this-\u003eerrors[] = \"Distance Matrix API Error: \" . $this-\u003edistanceMatrixErrorMessages[$e-\u003egetMessage()];\n            } catch (DistanceMatrixResponseElementException $e) {\n                $this-\u003eerrors[] = \"Distance Matrix API Error: \" . $this-\u003edistanceMatrixElementErrorMessages[$e-\u003egetMessage()];\n            }\n        }\n\n    }\n\n    private function computeDelay()\n    {\n        if (is_array($this-\u003eduration)\n            \u0026\u0026 is_array($this-\u003edurationInTraffic)\n            \u0026\u0026 array_key_exists('value', $this-\u003eduration)\n            \u0026\u0026 array_key_exists('value', $this-\u003edurationInTraffic)\n        ) {\n            $delay = $this-\u003edurationInTraffic['value'] - $this-\u003eduration['value'];\n            $this-\u003edelay = $delay \u003e 0 ? $delay : null;\n        } else {\n            $this-\u003edelay = null;\n        }\n    }\n\n    private function computeGoogleMapsLink()\n    {\n        if (isset($this-\u003eoriginAddress)\n            \u0026\u0026 is_string($this-\u003eoriginAddress)\n            \u0026\u0026 isset($this-\u003edestinationAddress)\n            \u0026\u0026 is_string($this-\u003edestinationAddress)\n        ) {\n            $this-\u003egoogleMapsLink = self::GOOGLE_MAP_URL . \"?\" . http_build_query([\n                    self::GOOGLE_MAP_URL_SOURCE_ADDRESS =\u003e $this-\u003eoriginAddress,\n                    self::GOOGLE_MAP_URL_DESTINATION_ADDRESS =\u003e $this-\u003edestinationAddress,\n                ]);\n        } else {\n            $this-\u003egoogleMapsLink = null;\n        }\n    }\n\n    /**\n     * @return string\n     */\n    public function __toString()\n    {\n        return $this-\u003erender();\n    }\n\n    private function render()\n    {\n        return DEBUG ? $this-\u003erenderConsole() : $this-\u003erenderBitbar();\n    }\n\n    /**\n     * render with Bitbar metadata\n     * @return string\n     */\n    private function renderBitbar()\n    {\n        $return = \"\";\n\n        if ($this-\u003eerrors) {\n            $return .= self::ICON_WARNING . \" Error|color=\" . self::COLOR_RED . \"\\n\";\n            $return .= \"---\\n\";\n            $return .= implode(\"|color=\" . self::COLOR_RED . \"\\n\", $this-\u003eerrors) . \"\\n\";\n            $return .= \"---\\n\";\n            $return .= \"Refresh | refresh=true \\n\";\n            return $return;\n        }\n\n        $durationColor = self::COLOR_BLACK;\n        if ($this-\u003edelay \u003e self::FIVE_MINUTES_IN_SECONDS) {\n            $durationColor = self::COLOR_ORANGE;\n        }\n        if ($this-\u003edelay \u003e self::FIFTEEN_MINUTES_IN_SECONDS) {\n            $durationColor = self::COLOR_RED;\n        }\n\n        $return .= self::ICON_PIN . \" {$this-\u003edurationInTraffic['text']}|color=$durationColor\\n\";\n        $return .= \"---\\n\";\n\n        if ($this-\u003ewarnings) {\n            foreach ($this-\u003ewarnings as $warning) {\n                $return .= self::ICON_WARNING . \" $warning\\n\";\n            }\n            $return .= \"---\\n\";\n        }\n\n        $return .= \"{$this-\u003edurationInTraffic['text']} ({$this-\u003edistance['text']})|color=$durationColor\\n\";\n        if ($this-\u003edelay \u003e self::ONE_MINUTES_IN_SECONDS) {\n            $return .= \"{$this-\u003eduration['text']} without traffic\\n\";\n        }\n        $return .= \"---\\n\";\n\n        $return .= \"Directions\\n\";\n        $return .= self::ICON_CIRCLE . \" {$this-\u003eoriginAddress} | color=\" . self::COLOR_BLACK . \"\\n\";\n        $return .= self::ICON_FLAG . \" {$this-\u003edestinationAddress} | color=\" . self::COLOR_BLACK . \"\\n\";\n        $return .= \"---\\n\";\n\n        $return .= \"Geolocation\\n\";\n        $return .= \"Latitude: {$this-\u003elatitude} | color=\" . self::COLOR_BLACK . \"\\n\";\n        $return .= \"Longitude: {$this-\u003elongitude} | color=\" . self::COLOR_BLACK . \"\\n\";\n        $return .= \"Accuracy: {$this-\u003eaccuracy}m | color=\" . self::COLOR_BLACK . \"\\n\";\n        $return .= \"---\\n\";\n\n        if ($this-\u003egoogleMapsLink) {\n            $return .= \"View on Google maps|href={$this-\u003egoogleMapsLink}\\n\";\n        }\n        $return .= \"Refresh | refresh=true \\n\";\n\n        return $return;\n    }\n\n    /**\n     * render for console output\n     * @return string\n     */\n    private function renderConsole()\n    {\n        $return = \"\";\n        if ($this-\u003eerrors) {\n            return implode(\"\\n\", $this-\u003eerrors);\n        }\n\n        if ($this-\u003ewarnings) {\n            $return .= \"---\\nWarning(s):\\n\";\n            $return .= implode(\"\\n\", $this-\u003ewarnings);\n            $return .= \"\\n---\\n\\n\";\n        }\n\n        $return .= \"Duration: {$this-\u003edurationInTraffic['text']}\\n\";\n        $return .= \"Distance: {$this-\u003edistance['text']}\\n\";\n        $return .= $this-\u003edelay ? \"Traffic Delay: {$this-\u003edelay}s\" : \"No Traffic Delay\";\n        $return .= \"\\n\\n\";\n\n        $return .= \"Directions:\\n\";\n        $return .= \"\\tFrom: {$this-\u003eoriginAddress}\\n\";\n        $return .= \"\\tTo: {$this-\u003edestinationAddress}\\n\\n\";\n\n        $return .= \"Geolocation:\\n\";\n        $return .= \"\\tLatitude: {$this-\u003elatitude}\\n\";\n        $return .= \"\\tLongitude: {$this-\u003elongitude}\\n\";\n        $return .= \"\\tAccuracy: {$this-\u003eaccuracy}\\n\\n\";\n\n        if ($this-\u003egoogleMapsLink) {\n            $return .= \"Google Maps URL: {$this-\u003egoogleMapsLink}\\n\\n\";\n        };\n\n        return $return;\n    }\n\n}\n\n/**\n * Class AccessPointScanner\n * @package BitbarPlugins\\Travel\n */\nfinal class AccessPointScanner\n{\n    /**\n     * use `airport` utility command with --scan option : Perform a wireless broadcast scan.\n     *\n     * @return string raw command output\n     * @throws AccessPointScannerException\n     */\n    public static function scan()\n    {\n        if (!self::airportProgramFound()) {\n            throw new AccessPointScannerException(\"Airport utility command not found. Please check path.\");\n        }\n\n        return shell_exec(AIRPORT_PATH . \" -s\");\n    }\n\n    private static function airportProgramFound()\n    {\n        if (!(is_file(AIRPORT_PATH)\n            \u0026\u0026 file_exists(AIRPORT_PATH)\n            \u0026\u0026 is_executable(AIRPORT_PATH))\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\nfinal class AccessPointScannerException extends \\Exception\n{\n\n}\n\nfinal class WifiAccessPoints implements \\Countable, \\JsonSerializable\n{\n\n    const PATTERN_AIRPORT_LINE_SCAN = '/^\\s*(.+?)\\s((?:[0-9A-Fa-f]{2}[:-]){5}(?:[0-9A-Fa-f]{2}))\\s(.+?)\\s+(\\d+).+$/';\n\n    /**\n     * @var WifiAccessPoint[]\n     */\n    private $accessPoints = [];\n\n    /**\n     * {@inheritDoc}\n     */\n    public function count()\n    {\n        return count($this-\u003eaccessPoints);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    function jsonSerialize()\n    {\n        return $this-\u003eaccessPoints;\n    }\n\n    /**\n     * @param string $response\n     *\n     * @return self\n     */\n    public static function fromAccessPointScannerResponse($response)\n    {\n        $instance = new self();\n\n        foreach (explode(\"\\n\", $response) as $airportAccessPoint) {\n            if (preg_match(self::PATTERN_AIRPORT_LINE_SCAN, $airportAccessPoint, $matches)) {\n                $instance-\u003eaccessPoints[] = WifiAccessPoint::fromArrayDefinition([\n                    WifiAccessPoint::DEFINITION_MAC_ADDRESS =\u003e $matches[2],\n                    WifiAccessPoint::DEFINITION_SIGNAL_TO_NOISE_RATION =\u003e intval($matches[3]),\n                    WifiAccessPoint::DEFINITION_CHANNEL =\u003e intval($matches[4]),\n                ]);\n            }\n        }\n\n        return $instance;\n    }\n\n}\n\nfinal class WifiAccessPoint implements \\JsonSerializable\n{\n    const DEFINITION_MAC_ADDRESS = \"macAddress\";\n    const DEFINITION_SIGNAL_STRENGTH = \"signalStrength\";\n    const DEFINITION_AGE = \"age\";\n    const DEFINITION_CHANNEL = \"channel\";\n    const DEFINITION_SIGNAL_TO_NOISE_RATION = \"signalToNoiseRatio\";\n\n    const PATTERN_MAC_ADDRESS = '/^(?:[0-9A-Fa-f]{2}[:-]){5}(?:[0-9A-Fa-f]{2})$/';\n\n    /**\n     * @var string\n     */\n    private $macAddress = null;\n\n    /**\n     * @var int\n     */\n    private $signalStrength = null;\n\n    /**\n     * @var int\n     */\n    private $age = null;\n\n    /**\n     * @var int\n     */\n    private $channel = null;\n\n    /**\n     * @var int\n     */\n    private $signalToNoiseRatio = null;\n\n    /**\n     * {@inheritDoc}\n     */\n    function jsonSerialize()\n    {\n        $return = [self::DEFINITION_MAC_ADDRESS =\u003e $this-\u003emacAddress];\n\n        if ($this-\u003esignalStrength !== null) {\n            $return[self::DEFINITION_SIGNAL_STRENGTH] = $this-\u003esignalStrength;\n        }\n\n        if ($this-\u003eage !== null) {\n            $return[self::DEFINITION_AGE] = $this-\u003eage;\n        }\n\n        if ($this-\u003echannel !== null) {\n            $return[self::DEFINITION_CHANNEL] = $this-\u003echannel;\n        }\n\n        if ($this-\u003esignalToNoiseRatio !== null) {\n            $return[self::DEFINITION_SIGNAL_TO_NOISE_RATION] = $this-\u003esignalToNoiseRatio;\n        }\n\n        return $return;\n    }\n\n    /**\n     * @param array $definition\n     * @return WifiAccessPoint\n     */\n    public static function fromArrayDefinition(array $definition)\n    {\n        $instance = new self();\n\n        $instance-\u003emacAddress = self::getMacAddressFromDefinition($definition);\n        $instance-\u003esignalStrength = self::getSignalStrengthFromDefinition($definition);\n        $instance-\u003eage = self::getAgeFromDefinition($definition);\n        $instance-\u003echannel = self::getChannelFromDefinition($definition);\n        $instance-\u003esignalToNoiseRatio = self::getSignalToNoiseRatioFromDefinition($definition);\n\n        return $instance;\n    }\n\n    private static function getMacAddressFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_MAC_ADDRESS])\n            \u0026\u0026 is_string($definition[self::DEFINITION_MAC_ADDRESS])\n            \u0026\u0026 preg_match(self::PATTERN_MAC_ADDRESS, $definition[self::DEFINITION_MAC_ADDRESS]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_MAC_ADDRESS];\n    }\n\n    private static function getSignalStrengthFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_SIGNAL_STRENGTH])\n            \u0026\u0026 is_int($definition[self::DEFINITION_SIGNAL_STRENGTH]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_SIGNAL_STRENGTH];\n    }\n\n    private static function getAgeFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_AGE])\n            \u0026\u0026 is_int($definition[self::DEFINITION_AGE]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_AGE];\n    }\n\n    private static function getChannelFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_CHANNEL])\n            \u0026\u0026 is_int($definition[self::DEFINITION_CHANNEL]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_CHANNEL];\n    }\n\n    private static function getSignalToNoiseRatioFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_SIGNAL_TO_NOISE_RATION])\n            \u0026\u0026 is_int($definition[self::DEFINITION_SIGNAL_TO_NOISE_RATION]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_SIGNAL_TO_NOISE_RATION];\n    }\n\n\n}\n\n/**\n * Class GeolocationAPI\n *\n * @link https://developers.google.com/maps/documentation/geolocation/\n * @package BitbarPlugins\\Travel\n */\nfinal class GeolocationAPI\n{\n    const GEOLOCATION_URL = \"https://www.googleapis.com/geolocation/v1/geolocate\";\n    const METHOD = \"POST\";\n\n    /**\n     * @var resource curl handler\n     */\n    private $ch;\n\n    private $headers = [\n        \"content-type: application/json\",\n        \"Accept: application/json\",\n        \"Cache-Control: no-cache\",\n        \"Pragma: no-cache\",\n    ];\n\n    public function __construct()\n    {\n        $this-\u003einitCurl();\n    }\n\n    private function initCurl()\n    {\n        $this-\u003ech = curl_init();\n\n        curl_setopt($this-\u003ech, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($this-\u003ech, CURLOPT_HTTPHEADER, $this-\u003eheaders);\n        curl_setopt($this-\u003ech, CURLOPT_CUSTOMREQUEST, self::METHOD);\n        curl_setopt($this-\u003ech, CURLOPT_POSTFIELDS, $this-\u003eheaders);\n    }\n\n    /**\n     * Sends a Geolocation request\n     *\n     * @param GeolocationRequest $request\n     * @return GeolocationResponse\n     */\n    public function call(GeolocationRequest $request)\n    {\n        $url = self::GEOLOCATION_URL . '?' . http_build_query(['key' =\u003e API_KEY]);\n\n        curl_setopt($this-\u003ech, CURLOPT_POSTFIELDS, json_encode($request));\n        curl_setopt($this-\u003ech, CURLOPT_URL, $url);\n\n        $response = curl_exec($this-\u003ech);\n\n        return GeolocationResponse::fromApiResponse($response);\n    }\n\n}\n\n/**\n * Class GeolocationRequest\n *\n * @todo make cellTower definition as an object and sanitize data\n * @link https://developers.google.com/maps/documentation/geolocation/intro#body\n * @package BitbarPlugins\\Travel\n */\nfinal class GeolocationRequest implements \\JsonSerializable\n{\n    const DEFINITION_MMC = \"homeMobileCountryCode\";\n    const DEFINITION_MNC = \"homeMobileNetworkCode\";\n    const DEFINITION_RADIO_TYPE = \"radioType\";\n    const DEFINITION_CARRIER = \"carrier\";\n    const DEFINITION_CONSIDER_IP = \"considerIp\";\n    const DEFINITION_CELL_TOWERS = \"cellTowers\";\n    const DEFINITION_WIFI_ACCESS_POINTS = \"wifiAccessPoints\";\n\n    /**\n     * The mobile country code (MCC) for the device's home network.\n     * @var int\n     */\n    private $homeMobileCountryCode = null;\n\n    /**\n     * The mobile network code (MNC) for the device's home network.\n     * @var int\n     */\n    private $homeMobileNetworkCode = null;\n\n    /**\n     * The mobile radio type. Supported values are lte, gsm, cdma, and wcdma. While this field is optional,\n     * it should be included if a value is available, for more accurate results.\n     * @var string\n     */\n    private $radioType = null;\n\n    /**\n     * The carrier name.\n     * @var string\n     */\n    private $carrier = null;\n\n    /**\n     * Specifies whether to fall back to IP geolocation if wifi and cell tower signals are not available.\n     * Note that the IP address in the request header may not be the IP of the device. Defaults to true.\n     * Set considerIp to false to disable fall back.\n     * @var boolean\n     */\n    private $considerIp = true;\n\n    /**\n     * An array of cell tower objects.\n     *\n     * @var array\n     */\n    private $cellTowers;\n\n    /**\n     * An array of WiFi access point objects.\n     * @var WifiAccessPoints\n     */\n    private $wifiAccessPoints;\n\n    function jsonSerialize()\n    {\n        $return = [];\n\n        if ($this-\u003ehomeMobileCountryCode !== null) {\n            $return[self::DEFINITION_MMC] = $this-\u003ehomeMobileCountryCode;\n        }\n\n        if ($this-\u003ehomeMobileNetworkCode !== null) {\n            $return[self::DEFINITION_MNC] = $this-\u003ehomeMobileNetworkCode;\n        }\n\n        if (in_array($this-\u003eradioType, ['lte', 'gsm', 'cdma', 'wcdma'], true)) {\n            $return[self::DEFINITION_RADIO_TYPE] = $this-\u003eradioType;\n        }\n\n        if ($this-\u003ecarrier) {\n            $return[self::DEFINITION_CARRIER] = $this-\u003ecarrier;\n        }\n\n        if ($this-\u003econsiderIp === false) {\n            $return[self::DEFINITION_CONSIDER_IP] = 'false';\n        }\n\n        if (count($this-\u003ecellTowers)) {\n            $return[self::DEFINITION_CELL_TOWERS] = $this-\u003ecellTowers;\n        }\n\n        if (count($this-\u003ewifiAccessPoints)) {\n            $return[self::DEFINITION_WIFI_ACCESS_POINTS] = $this-\u003ewifiAccessPoints;\n        }\n\n        return $return;\n    }\n\n    /**\n     * @param array $definition\n     *\n     * @return self\n     */\n    public static function fromArrayDefinition(array $definition)\n    {\n        $instance = new self();\n\n        $instance-\u003ehomeMobileCountryCode = self::getMMCFromDefinition($definition);\n        $instance-\u003ehomeMobileNetworkCode = self::getMNCFromDefinition($definition);\n        $instance-\u003eradioType = self::getRadioTypeFromDefinition($definition);\n        $instance-\u003ecarrier = self::getCarrierFromDefinition($definition);\n        $instance-\u003econsiderIp = self::getConsiderIpFromDefinition($definition);\n        $instance-\u003ecellTowers = self::getCellTowersFromDefinition($definition);\n        $instance-\u003ewifiAccessPoints = self::getWifiAccessPointsFromDefinition($definition);\n\n        return $instance;\n    }\n\n    private static function getMMCFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_MMC])\n            \u0026\u0026 is_int($definition[self::DEFINITION_MMC]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_MMC];\n    }\n\n    private static function getMNCFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_MNC])\n            \u0026\u0026 is_int($definition[self::DEFINITION_MNC]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_MNC];\n    }\n\n    private static function getRadioTypeFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_RADIO_TYPE])\n            \u0026\u0026 is_string($definition[self::DEFINITION_RADIO_TYPE])\n            \u0026\u0026 in_array($definition[self::DEFINITION_RADIO_TYPE], ['lte', 'gsm', 'cdma', 'wcdma'], true))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_RADIO_TYPE];\n    }\n\n    private static function getCarrierFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_CARRIER])\n            \u0026\u0026 is_string($definition[self::DEFINITION_CARRIER]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_CARRIER];\n    }\n\n    private static function getConsiderIpFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_CONSIDER_IP])\n            \u0026\u0026 is_bool($definition[self::DEFINITION_CONSIDER_IP]))\n        ) {\n            return true;\n        }\n\n        return $definition[self::DEFINITION_CONSIDER_IP];\n    }\n\n    private static function getCellTowersFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_CELL_TOWERS])\n            \u0026\u0026 is_array($definition[self::DEFINITION_CELL_TOWERS]))\n        ) {\n            return [];\n        }\n\n        return $definition[self::DEFINITION_CELL_TOWERS];\n    }\n\n    private static function getWifiAccessPointsFromDefinition(array $definition)\n    {\n\n        if (!(isset($definition[self::DEFINITION_WIFI_ACCESS_POINTS])\n            \u0026\u0026 $definition[self::DEFINITION_WIFI_ACCESS_POINTS] instanceof WifiAccessPoints\n            \u0026\u0026 count($definition[self::DEFINITION_WIFI_ACCESS_POINTS]) \u003e= 2)\n        ) {\n            return [];\n        }\n\n        return $definition[self::DEFINITION_WIFI_ACCESS_POINTS];\n    }\n\n    /**\n     * @param string $carrier\n     * @return GeolocationRequest\n     */\n    public function setCarrier($carrier)\n    {\n        $this-\u003ecarrier = $carrier;\n        return $this;\n    }\n\n    /**\n     * @param array $cellTowers\n     * @return GeolocationRequest\n     */\n    public function setCellTowers($cellTowers)\n    {\n        $this-\u003ecellTowers = $cellTowers;\n        return $this;\n    }\n\n    /**\n     * @param boolean $considerIp\n     * @return GeolocationRequest\n     */\n    public function setConsiderIp($considerIp)\n    {\n        $this-\u003econsiderIp = $considerIp;\n        return $this;\n    }\n\n    /**\n     * @param int $homeMobileCountryCode\n     * @return GeolocationRequest\n     */\n    public function setHomeMobileCountryCode($homeMobileCountryCode)\n    {\n        $this-\u003ehomeMobileCountryCode = $homeMobileCountryCode;\n        return $this;\n    }\n\n    /**\n     * @param int $homeMobileNetworkCode\n     * @return GeolocationRequest\n     */\n    public function setHomeMobileNetworkCode($homeMobileNetworkCode)\n    {\n        $this-\u003ehomeMobileNetworkCode = $homeMobileNetworkCode;\n        return $this;\n    }\n\n    /**\n     * @param string $radioType\n     * @return GeolocationRequest\n     */\n    public function setRadioType($radioType)\n    {\n        $this-\u003eradioType = $radioType;\n        return $this;\n    }\n\n    /**\n     * @param WifiAccessPoints $wifiAccessPoints\n     * @return GeolocationRequest\n     */\n    public function setWifiAccessPoints($wifiAccessPoints)\n    {\n        $this-\u003ewifiAccessPoints = $wifiAccessPoints;\n        return $this;\n    }\n}\n\n/**\n * Class GeolocationResponse\n * @package BitbarPlugins\\Travel\n */\nfinal class GeolocationResponse\n{\n    const DEFINITION_LOCATION = 'location';\n    const DEFINITION_LATITUDE = 'lat';\n    const DEFINITION_LONGITUDE = 'lng';\n    const DEFINITION_ACCURACY = 'accuracy';\n    const DEFINITION_ERROR = 'error';\n    const DEFINITION_MESSAGE = 'message';\n    const DEFINITION_CODE = 'code';\n\n    /**\n     * @var float\n     */\n    private $latitude = null;\n\n    /**\n     * @var float\n     */\n    private $longitude = null;\n\n    /**\n     * @var float\n     */\n    private $accuracy = null;\n\n    /**\n     * Creates an instance of GeolocationResponse from raw API response in json\n     * @param $response\n     * @return GeolocationResponse\n     * @throws GeolocationResponseException\n     */\n    public static function fromApiResponse($response)\n    {\n        $instance = new self();\n\n        $geolocation = json_decode($response, true);\n\n        if ($geolocationError = self::getErrorFromResponse($geolocation)) {\n            throw $geolocationError;\n        }\n\n        $instance-\u003elatitude = self::getLatitudeFromResponse($geolocation);\n        $instance-\u003elongitude = self::getLongitudeFromResponse($geolocation);\n        $instance-\u003eaccuracy = self::getAccuracyFromResponse($geolocation);\n\n        return $instance;\n    }\n\n    private static function getErrorFromResponse(array $geolocation)\n    {\n        if (!(is_array($geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_ERROR, $geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_MESSAGE, $geolocation[self::DEFINITION_ERROR])\n            \u0026\u0026 array_key_exists(self::DEFINITION_CODE, $geolocation[self::DEFINITION_ERROR])\n            \u0026\u0026 is_string($geolocation[self::DEFINITION_ERROR][self::DEFINITION_MESSAGE])\n            \u0026\u0026 is_int($geolocation[self::DEFINITION_ERROR][self::DEFINITION_CODE]))\n        ) {\n            return null;\n        }\n\n        return new GeolocationResponseException(\n            $geolocation[self::DEFINITION_ERROR][self::DEFINITION_MESSAGE],\n            $geolocation[self::DEFINITION_ERROR][self::DEFINITION_CODE]\n        );\n    }\n\n    private static function getLatitudeFromResponse(array $geolocation)\n    {\n        if (!(is_array($geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_LOCATION, $geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_LATITUDE, $geolocation[self::DEFINITION_LOCATION])\n            \u0026\u0026 is_float($geolocation[self::DEFINITION_LOCATION][self::DEFINITION_LATITUDE]))\n        ) {\n            return null;\n        }\n\n        return $geolocation[self::DEFINITION_LOCATION][self::DEFINITION_LATITUDE];\n    }\n\n    private static function getLongitudeFromResponse(array $geolocation)\n    {\n        if (!(is_array($geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_LOCATION, $geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_LONGITUDE, $geolocation[self::DEFINITION_LOCATION])\n            \u0026\u0026 is_float($geolocation[self::DEFINITION_LOCATION][self::DEFINITION_LONGITUDE]))\n        ) {\n            return null;\n        }\n\n        return $geolocation[self::DEFINITION_LOCATION][self::DEFINITION_LONGITUDE];\n    }\n\n    private static function getAccuracyFromResponse(array $geolocation)\n    {\n        if (!(is_array($geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_ACCURACY, $geolocation)\n            \u0026\u0026 is_float($geolocation[self::DEFINITION_ACCURACY]))\n        ) {\n            return null;\n        }\n\n        return $geolocation[self::DEFINITION_ACCURACY];\n    }\n\n    /**\n     * @return float\n     */\n    public function getAccuracy()\n    {\n        return $this-\u003eaccuracy;\n    }\n\n    /**\n     * @return float\n     */\n    public function getLatitude()\n    {\n        return $this-\u003elatitude;\n    }\n\n    /**\n     * @return float\n     */\n    public function getLongitude()\n    {\n        return $this-\u003elongitude;\n    }\n}\n\nfinal class GeolocationResponseException extends \\Exception\n{\n    /**\n     * @var int\n     */\n    private $statusCode;\n\n    public function __construct($message, $code)\n    {\n        $this-\u003estatusCode = $code;\n        $this-\u003emessage = $message;\n    }\n\n    /**\n     * @return int\n     */\n    public function getStatusCode()\n    {\n        return $this-\u003estatusCode;\n    }\n}\n\n/**\n * Class DistanceMatrixAPI\n *\n * @link https://developers.google.com/maps/documentation/distance-matrix/\n * @package BitbarPlugins\\Travel\n */\nfinal class DistanceMatrixAPI\n{\n    const DISTANCE_MATRIX_URL = \"https://maps.googleapis.com/maps/api/distancematrix/json\";\n\n    /**\n     * @var resource curl handler\n     */\n    private $ch;\n\n    private $headers = [\n        \"Accept: application/json\",\n        \"Cache-Control: no-cache\",\n        \"Pragma: no-cache\",\n    ];\n\n    public function __construct()\n    {\n        $this-\u003einitCurl();\n    }\n\n    private function initCurl()\n    {\n        $this-\u003ech = curl_init();\n\n        curl_setopt($this-\u003ech, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($this-\u003ech, CURLOPT_HTTPHEADER, $this-\u003eheaders);\n    }\n\n    /**\n     * Send a DistanceMatrix Request\n     *\n     * @param DistanceMatrixRequest $request\n     * @return DistanceMatrixResponse\n     * @throws DistanceMatrixResponseException\n     */\n    public function call(DistanceMatrixRequest $request)\n    {\n        $url = self::DISTANCE_MATRIX_URL . '?' . $request-\u003etoQueryParameters();\n        curl_setopt($this-\u003ech, CURLOPT_URL, $url);\n        $response = curl_exec($this-\u003ech);\n\n        return DistanceMatrixResponse::fromApiResponse($response);\n    }\n\n}\n\n/**\n * Class DistanceMatrixRequest\n * @todo handle departure_time with unix timestamps\n * @package BitbarPlugins\\Travel\n */\nfinal class DistanceMatrixRequest\n{\n    const DEFINITION_ORIGINS = \"origins\";\n    const DEFINITION_DESTINATIONS = \"destinations\";\n    const DEFINITION_KEY = \"key\";\n    const DEFINITION_MODE = \"mode\";\n    const DEFINITION_LANGUAGE = \"language\";\n    const DEFINITION_UNITS = \"units\";\n    const DEFINITION_DEPARTURE_TIME = \"departure_time\";\n\n    const PATTERN_LATITUDE_LONGITUDE = '/^\\-?\\d+(?:\\.\\d+)?,\\-?\\d+(?:\\.\\d+)?$/';\n\n    /**\n     * One or more addresses and/or textual latitude/longitude values, separated with the pipe (|) character,\n     * from which to calculate distance and time.\n     * @var string\n     */\n    private $origins = null;\n\n    /**\n     * One or more addresses and/or textual latitude/longitude values, separated with the pipe (|) character,\n     * to which to calculate distance and time.\n     * @var string\n     */\n    private $destinations = null;\n\n    /**\n     * Your application's API key. This key identifies your application for purposes of quota management.\n     * @var string\n     */\n    private $key = null;\n\n    /**\n     * Optional\n     * Specifies the mode of transport to use when calculating distance.\n     * @var string\n     */\n    private $mode = 'driving'; // 'driving', 'walking', 'cycling', 'transit'\n\n    /**\n     * Optional\n     * The language in which to return results.\n     * @var string\n     */\n    private $language = 'en';\n\n    /**\n     * Optional\n     * Specifies the unit system to use when expressing distance as text.\n     * @var string\n     */\n    private $units = 'metric'; // 'metric', 'imperial'\n\n    /**\n     * Optional\n     * The desired time of departure. You can specify the time as an integer in seconds since midnight,\n     * January 1, 1970 UTC. Alternatively, you can specify a value of now\n     * @var string\n     */\n    private $departureTime = 'now';\n\n    /**\n     * Convert Request Object to URL-encoded query string\n     *\n     * @return string\n     */\n    public function toQueryParameters()\n    {\n        return http_build_query([\n            self::DEFINITION_ORIGINS =\u003e $this-\u003eorigins,\n            self::DEFINITION_DESTINATIONS =\u003e $this-\u003edestinations,\n            self::DEFINITION_KEY =\u003e $this-\u003ekey,\n            self::DEFINITION_MODE =\u003e $this-\u003emode,\n            self::DEFINITION_LANGUAGE =\u003e $this-\u003elanguage,\n            self::DEFINITION_UNITS =\u003e $this-\u003eunits,\n            self::DEFINITION_DEPARTURE_TIME =\u003e $this-\u003edepartureTime,\n        ]);\n    }\n\n    /**\n     * @param array $definition\n     *\n     * @return self\n     */\n    public static function fromArrayDefinition(array $definition)\n    {\n        $instance = new self();\n\n        $instance-\u003eorigins = self::getOriginsFromDefinition($definition);\n        $instance-\u003edestinations = self::getDestinationsFromDefinition($definition);\n        $instance-\u003ekey = self::getKeyFromDefinition($definition);\n        $instance-\u003emode = self::getModeFromDefinition($definition);\n        $instance-\u003elanguage = self::getLanguageFromDefinition($definition);\n        $instance-\u003eunits = self::getUnitsFromDefinition($definition);\n        $instance-\u003edepartureTime = self::getDepartureTimeFromDefinition($definition);\n\n        return $instance;\n    }\n\n    private static function getOriginsFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_ORIGINS])\n            \u0026\u0026 is_string($definition[self::DEFINITION_ORIGINS])\n            \u0026\u0026 preg_match(self::PATTERN_LATITUDE_LONGITUDE, $definition[self::DEFINITION_ORIGINS]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_ORIGINS];\n    }\n\n    private static function getDestinationsFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_DESTINATIONS])\n            \u0026\u0026 is_string($definition[self::DEFINITION_DESTINATIONS]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_DESTINATIONS];\n    }\n\n    private static function getKeyFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_KEY])\n            \u0026\u0026 is_string($definition[self::DEFINITION_KEY]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_KEY];\n    }\n\n    private static function getModeFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_MODE])\n            \u0026\u0026 is_string($definition[self::DEFINITION_MODE])\n            \u0026\u0026 in_array($definition[self::DEFINITION_MODE], ['driving', 'walking', 'cycling', 'transit']))\n        ) {\n            return 'driving';\n        }\n\n        return $definition[self::DEFINITION_MODE];\n    }\n\n    private static function getLanguageFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_LANGUAGE])\n            \u0026\u0026 is_string($definition[self::DEFINITION_LANGUAGE])\n            \u0026\u0026 in_array($definition[self::DEFINITION_LANGUAGE], ['ar', 'kn', 'bg', 'ko', 'bn', 'lt', 'ca', 'lv', 'cs',\n                'ml', 'da', 'mr', 'de', 'nl', 'el', 'no', 'en', 'pl', 'en-AU', 'pt', 'en-GB', 'pt-BR', 'es', 'pt-PT',\n                'eu', 'ro', 'eu', 'ru', 'fa', 'sk', 'fi', 'sl', 'fil', 'sr', 'fr', 'sv', 'gl', 'ta', 'gu', 'te', 'hi',\n                'th', 'hr', 'tl', 'hu', 'tr', 'id', 'uk', 'it', 'vi', 'iw', 'zh-CN', 'ja', 'zh-TW',]))\n        ) {\n            return 'en';\n        }\n\n        return $definition[self::DEFINITION_LANGUAGE];\n    }\n\n    private static function getUnitsFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_UNITS])\n            \u0026\u0026 is_string($definition[self::DEFINITION_UNITS])\n            \u0026\u0026 in_array($definition[self::DEFINITION_UNITS], ['metric', 'imperial']))\n        ) {\n            return 'metric';\n        }\n\n        return $definition[self::DEFINITION_UNITS];\n    }\n\n    private static function getDepartureTimeFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_DEPARTURE_TIME])\n            \u0026\u0026 is_string($definition[self::DEFINITION_DEPARTURE_TIME])\n            \u0026\u0026 $definition[self::DEFINITION_DEPARTURE_TIME] === 'now')\n        ) {\n            return 'now';\n        }\n\n        return $definition[self::DEFINITION_DEPARTURE_TIME];\n    }\n}\n\n/**\n * Class DistanceMatrixResponse\n * @package BitbarPlugins\\Travel\n */\nfinal class DistanceMatrixResponse\n{\n    const DEFINITION_STATUS = 'status';\n    const DEFINITION_ORIGIN_ADDRESSES = 'origin_addresses';\n    const DEFINITION_DESTINATION_ADDRESSES = 'destination_addresses';\n    const DEFINITION_ROWS = 'rows';\n\n    const STATUS_CODE_OK = 'OK';\n    const STATUS_CODE_INVALID_REQUEST = 'INVALID_REQUEST';\n    const STATUS_CODE_MAX_ELEMENTS_EXCEEDED = 'MAX_ELEMENTS_EXCEEDED';\n    const STATUS_CODE_OVER_QUERY_LIMIT = 'OVER_QUERY_LIMIT';\n    const STATUS_CODE_REQUEST_DENIED = 'REQUEST_DENIED';\n    const STATUS_CODE_UNKNOWN_ERROR = 'UNKNOWN_ERROR';\n\n    /**\n     * Contains metadata on the request.\n     * @var string\n     */\n    private $status;\n\n    /**\n     * Contains an array of addresses as returned by the API from your original request.\n     * These are formatted by the geocoder and localized according to the language parameter passed with the request.\n     * @var string\n     */\n    private $originAddresses;\n\n    /**\n     * Contains an array of addresses as returned by the API from your original request.\n     * As with origin_addresses, these are localized if appropriate.\n     * @var string\n     */\n    private $destinationAddresses;\n\n    /**\n     * Contains an array of elements\n     * @var DistanceMatrixResponseElement\n     */\n    private $rows;\n\n    /**\n     * Creates an instance of DistanceMatrixResponse from raw API response in json\n     * @param $response\n     * @return DistanceMatrixResponse\n     * @throws DistanceMatrixResponseException\n     */\n    public static function fromApiResponse($response)\n    {\n        $instance = new self();\n\n        $distanceMatrix = json_decode($response, true);\n\n        if ($distanceMatrixError = self::getErrorFromResponse($distanceMatrix)) {\n            throw $distanceMatrixError;\n        }\n\n        $instance-\u003estatus = self::getStatusFromResponse($distanceMatrix);\n        $instance-\u003eoriginAddresses = self::getOriginAddressesFromResponse($distanceMatrix);\n        $instance-\u003edestinationAddresses = self::getDestinationAddressesFromResponse($distanceMatrix);\n        $instance-\u003erows = DistanceMatrixResponseElement::fromArrayDefinition(self::getRowsFromResponse($distanceMatrix));\n\n        return $instance;\n    }\n\n    private static function getErrorFromResponse(array $distanceMatrix)\n    {\n        if (!(is_array($distanceMatrix)\n            \u0026\u0026 array_key_exists(self::DEFINITION_STATUS, $distanceMatrix)\n            \u0026\u0026 $distanceMatrix[self::DEFINITION_STATUS] === self::STATUS_CODE_OK)\n        ) {\n            return new DistanceMatrixResponseException($distanceMatrix[self::DEFINITION_STATUS]);\n        }\n\n        return null;\n    }\n\n    private static function getStatusFromResponse(array $distanceMatrix)\n    {\n        if (!(is_array($distanceMatrix)\n            \u0026\u0026 array_key_exists(self::DEFINITION_STATUS, $distanceMatrix)\n            \u0026\u0026 is_string($distanceMatrix[self::DEFINITION_STATUS]))\n        ) {\n            return null;\n        }\n\n        return $distanceMatrix[self::DEFINITION_STATUS];\n    }\n\n    private static function getOriginAddressesFromResponse(array $distanceMatrix)\n    {\n        if (!(is_array($distanceMatrix)\n            \u0026\u0026 array_key_exists(self::DEFINITION_ORIGIN_ADDRESSES, $distanceMatrix)\n            \u0026\u0026 is_array($distanceMatrix[self::DEFINITION_ORIGIN_ADDRESSES])\n            \u0026\u0026 count($distanceMatrix[self::DEFINITION_ORIGIN_ADDRESSES]) === 1)\n        ) {\n            return null;\n        }\n\n        return $distanceMatrix[self::DEFINITION_ORIGIN_ADDRESSES][0];\n    }\n\n    private static function getDestinationAddressesFromResponse(array $distanceMatrix)\n    {\n        if (!(is_array($distanceMatrix)\n            \u0026\u0026 array_key_exists(self::DEFINITION_DESTINATION_ADDRESSES, $distanceMatrix)\n            \u0026\u0026 is_array($distanceMatrix[self::DEFINITION_DESTINATION_ADDRESSES])\n            \u0026\u0026 count($distanceMatrix[self::DEFINITION_DESTINATION_ADDRESSES]) === 1)\n        ) {\n            return null;\n        }\n\n        return $distanceMatrix[self::DEFINITION_DESTINATION_ADDRESSES][0];\n    }\n\n    private static function getRowsFromResponse(array $distanceMatrix)\n    {\n        if (!(is_array($distanceMatrix)\n            \u0026\u0026 array_key_exists(self::DEFINITION_ROWS, $distanceMatrix)\n            \u0026\u0026 is_array($distanceMatrix[self::DEFINITION_ROWS])\n            \u0026\u0026 count($distanceMatrix[self::DEFINITION_ROWS]) === 1)\n        ) {\n            return null;\n        }\n\n        return $distanceMatrix[self::DEFINITION_ROWS][0];\n    }\n\n    /**\n     * @return string\n     */\n    public function getDestinationAddresses()\n    {\n        return $this-\u003edestinationAddresses;\n    }\n\n    /**\n     * @return string\n     */\n    public function getOriginAddresses()\n    {\n        return $this-\u003eoriginAddresses;\n    }\n\n    /**\n     * @return DistanceMatrixResponseElement\n     */\n    public function getRows()\n    {\n        return $this-\u003erows;\n    }\n\n    /**\n     * @return string\n     */\n    public function getStatus()\n    {\n        return $this-\u003estatus;\n    }\n\n}\n\nfinal class DistanceMatrixResponseElement\n{\n    const DEFINITION_ELEMENTS = 'elements';\n    const DEFINITION_STATUS = 'status';\n    const DEFINITION_DURATION = 'duration';\n    const DEFINITION_DISTANCE = 'distance';\n    const DEFINITION_DURATION_IN_TRAFFIC = 'duration_in_traffic';\n\n    const STATUS_CODE_OK = 'OK';\n    const STATUS_CODE_NOT_FOUND = 'NOT_FOUND';\n    const STATUS_CODE_ZERO_RESULTS = 'ZERO_RESULTS';\n\n    /**\n     * Element level status of the request\n     * @var string\n     */\n    private $status = null;\n\n    /**\n     * The length of time it takes to travel this route, expressed in seconds (the value field) and as text.\n     * The textual representation is localized according to the query's language parameter.\n     * @var array\n     */\n    private $duration = [];\n\n    /**\n     * The total distance of this route, expressed in meters (value) and as text. The textual value uses the unit\n     * system specified with the unit parameter of the original request, or the origin's region.\n     * @var array\n     */\n    private $distance = [];\n\n    /**\n     * The length of time it takes to travel this route, based on current and historical traffic conditions.\n     * @var array\n     */\n    private $durationInTraffic = [];\n\n    /**\n     * @param array $definition\n     * @return DistanceMatrixResponseElement\n     * @throws DistanceMatrixResponseElementException\n     */\n    public static function fromArrayDefinition(array $definition)\n    {\n        $instance = new self();\n\n        if ($distanceMatrixElementError = self::getErrorFromDefinition($definition)) {\n            throw $distanceMatrixElementError;\n        }\n\n        $instance-\u003estatus = self::getStatusFromDefinition($definition);\n        $instance-\u003eduration = self::getDurationFromDefinition($definition);\n        $instance-\u003edistance = self::getDistanceFromDefinition($definition);\n        $instance-\u003edurationInTraffic = self::getDurationInTrafficFromDefinition($definition);\n\n        return $instance;\n    }\n\n    public static function getErrorFromDefinition(array $definition)\n    {\n        if (!(is_array($definition)\n            \u0026\u0026 array_key_exists(self::DEFINITION_ELEMENTS, $definition)\n            \u0026\u0026 is_array($definition[self::DEFINITION_ELEMENTS])\n            \u0026\u0026 count($definition[self::DEFINITION_ELEMENTS]) === 1\n            \u0026\u0026 is_array($definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 array_key_exists(self::DEFINITION_STATUS, $definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 $definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_STATUS] === self::STATUS_CODE_OK)\n        ) {\n            return new DistanceMatrixResponseElementException($definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_STATUS]);\n        }\n\n        return null;\n    }\n\n    public static function getStatusFromDefinition(array $definition)\n    {\n        if (!(is_array($definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 array_key_exists(self::DEFINITION_STATUS, $definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 is_string($definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_STATUS]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_STATUS];\n    }\n\n    public static function getDurationFromDefinition(array $definition)\n    {\n        if (!(is_array($definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 array_key_exists(self::DEFINITION_DURATION, $definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 is_array($definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DURATION]))\n        ) {\n            return [];\n        }\n\n        return $definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DURATION];\n    }\n\n    public static function getDistanceFromDefinition(array $definition)\n    {\n        if (!(is_array($definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 array_key_exists(self::DEFINITION_DISTANCE, $definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 is_array($definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DISTANCE]))\n        ) {\n            return [];\n        }\n\n        return $definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DISTANCE];\n    }\n\n    public static function getDurationInTrafficFromDefinition(array $definition)\n    {\n        if (!(is_array($definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 array_key_exists(self::DEFINITION_DURATION_IN_TRAFFIC, $definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 is_array($definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DURATION_IN_TRAFFIC]))\n        ) {\n            return [];\n        }\n\n        return $definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DURATION_IN_TRAFFIC];\n    }\n\n    /**\n     * @return array\n     */\n    public function getDistance()\n    {\n        return $this-\u003edistance;\n    }\n\n    /**\n     * @return array\n     */\n    public function getDuration()\n    {\n        return $this-\u003eduration;\n    }\n\n    /**\n     * @return array\n     */\n    public function getDurationInTraffic()\n    {\n        return $this-\u003edurationInTraffic;\n    }\n\n    /**\n     * @return string\n     */\n    public function getStatus()\n    {\n        return $this-\u003estatus;\n    }\n}\n\nfinal class DistanceMatrixResponseException extends \\Exception\n{\n\n}\n\nfinal class DistanceMatrixResponseElementException extends \\Exception\n{\n\n}\n\necho new TravelTimePlugin();\n"
				}
			],
			"path": "Travel/travel-time.5m.php",
			"filename": "travel-time.5m.php",
			"dir": "Travel",
			"docsPlugin": "Travel/travel-time.5m.php.html",
			"docsCategory": "Travel.html",
			"pathSegments": [
				"Travel"
			],
			"categoryPathSegments": [
				{
					"path": "Travel",
					"text": "Travel",
					"isLast": true
				}
			],
			"title": "Travel time",
			"version": "1.1",
			"author": "Yann Milin",
			"authors": [
				{
					"name": "Yann Milin",
					"githubUsername": "ymilin",
					"imageURL": "https://avatars.githubusercontent.com/u/3737075?v=4",
					"bio": "",
					"primary": true
				}
			],
			"desc": "Provides travel distance and time to your favorite destination, with traffic conditions. A Google Developer Account is required with access to \"Google Maps Distance Matrix API\" and \"Google Maps Geolocation API\"",
			"imageURL": "http://i.imgur.com/Ui6I4YH.png",
			"dependencies": [
				"php \u003e= 5.4.0"
			],
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:22:08.333314Z",
			"vars": null
		},
		{
			"files": [
				{
					"path": "Dev/rabbitmq-status.1m.php",
					"filename": "rabbitmq-status.1m.php",
					"content": "#!/usr/bin/env  php\n\u003c?php\n# \u003cbitbar.title\u003eRabbitMQ Status\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003e1.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003eYann Milin\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003eymilin\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eKeep an eye on your RabbitMQ server status from your menu bar !\u003c/bitbar.desc\u003e\n# \u003cbitbar.image\u003ehttp://i.imgur.com/Gz8FCJL.png\u003c/bitbar.image\u003e\n# \u003cbitbar.dependencies\u003ephp \u003e= 5.4.0\u003c/bitbar.dependencies\u003e\n# \n# RabbitMQ management plugin must be activated on server https://www.rabbitmq.com/management.html\n# RabbitMQ Management HTTP API documentation https://raw.githack.com/rabbitmq/rabbitmq-management/rabbitmq_v3_6_0/priv/www/api/index.html\n\n// Config\n$baseUrl = \"http://example.com\";\n$port = \"15672\";\n$user = \"guest\";\n$password = \"guest\";\n$queuedMessageCountErrorLimit = 1000; // alert if queued messages higher than this, 0 = not active\n// Config end\n\n$statusBlackCircle = \"‚ö´Ô∏è\";\n$statusRedCircle = \"üî¥\";\n$statusWarning = \"‚ö†Ô∏è\";\n$colorBlack = \"#333333\";\n$colorRed = \"#FF0000\";\n\n$headers = [\n    \"Authorization: Basic \" . base64_encode(\"$user:$password\"),\n    \"content-type: application/json\",\n    \"Accept: application/json\",\n    \"Cache-Control: no-cache\",\n    \"Pragma: no-cache\",\n];\n$ch = curl_init();\n$errors = [];\n\n$uriOverview = \"/api/overview\";\n$uriNodes = \"/api/nodes\";\n$uriQueues = \"/api/queues\";\n\ncurl_setopt($ch, CURLOPT_PORT, $port);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\ncurl_setopt($ch, CURLOPT_TIMEOUT, 60);\ncurl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n/**\n * Executes a GET request and returns response body in array format\n *\n * @param $ch\n * @param $url\n * @return mixed\n */\n$curl_exec = function (\u0026$ch, $url) {\n    curl_setopt($ch, CURLOPT_URL, $url);\n    return json_decode(curl_exec($ch), true);\n};\n\n/**\n * Handles error message from the api, stopping the script on errors\n *\n * @param $ch\n * @param $response\n */\n$curlHandleResponseError = function (\u0026$ch, $response) {\n    global $statusWarning, $colorRed;\n    if (!$response) {\n        $error = curl_error($ch);\n        echo \"$statusWarning Error |color=$colorRed\\n\";\n        echo \"---\\n\";\n        echo \"$error | color=$colorRed\\n\";\n        exit;\n    }\n    if (array_key_exists('error', $response)) {\n        echo \"$statusWarning Error |color=$colorRed\\n\";\n        echo \"---\\n\";\n        echo \"error: {$response['error']}, reason: {$response['reason']} | color=$colorRed\\n\";\n        exit;\n    }\n};\n\n// api calls\n$responseOverview = $curl_exec($ch, $baseUrl . $uriOverview);\n$curlHandleResponseError($ch, $responseOverview);\n$responseNodes = $curl_exec($ch, $baseUrl . $uriNodes);\n$curlHandleResponseError($ch, $responseNodes);\n$responseQueues = $curl_exec($ch, $baseUrl . $uriQueues);\n$curlHandleResponseError($ch, $responseQueues);\n\n// Extract values from responses\n$messagesReady = $responseOverview['queue_totals']['messages_ready'];\n$messagesUnacked = $responseOverview['queue_totals']['messages_unacknowledged'];\n$messagesTotal = $responseOverview['queue_totals']['messages'];\n$connections = $responseOverview['object_totals']['connections'];\n$channels = $responseOverview['object_totals']['channels'];\n$exchanges = $responseOverview['object_totals']['exchanges'];\n$queuesCount = $responseOverview['object_totals']['queues'];\n$consumers = $responseOverview['object_totals']['consumers'];\n$rabbitMqVersion = $responseOverview['rabbitmq_version'];\n$erlangVersion = $responseOverview['erlang_version'];\n\n$statusIcon = $statusBlackCircle;\n$nodes = [];\nforeach ($responseNodes as $responseNode) {\n    $nodes[] = [\n        'name' =\u003e $responseNode['name'],\n        'running' =\u003e $responseNode['running'],\n    ];\n\n    if (!$responseNode['running']) {\n        $statusIcon = $statusRedCircle;\n        $errors[] = \"RabbitMQ is reporting that node {$responseNode['name']} is not running correctly, known VPN issue on server.\";\n    }\n}\n\n$queues = [];\nforeach ($responseQueues as $responseQueue) {\n    $queues[] = [\n        'name' =\u003e $responseQueue['name'],\n        'state' =\u003e $responseQueue['state'],\n    ];\n\n    if ($responseQueue['state'] !== \"running\") {\n        $statusIcon = $statusRedCircle;\n        $errors[] = \"RabbitMQ is reporting that queue {$responseQueue['name']} is not running correctly.\";\n    }\n}\n\n\nif ($queuedMessageCountErrorLimit \u0026\u0026 intval($messagesReady) \u003e $queuedMessageCountErrorLimit) {\n    $statusIcon = $statusRedCircle;\n    $errors[] = \"Number of message in queue higher than $queuedMessageCountErrorLimit, please check consumers status.\";\n}\n\n// Top menu : status icon + count message ready\necho $statusIcon . \" \" . $messagesReady . \"|color=$colorBlack\\n\";\necho \"---\\n\";\n// Error messages\nforeach ($errors as $error) {\n    echo \"$error | color=$colorRed\\n\";\n}\nif ($errors) {\n    echo \"---\\n\";\n}\n// Message count detail\necho \"Queued messages\\n\";\necho \"Ready: $messagesReady | color=$colorBlack\\n\";\necho \"Unacked: $messagesUnacked | color=$colorBlack\\n\";\necho \"Total: $messagesTotal | color=$colorBlack\\n\";\necho \"---\\n\";\n// Global count for Connections, Channels, Exchanges, Queues, Consumers:\necho \"Global counts\\n\";\necho \"Connections: $connections | color=$colorBlack\\n\";\necho \"Channels: $channels | color=$colorBlack\\n\";\necho \"Exchanges: $exchanges | color=$colorBlack\\n\";\necho \"Queues: $queuesCount | color=$colorBlack\\n\";\necho \"Consumers: $consumers | color=$colorBlack\\n\";\necho \"---\\n\";\n// Nodes status\necho \"Nodes\\n\";\nforeach ($nodes as $node) {\n    $nodeStatus = $node['running'] ? \"ok\" : \"error\";\n    $nodeStatusColor = $node['running'] ? $colorBlack : $colorRed;\n    echo \"{$node['name']} status $nodeStatus | color=$nodeStatusColor\\n\";\n}\necho \"---\\n\";\necho \"Queues\\n\";\nforeach ($queues as $queue) {\n    $queueStatusColor = $queue['state'] === \"running\" ? $colorBlack : $colorRed;\n    echo \"{$queue['name']} status {$queue['state']} | color=$queueStatusColor\\n\";\n}\necho \"---\\n\";\n// manual refresh + RabbitMQ version TAG + management interface link\necho \"RabbitMQ v$rabbitMqVersion, Erlang $erlangVersion\\n\";\necho \"$baseUrl:$port | href=$baseUrl:$port \\n\";\necho \"Refresh | refresh=true \\n\";\n\ncurl_close($ch);\n"
				}
			],
			"path": "Dev/rabbitmq-status.1m.php",
			"filename": "rabbitmq-status.1m.php",
			"dir": "Dev",
			"docsPlugin": "Dev/rabbitmq-status.1m.php.html",
			"docsCategory": "Dev.html",
			"pathSegments": [
				"Dev"
			],
			"categoryPathSegments": [
				{
					"path": "Dev",
					"text": "Dev",
					"isLast": true
				}
			],
			"title": "RabbitMQ Status",
			"version": "1.0",
			"author": "Yann Milin",
			"authors": [
				{
					"name": "Yann Milin",
					"githubUsername": "ymilin",
					"imageURL": "https://avatars.githubusercontent.com/u/3737075?v=4",
					"bio": "",
					"primary": true
				}
			],
			"desc": "Keep an eye on your RabbitMQ server status from your menu bar !",
			"imageURL": "http://i.imgur.com/Gz8FCJL.png",
			"dependencies": [
				"php \u003e= 5.4.0"
			],
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:21:52.039991Z",
			"vars": null
		}
	]
}