{
	"plugin": {
		"files": [
			{
				"path": "Dev/backlog-show-my-task.1m.rb",
				"filename": "backlog-show-my-task.1m.rb",
				"content": "#!/usr/bin/env ruby\n# coding: utf-8\n\n# \u003cbitbar.title\u003eBacklog Show My Task\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev1.0.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003ehikouki\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003ehikouki\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eShow Backlog open ticket for mine\u003c/bitbar.desc\u003e\n# \u003cbitbar.image\u003ehttps://raw.githubusercontent.com/hikouki/bitbar-backlog/master/preview.png\u003c/bitbar.image\u003e\n# \u003cbitbar.dependencies\u003eruby\u003c/bitbar.dependencies\u003e\n# \u003cbitbar.abouturl\u003ehttps://github.com/hikouki\u003c/bitbar.abouturl\u003e\n\nrequire 'net/http'\nrequire 'uri'\nrequire 'json'\n\n# a6140cbf6e84a0bAffb0cX49138fc5687310b518\n#   or\n# launchctl setenv BACKLOG_ACCESS_TOKEN a6140cbf6e84a0bAffb0cX49138fc5687310b518\nTOKEN = ENV[\"BACKLOG_ACCESS_TOKEN\"] || ''\n# https://xxxx.backlog.jp\n#   or\n# launchctl setenv BACKLOG_URL https://xxxx.backlog.jp\nBACKLOG_URL = ENV[\"BACKLOG_URL\"] || ''\n\nbegin\n\n  myself_api = URI.parse(\"#{BACKLOG_URL}/api/v2/users/myself\")\n  myself_api.query = URI.encode_www_form(apiKey: TOKEN)\n\n  myself_res = Net::HTTP.start(myself_api.host, myself_api.port, use_ssl: myself_api.scheme == 'https') do | http |\n    http.get(myself_api.request_uri)\n  end\n\n  raise \"error #{myself_res.code} #{myself_res.message}\" if myself_res.code != '200'\n\n  me = JSON.parse(myself_res.body, symbolize_names: true)\n\n  issues_api = URI.parse(\"#{BACKLOG_URL}/api/v2/issues\")\n  issues_api.query = URI.encode_www_form(apiKey: TOKEN, 'assigneeId[]' =\u003e me[:id], count: 100)\n\n  issues_res = Net::HTTP.start(issues_api.host, issues_api.port, use_ssl: issues_api.scheme == 'https') do | http |\n    http.get(issues_api.request_uri)\n  end\n\n  raise \"error #{issues_res.code} #{issues_res.message}\" if issues_res.code != '200'\n\n  issues = JSON.parse(issues_res.body, symbolize_names: true)\n\n  projects = Hash.new do | h, k |\n    h[k] = {\n      name: \"\u003cproject name\u003e\",\n      issue_count: 0,\n      issue_type_groups: Hash.new do | h1, k1 |\n        h1[k1] = {\n          name: \"\u003ctype name\u003e\",\n          color: \"\u003ctype color\u003e\",\n          issue_status_groups: Hash.new do | h2, k2 |\n            h2[k2] = {\n              name: \"\u003cstatus name\u003e\",\n              issues: []\n            }\n          end\n        }\n      end\n    }\n  end\n\n  issues.each do | issue |\n    project_id = issue[:projectId]\n    issue_type_id = issue[:issueType][:id]\n    issue_status_id = issue[:status][:id]\n\n    projects[project_id][:issue_count] += 1\n    projects[project_id][:issue_type_groups][issue_type_id][:name] = issue[:issueType][:name]\n    projects[project_id][:issue_type_groups][issue_type_id][:color] = issue[:issueType][:color]\n    projects[project_id][:issue_type_groups][issue_type_id][:issue_status_groups][issue_status_id][:name] = issue[:status][:name]\n    projects[project_id][:issue_type_groups][issue_type_id][:issue_status_groups][issue_status_id][:issues].push(\n      {\n        key: issue[:issueKey],\n        summary: issue[:summary]\n      }\n    )\n  end\n\n  puts issues.empty? ? \"◈ | color=#7d7d7d\" : \"◈ #{issues.count}\"\n  puts \"---\"\n  puts \"Backlog | color=black href=#{BACKLOG_URL}\"\n  puts \"---\"\n\n  projects.each do | project_id, project |\n    project_api = URI.parse(\"#{BACKLOG_URL}/api/v2/projects/#{project_id}\")\n    project_api.query = URI.encode_www_form(apiKey: TOKEN)\n\n    project_res = Net::HTTP.start(project_api.host, project_api.port, use_ssl: project_api.scheme == 'https') do | http |\n      http.get(project_api.request_uri)\n    end\n\n    raise \"error #{project_res.code} #{project_res.message}\" if project_res.code != '200'\n\n    project_info = JSON.parse(project_res.body, symbolize_names: true)\n\n    puts \"#{project_info[:name]}: #{project[:issue_count]} | size=11\"\n    project[:issue_type_groups].each do | _, type_group |\n      puts \"➠ #{type_group[:name]} | color=#{type_group[:color]} size=11\"\n      type_group[:issue_status_groups].each do | _, status_group |\n        puts \"[#{status_group[:name]}] | color=#58BE89 size=11\"\n        status_group[:issues].each do | issue |\n          prefix = status_group[:issues].last == issue ? \"└\" : \"├\"\n          puts \"#{prefix} #{issue[:summary]} | color=black href=#{BACKLOG_URL}/view/#{issue[:key]} size=11\"\n        end\n      end\n    end\n    puts \"---\"\n  end\n\n  puts \"---\"\n  puts \"Refresh | color=#7d7d7d refresh=true\"\n\nrescue =\u003e e\n  puts \"◈ ! | color=#ECB935\"\n  puts \"---\"\n  puts \"Exception: #{$!}\"\n  puts e.backtrace\nend\n"
			}
		],
		"path": "Dev/backlog-show-my-task.1m.rb",
		"filename": "backlog-show-my-task.1m.rb",
		"dir": "Dev",
		"docsPlugin": "Dev/backlog-show-my-task.1m.rb.html",
		"docsCategory": "Dev.html",
		"pathSegments": [
			"Dev"
		],
		"categoryPathSegments": [
			{
				"path": "Dev",
				"text": "Dev",
				"isLast": true
			}
		],
		"title": "Backlog Show My Task",
		"version": "v1.0.0",
		"author": "hikouki",
		"authors": [
			{
				"name": "Kouki Higashikawa",
				"githubUsername": "hikouki",
				"imageURL": "https://avatars.githubusercontent.com/u/15326035?v=4",
				"bio": ":airplane:",
				"primary": true
			}
		],
		"desc": "Show Backlog open ticket for mine",
		"imageURL": "https://raw.githubusercontent.com/hikouki/bitbar-backlog/master/preview.png",
		"dependencies": [
			"ruby"
		],
		"aboutURL": "https://github.com/hikouki",
		"lastUpdated": "2021-03-08T15:21:50.89196Z",
		"vars": null
	}
}