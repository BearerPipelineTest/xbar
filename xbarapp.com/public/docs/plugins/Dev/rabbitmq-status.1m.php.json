{
	"plugin": {
		"files": [
			{
				"path": "Dev/rabbitmq-status.1m.php",
				"filename": "rabbitmq-status.1m.php",
				"content": "#!/usr/bin/env  php\n\u003c?php\n# \u003cbitbar.title\u003eRabbitMQ Status\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003e1.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003eYann Milin\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003eymilin\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eKeep an eye on your RabbitMQ server status from your menu bar !\u003c/bitbar.desc\u003e\n# \u003cbitbar.image\u003ehttp://i.imgur.com/Gz8FCJL.png\u003c/bitbar.image\u003e\n# \u003cbitbar.dependencies\u003ephp \u003e= 5.4.0\u003c/bitbar.dependencies\u003e\n# \n# RabbitMQ management plugin must be activated on server https://www.rabbitmq.com/management.html\n# RabbitMQ Management HTTP API documentation https://raw.githack.com/rabbitmq/rabbitmq-management/rabbitmq_v3_6_0/priv/www/api/index.html\n\n// Config\n$baseUrl = \"http://example.com\";\n$port = \"15672\";\n$user = \"guest\";\n$password = \"guest\";\n$queuedMessageCountErrorLimit = 1000; // alert if queued messages higher than this, 0 = not active\n// Config end\n\n$statusBlackCircle = \"‚ö´Ô∏è\";\n$statusRedCircle = \"üî¥\";\n$statusWarning = \"‚ö†Ô∏è\";\n$colorBlack = \"#333333\";\n$colorRed = \"#FF0000\";\n\n$headers = [\n    \"Authorization: Basic \" . base64_encode(\"$user:$password\"),\n    \"content-type: application/json\",\n    \"Accept: application/json\",\n    \"Cache-Control: no-cache\",\n    \"Pragma: no-cache\",\n];\n$ch = curl_init();\n$errors = [];\n\n$uriOverview = \"/api/overview\";\n$uriNodes = \"/api/nodes\";\n$uriQueues = \"/api/queues\";\n\ncurl_setopt($ch, CURLOPT_PORT, $port);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\ncurl_setopt($ch, CURLOPT_TIMEOUT, 60);\ncurl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\n/**\n * Executes a GET request and returns response body in array format\n *\n * @param $ch\n * @param $url\n * @return mixed\n */\n$curl_exec = function (\u0026$ch, $url) {\n    curl_setopt($ch, CURLOPT_URL, $url);\n    return json_decode(curl_exec($ch), true);\n};\n\n/**\n * Handles error message from the api, stopping the script on errors\n *\n * @param $ch\n * @param $response\n */\n$curlHandleResponseError = function (\u0026$ch, $response) {\n    global $statusWarning, $colorRed;\n    if (!$response) {\n        $error = curl_error($ch);\n        echo \"$statusWarning Error |color=$colorRed\\n\";\n        echo \"---\\n\";\n        echo \"$error | color=$colorRed\\n\";\n        exit;\n    }\n    if (array_key_exists('error', $response)) {\n        echo \"$statusWarning Error |color=$colorRed\\n\";\n        echo \"---\\n\";\n        echo \"error: {$response['error']}, reason: {$response['reason']} | color=$colorRed\\n\";\n        exit;\n    }\n};\n\n// api calls\n$responseOverview = $curl_exec($ch, $baseUrl . $uriOverview);\n$curlHandleResponseError($ch, $responseOverview);\n$responseNodes = $curl_exec($ch, $baseUrl . $uriNodes);\n$curlHandleResponseError($ch, $responseNodes);\n$responseQueues = $curl_exec($ch, $baseUrl . $uriQueues);\n$curlHandleResponseError($ch, $responseQueues);\n\n// Extract values from responses\n$messagesReady = $responseOverview['queue_totals']['messages_ready'];\n$messagesUnacked = $responseOverview['queue_totals']['messages_unacknowledged'];\n$messagesTotal = $responseOverview['queue_totals']['messages'];\n$connections = $responseOverview['object_totals']['connections'];\n$channels = $responseOverview['object_totals']['channels'];\n$exchanges = $responseOverview['object_totals']['exchanges'];\n$queuesCount = $responseOverview['object_totals']['queues'];\n$consumers = $responseOverview['object_totals']['consumers'];\n$rabbitMqVersion = $responseOverview['rabbitmq_version'];\n$erlangVersion = $responseOverview['erlang_version'];\n\n$statusIcon = $statusBlackCircle;\n$nodes = [];\nforeach ($responseNodes as $responseNode) {\n    $nodes[] = [\n        'name' =\u003e $responseNode['name'],\n        'running' =\u003e $responseNode['running'],\n    ];\n\n    if (!$responseNode['running']) {\n        $statusIcon = $statusRedCircle;\n        $errors[] = \"RabbitMQ is reporting that node {$responseNode['name']} is not running correctly, known VPN issue on server.\";\n    }\n}\n\n$queues = [];\nforeach ($responseQueues as $responseQueue) {\n    $queues[] = [\n        'name' =\u003e $responseQueue['name'],\n        'state' =\u003e $responseQueue['state'],\n    ];\n\n    if ($responseQueue['state'] !== \"running\") {\n        $statusIcon = $statusRedCircle;\n        $errors[] = \"RabbitMQ is reporting that queue {$responseQueue['name']} is not running correctly.\";\n    }\n}\n\n\nif ($queuedMessageCountErrorLimit \u0026\u0026 intval($messagesReady) \u003e $queuedMessageCountErrorLimit) {\n    $statusIcon = $statusRedCircle;\n    $errors[] = \"Number of message in queue higher than $queuedMessageCountErrorLimit, please check consumers status.\";\n}\n\n// Top menu : status icon + count message ready\necho $statusIcon . \" \" . $messagesReady . \"|color=$colorBlack\\n\";\necho \"---\\n\";\n// Error messages\nforeach ($errors as $error) {\n    echo \"$error | color=$colorRed\\n\";\n}\nif ($errors) {\n    echo \"---\\n\";\n}\n// Message count detail\necho \"Queued messages\\n\";\necho \"Ready: $messagesReady | color=$colorBlack\\n\";\necho \"Unacked: $messagesUnacked | color=$colorBlack\\n\";\necho \"Total: $messagesTotal | color=$colorBlack\\n\";\necho \"---\\n\";\n// Global count for Connections, Channels, Exchanges, Queues, Consumers:\necho \"Global counts\\n\";\necho \"Connections: $connections | color=$colorBlack\\n\";\necho \"Channels: $channels | color=$colorBlack\\n\";\necho \"Exchanges: $exchanges | color=$colorBlack\\n\";\necho \"Queues: $queuesCount | color=$colorBlack\\n\";\necho \"Consumers: $consumers | color=$colorBlack\\n\";\necho \"---\\n\";\n// Nodes status\necho \"Nodes\\n\";\nforeach ($nodes as $node) {\n    $nodeStatus = $node['running'] ? \"ok\" : \"error\";\n    $nodeStatusColor = $node['running'] ? $colorBlack : $colorRed;\n    echo \"{$node['name']} status $nodeStatus | color=$nodeStatusColor\\n\";\n}\necho \"---\\n\";\necho \"Queues\\n\";\nforeach ($queues as $queue) {\n    $queueStatusColor = $queue['state'] === \"running\" ? $colorBlack : $colorRed;\n    echo \"{$queue['name']} status {$queue['state']} | color=$queueStatusColor\\n\";\n}\necho \"---\\n\";\n// manual refresh + RabbitMQ version TAG + management interface link\necho \"RabbitMQ v$rabbitMqVersion, Erlang $erlangVersion\\n\";\necho \"$baseUrl:$port | href=$baseUrl:$port \\n\";\necho \"Refresh | refresh=true \\n\";\n\ncurl_close($ch);\n"
			}
		],
		"path": "Dev/rabbitmq-status.1m.php",
		"filename": "rabbitmq-status.1m.php",
		"dir": "Dev",
		"docsPlugin": "Dev/rabbitmq-status.1m.php.html",
		"docsCategory": "Dev.html",
		"pathSegments": [
			"Dev"
		],
		"categoryPathSegments": [
			{
				"path": "Dev",
				"text": "Dev",
				"isLast": true
			}
		],
		"title": "RabbitMQ Status",
		"version": "1.0",
		"author": "Yann Milin",
		"authors": [
			{
				"name": "Yann Milin",
				"githubUsername": "ymilin",
				"imageURL": "https://avatars.githubusercontent.com/u/3737075?v=4",
				"bio": "",
				"primary": true
			}
		],
		"desc": "Keep an eye on your RabbitMQ server status from your menu bar !",
		"imageURL": "http://i.imgur.com/Gz8FCJL.png",
		"dependencies": [
			"php \u003e= 5.4.0"
		],
		"aboutURL": "",
		"lastUpdated": "2021-03-08T15:21:52.039991Z",
		"vars": null
	}
}