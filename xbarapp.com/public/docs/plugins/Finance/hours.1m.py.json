{
	"plugin": {
		"files": [
			{
				"path": "Finance/hours.1m.py",
				"filename": "hours.1m.py",
				"content": "#!/usr/local/bin/python3\n# \u003cbitbar.title\u003ehours\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev2.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003eUdey Rishi\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003eudeyrishi\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eA simple command line tool for managing your work hours and the money you make\u003c/bitbar.desc\u003e\n# \u003cbitbar.image\u003ehttps://raw.githubusercontent.com/udeyrishi/hours/master/assets/shift_ongoing.png\u003c/bitbar.image\u003e\n# \u003cbitbar.dependencies\u003ePython3\u003c/bitbar.dependencies\u003e\n# \u003cbitbar.abouturl\u003ehttps://github.com/udeyrishi/hours\u003c/bitbar.abouturl\u003e\n\nfrom argparse import ArgumentParser\nimport csv\nfrom enum import Enum, auto\nimport os\nfrom distutils.util import strtobool\nfrom math import isclose\nimport sys\nimport time\n\nLOG_FILE_PATH = os.path.join(os.path.expanduser('~'), '.hours', 'log.csv')\n\nclass ModeFailException(Exception):\n    pass\n\ndef prompt_until_success(question, parser_fn, default=None):\n    while True:\n        print(question, end='')\n        try:\n            return parser_fn(input())\n        except ValueError:\n            if default is None:\n                print('Not a valid response.')\n            else:\n                return default\n\ndef script_path():\n    return os.path.realpath(__file__)\n\ndef script_name():\n    return os.path.basename(__file__)\n\nclass LogEvent(Enum):\n    WAGE_SET = auto()\n    PAYMENT = auto()\n    START = auto()\n    END = auto()\n\ndef positive_float(val):\n    num = float(val)\n    if num \u003c 0:\n        raise ValueError(f'{val} is a negative number.')\n    return num\n\nclass LogReport:\n    def __init__(self, active_wage=None, current_shift_started_at=None, earned_past_shifts=0, total_paid=0):\n        self.active_wage = active_wage\n        self.current_shift_started_at = current_shift_started_at\n        self.earned_past_shifts = earned_past_shifts\n        self.total_paid = total_paid\n\n    @property\n    def total_earned(self):\n        return self.earned_past_shifts + (((time.time() - self.current_shift_started_at)/60/60*self.active_wage) if self.current_shift_started_at is not None else 0)\n\n    @property\n    def outstanding_payment(self):\n        return self.total_earned - self.total_paid\n\n    @property\n    def has_outstanding_payment(self):\n        return not isclose(self.total_earned, self.total_paid, abs_tol=0.01)\n\n    @property\n    def in_shift(self):\n        return self.current_shift_started_at != None\n\n    @property\n    def has_active_wage(self):\n        return self.active_wage != None\n\n    @property\n    def current_shift_duration(self):\n        if self.current_shift_started_at is None:\n            return None\n        else:\n            duration = time.time() - self.current_shift_started_at\n            if duration \u003c 0:\n                raise ModeFailException(f'Log file at {LOG_FILE_PATH} is corrupted; the ongoing shift seems to have been started in the future.')\n            m, s = divmod(duration, 60)\n            h, m = divmod(m, 60)\n            return f'{int(h):02d}:{int(m):02d}:{int(s):02d}'\n\ndef prepare_report():\n    report = LogReport()\n    \n    for event, value in read_log():\n        if event == LogEvent.WAGE_SET:\n            report.active_wage = value\n        elif event == LogEvent.PAYMENT:\n            report.total_paid += value\n        elif event == LogEvent.START: \n            if report.in_shift:\n                raise ModeFailException(f'Log file at {LOG_FILE_PATH} is corrupted; found two successive {LogEvent.START.name}s without a {LogEvent.END.name} in between. Try fixing or deleting it.')\n            if report.active_wage is None:\n                raise ModeFailException(f'Log file at {LOG_FILE_PATH} is corrupted; A shift {event.name} event occurred before any {LogEvent.WAGE_SET.name} event.')\n            report.current_shift_started_at = value\n        elif event == LogEvent.END:\n            if not report.in_shift:\n                raise ModeFailException(f'Log file at {LOG_FILE_PATH} is corrupted; found two successive {LogEvent.END.name}s without a {LogEvent.START.name} in between. Try fixing or deleting it.')\n            if report.active_wage is None:\n                raise ModeFailException(f'Log file at {LOG_FILE_PATH} is corrupted; A shift {event.name} event occurred before any {LogEvent.WAGE_SET.name} event.')\n            \n            seconds = value - report.current_shift_started_at\n            report.current_shift_started_at = None\n            if (seconds \u003c 0):\n                raise ModeFailException(f'Log file at {LOG_FILE_PATH} is corrupted; A shift\\'s duration cannot be negative. Try fixing or deleting it.')\n            \n            report.earned_past_shifts += (seconds/60/60) * report.active_wage\n        else:\n            assert False, f'Support for new LogEvent {event.name} not added.'\n\n    return report\n\n\ndef read_log():\n    with open(LOG_FILE_PATH, 'r') as log_file:\n        csv_reader = csv.reader(log_file)\n        for log in csv_reader:\n            event = next((e for e in LogEvent if e.name == log[0]), None)\n            if event is None:\n                raise ModeFailException(f'Log file at {LOG_FILE_PATH} is corrupted; found an unknown log event: {log}')\n            value = float(log[1])\n            yield event, value\n\ndef write_log(event, value):\n    with open(LOG_FILE_PATH, 'a') as log_file:\n        csv_writer = csv.writer(log_file)\n        csv_writer.writerow([event.name, value])\n\ndef read_sanitized_report(expected_in_shift=None, if_shift_err=None):\n    if (expected_in_shift is None and if_shift_err is not None) or (expected_in_shift is not None and if_shift_err is None):\n        raise ValueError('Either both, or neither of expected_in_shift and if_shift_err should be null.')\n\n    report = prepare_report()\n    if not report.has_active_wage:\n        raise ModeFailException(f'Log file at {LOG_FILE_PATH} is corrupted; no {LogEvent.WAGE_SET.name} events found. Try fixing or deleting it.')\n\n    if expected_in_shift is not None and report.in_shift != expected_in_shift:\n        raise ModeFailException(if_shift_err)\n\n    return report\n\ndef configure_as_new(ask_permission=True):\n    if ask_permission:\n        should_configure = prompt_until_success(question=f'Looks like you have never configured {script_name()} before. Would you like to do so now? [Y/n] ', parser_fn=lambda x: strtobool(x) == 1, default=True)\n        if not should_configure:\n            raise ModeFailException(f'{script_name()} cannot run without configuring.')\n\n    wage = prompt_until_success(question='What is your hourly wage? ', parser_fn=positive_float)\n\n    if not os.path.exists(os.path.dirname(LOG_FILE_PATH)):\n        os.makedirs(os.path.dirname(LOG_FILE_PATH))\n\n    write_log(LogEvent.WAGE_SET, wage)\n    return LogReport(active_wage=wage)\n\nclass App:\n    class Mode:\n        def __init__(self, name, runner, help, is_default):\n            self.name = name\n            self.runner = runner\n            self.help = help\n            self.is_default = is_default\n\n    def __init__(self):\n        self.__registered_modes = []\n\n    def run(self):\n        assert len(self.__registered_modes) \u003e 0, 'No modes were registered'\n        default_modes = [mode for mode in self.__registered_modes if mode.is_default]\n        assert len(default_modes) == 1, 'Exactly 1 mode should be registered as the default'\n        default_mode = default_modes[0]\n\n        parser = ArgumentParser(description='A tool for managing your work hours and the money you make.')\n        group = parser.add_mutually_exclusive_group()\n\n        for mode in self.__registered_modes:\n            group.add_argument(f'-{mode.name[0]}', f'--{mode.name}', action='store_true', help=mode.help)\n\n        args = parser.parse_args()\n\n        matching_mode = next((mode for mode in self.__registered_modes if getattr(args, mode.name)), default_mode)\n        try:\n            matching_mode.runner()\n            return 0\n        except ModeFailException as e:\n            print(str(e))\n            return 3\n\n    def register_mode(self, expected_in_shift=None, if_shift_err=None, help=None, configure_if_needed=True, is_default=False):\n        def wrapper(mode_fn):\n            report_param_name = next((param[0] for param in mode_fn.__annotations__.items() if param[1] == LogReport), None)\n            num_other_params = len([param for param in mode_fn.__annotations__.items() if param[1] != LogReport])\n            assert num_other_params == 0, 'mode functions can only optionally request the current report. Everything else must be gathered via user input for bitbar compatibility.'\n\n            def mode_runner():\n                if os.path.isfile(LOG_FILE_PATH):\n                    report = read_sanitized_report(expected_in_shift, if_shift_err)\n                elif configure_if_needed:\n                    report = configure_as_new()\n                else:\n                    report = None\n\n                kwargs = dict()\n                if report_param_name is not None:\n                    kwargs[report_param_name] = report\n                \n                mode_fn(**kwargs)\n\n            self.__registered_modes.append(App.Mode(name=mode_fn.__name__, runner=mode_runner, help=help, is_default=is_default))\n            return mode_runner\n        return wrapper\n\napp = App()\n\n@app.register_mode(help='see the current status summary in a bitbar compatible syntax', configure_if_needed=False, is_default=True)\ndef bitbar(report: LogReport):\n    if report is None:\n        print(f'⚙️{script_name()} needs a one-time configuration.')\n        print(f'Configure | refresh=true bash=\"{script_path()}\" param1=-i terminal=true')\n        return 0\n\n    if report.in_shift:\n        print(f'🕒 {report.current_shift_duration}')\n    else:\n        print('🏠')\n\n    print('---')\n    if report.in_shift:\n        print(f'End Shift | refresh=true bash=\"{script_path()}\" param1=-e terminal=false')\n    else:\n        print(f'Start Shift | refresh=true bash=\"{script_path()}\" param1=-s terminal=false')\n\n    print('---')\n    if not report.in_shift:\n        print(f'Update wage | refresh=true bash=\"{script_path()}\" param1=-w terminal=true')\n    print(f'Receive payment | refresh=true bash=\"{script_path()}\" param1=-p terminal=true')\n\n    print(f'Open log | refresh=true bash=\"less\" param1={LOG_FILE_PATH} terminal=true')\n\n    if report.has_outstanding_payment:\n        print('---')\n        if report.outstanding_payment \u003e 0:\n            print(f'💰 {report.outstanding_payment:.2f} pending')\n        else:\n            print(f'💰 {-report.outstanding_payment:.2f} overpaid')\n\n@app.register_mode(help='see the current status summary info')\ndef info(report: LogReport):\n    if report.in_shift:\n        print(f'🕒 {report.current_shift_duration}', end='')\n    else:\n        print('🏠', end='')\n\n    if report.has_outstanding_payment:\n        print(' | ', end='')\n        if report.outstanding_payment \u003e 0:\n            print(f'💰 {report.outstanding_payment:.2f} pending', end='')\n        else:\n            print(f'💰 {-report.outstanding_payment:.2f} overpaid', end='')\n    print()\n\n@app.register_mode(expected_in_shift=False, if_shift_err='Cannot change the wage while a shift is ongoing.', help='update the hourly wage moving forward', configure_if_needed=False)\ndef wage(report: LogReport):\n    if report is None:\n        # User is trying to use this mode as the first-time setup itself. Do not ask for wage 2x\n        configure_as_new(ask_permission=False)\n    else:\n        wage = prompt_until_success(question='What is your new hourly wage? ', parser_fn=positive_float)\n        write_log(LogEvent.WAGE_SET, wage)\n\n@app.register_mode(help='add a received payment')\ndef payment():\n    amount = prompt_until_success(question='How much amount did you receive? ', parser_fn=positive_float)\n    write_log(LogEvent.PAYMENT, amount)\n\n@app.register_mode(expected_in_shift=False, if_shift_err='Cannot start a shift while one is ongoing.', help='start a shift')\ndef start():\n    write_log(LogEvent.START, time.time())\n\n@app.register_mode(expected_in_shift=True, if_shift_err='Cannot end a shift when none is ongoing.', help='end a shift')\ndef end():\n    write_log(LogEvent.END, time.time())\n\n@app.register_mode(help='prints the path to the log file')\ndef log():\n    print(LOG_FILE_PATH)\n\nif __name__ == '__main__':\n    sys.exit(app.run())"
			}
		],
		"path": "Finance/hours.1m.py",
		"filename": "hours.1m.py",
		"dir": "Finance",
		"docsPlugin": "Finance/hours.1m.py.html",
		"docsCategory": "Finance.html",
		"pathSegments": [
			"Finance"
		],
		"categoryPathSegments": [
			{
				"path": "Finance",
				"text": "Finance",
				"isLast": true
			}
		],
		"title": "hours",
		"version": "v2.0",
		"author": "Udey Rishi",
		"authors": [
			{
				"name": "Udey Rishi",
				"githubUsername": "udeyrishi",
				"imageURL": "https://avatars.githubusercontent.com/u/4692593?v=4",
				"bio": "Living life, one commit at a time",
				"primary": true
			}
		],
		"desc": "A simple command line tool for managing your work hours and the money you make",
		"imageURL": "https://raw.githubusercontent.com/udeyrishi/hours/master/assets/shift_ongoing.png",
		"dependencies": [
			"Python3"
		],
		"aboutURL": "https://github.com/udeyrishi/hours",
		"lastUpdated": "2021-03-08T15:21:53.616911Z",
		"vars": null
	}
}