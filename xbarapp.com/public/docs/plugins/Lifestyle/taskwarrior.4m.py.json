{
	"plugin": {
		"files": [
			{
				"path": "Lifestyle/taskwarrior.4m.py",
				"filename": "taskwarrior.4m.py",
				"content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# Taskwarrior\n#\n# \u003cbitbar.title\u003eTaskwarrior\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev2.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003eChristoph Russ\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003echristophruss\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eTask managment through your menu-bar.\u003c/bitbar.desc\u003e\n# \u003cbitbar.dependencies\u003etask,python\u003c/bitbar.dependencies\u003e\n# \u003cbitbar.image\u003ehttp://i.imgur.com/vjEt7Is.jpg\u003c/bitbar.image\u003e\n#\n# Dependencies:\n#   taskwarrior (http://taskwarrior.org)\n#      available via homebrew `brew install task`\n\n#\n# TODO\n# * In a sub-menu (at the bottom) Allow to restart previously completed tasks\n# * Allow to delete tasks (also in a sub-menu?)\n#\n\nimport os\nimport re\nimport subprocess\nfrom subprocess import Popen, PIPE\n\n\ndef trigger_actions(argv):\n    t_id = argv[-1]\n    action = argv[-2]\n    subprocess.call(['/usr/local/bin/task', t_id, action])\n\n\ndef build_command(t_id, action, refresh=True):\n    cmd = ''\n\n    if refresh:\n        cmd = cmd + ' refresh=true'\n\n    cmd = cmd + ' bash=/usr/bin/python param1=' + __file__ + ' param2='\n\n    cmd = cmd + action\n\n    cmd = cmd + ' param3=' + str(t_id)\n\n    cmd = cmd + ' terminal=false'\n\n    return cmd\n\n\ndef print_output(\n        cmd,\n        color,\n        head,\n        print_content=True,\n        command='',\n        ignore_id_list=[],\n        highlight_id_list=[],\n        highlight_color=' color=Red',\n        highlight_command='',\n        alternate_command=''):\n    output = ''\n\n    # important: PIPE the stderr, since task likes to use that - a lot ...\n    p = Popen(['/usr/local/bin/task', cmd],\n              stdin=None, stdout=PIPE, stderr=PIPE)\n    output, err = p.communicate()\n\n    output_lines = output.split('\\n')\n\n    id_list = []\n    content_lines = []\n\n    for output_line in output_lines:\n        output_line = output_line.rstrip()\n        if not output_line:\n            continue\n        # When looking for 'active' or 'next' tasks, we want to look only at\n        # lines that start with a digit or a -. Other line are likely extra\n        # data like annotations from bugwarrior sync\n        content_id = output_line.split()[0]\n        if not content_id.isdigit() and content_id not in ['--', '-', 'ID']:\n            continue\n        line_groups = re.match('^(\\s*\\d+|\\s*ID|\\s*-+)(.*)', output_line)\n        content_lines.append('[{}]{}'.format(*line_groups.groups()))\n\n    content_count = len(content_lines[2:-1])\n\n    if head:\n        if content_count == 0:\n            print 'ⓣ'  # ⓪ #⓿\n        elif content_count \u003c 21:\n            circle_number = ['⓪', '①', '②', '③', '④', '⑤', '⑥',\n                             '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬',\n                             '⑭', '⑮', '⑯', '⑰', '⑱', '⑲', '⑳']\n            print circle_number[content_count]  # + '|' + color_pending\n        else:\n            print str(content_count)  # + '| color=Red'\n\n        print '---'\n\n    if content_count \u003c 1:\n        return id_list\n\n    table_head = content_lines[0]\n\n    # total_number_of_tasks = content_lines[-1]\n\n    content_formatting = ' | size=12 font=Courier'\n\n    if print_content:\n        print table_head + content_formatting\n        print '---'\n\n    for content_line in content_lines[2:-1]:\n        content_re = re.match('^\\[\\s*(.+)\\]\\s+([0-9A-Fa-f]+)?', content_line)\n        content_id = content_re.group(1)\n        \n        if content_id == '-':\n            # should be the UUID in this case\n            content_id = content_re.group(2)\n\n        if content_id in ignore_id_list:\n            continue\n\n        id_list.append(content_id)\n\n        if print_content:\n            cmd = ''\n\n            if len(command) \u003e 0:\n                cmd = build_command(t_id=content_id, action=command)\n\n            if content_id in highlight_id_list:\n                if len(highlight_command) \u003e 0:\n                    cmd = build_command(\n                        t_id=content_id, action=highlight_command)\n                print content_line + content_formatting + highlight_color + cmd\n            else:\n                print content_line + content_formatting + color + cmd\n\n            # adding an alternative command (press ALT for this!)\n            # printing the same stuff again, only with a different action\n            # attached\n            if len(alternate_command) \u003e 0:\n                alt_cmd = build_command(\n                    t_id=content_id, action=alternate_command)\n\n                if content_id in highlight_id_list:\n                    print content_line + content_formatting + highlight_color + alt_cmd + ' alternate=true'\n                else:\n                    print content_line + content_formatting + color + alt_cmd + ' alternate=true'\n\n    return id_list\n\n\ndef is_darkmode():\n    FNULL = open(os.devnull, 'w')\n    return_code = subprocess.call(['/usr/bin/defaults', 'read', '-g',\n                                   'AppleInterfaceStyle'], stdout=FNULL, stderr=subprocess.STDOUT)\n    if (return_code == 1):\n        return False\n    else:\n        return True\n\n\ndef main(argv):\n\n    if len(argv) \u003e 1:\n        trigger_actions(argv)\n        exit()\n\n    if is_darkmode():\n        color_running = ' color=Red'\n        color_pending = ' color=Yellow'\n        color_completed = ' color=Green'\n    else:\n        color_running = ' color=Red'\n        color_pending = ' color=Black'\n        color_completed = ' color=Green'\n\n    id_list = print_output('active', color_running, True, print_content=False)\n\n    if len(id_list) \u003e 0:\n        print '---'\n\n    print_output(\n        'next',\n        color_pending,\n        False,\n        command='start',\n        highlight_id_list=id_list,\n        highlight_color=color_running,\n        highlight_command='stop',\n        alternate_command='done')\n\n    print '---'\n\n    # ok, so if you want to delete a command, you have to press done first ...\n    # sorry, but there is only one alternative command I can provide above ...\n    print_output(\n        'completed',\n        color_completed,\n        False,\n        command='start',\n        alternate_command='delete')\n\n    return\n\nif __name__ == \"__main__\":\n    import sys\n    main(sys.argv)\n"
			}
		],
		"path": "Lifestyle/taskwarrior.4m.py",
		"filename": "taskwarrior.4m.py",
		"dir": "Lifestyle",
		"docsPlugin": "Lifestyle/taskwarrior.4m.py.html",
		"docsCategory": "Lifestyle.html",
		"pathSegments": [
			"Lifestyle"
		],
		"categoryPathSegments": [
			{
				"path": "Lifestyle",
				"text": "Lifestyle",
				"isLast": true
			}
		],
		"title": "Taskwarrior",
		"version": "v2.0",
		"author": "Christoph Russ",
		"authors": [
			{
				"name": "Christoph Russ",
				"githubUsername": "christophruss",
				"imageURL": "https://avatars.githubusercontent.com/u/12080753?v=4",
				"bio": "",
				"primary": true
			}
		],
		"desc": "Task managment through your menu-bar.",
		"imageURL": "http://i.imgur.com/vjEt7Is.jpg",
		"dependencies": [
			"task",
			"python"
		],
		"aboutURL": "",
		"lastUpdated": "2021-03-08T15:21:56.297012Z",
		"vars": null
	}
}