
<!doctype html>
<html lang='en' style='background: #111;'>
	<head>
		<meta charset='utf-8' />
		<meta name='viewport' content='width=device-width' />
		<meta http-equiv='X-UA-Compatible' content='ie=edge'>
		<title>Sunrise in your macOS menu bar</title>
		<link rel='stylesheet' href='/public/css/xbar.css?cb=08%20Mar%2021%2015%3a22%20GMT'>
		<link rel='preconnect' href='https://fonts.gstatic.com'>
		<link rel='preconnect' href='https://fonts.googleapis.com'>
		<link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Bodoni+Moda:wght@500&display=swap'>
		
	<meta name='description' content='Displays sunrise, sunset, and day length for a location. - install xbar for free to get started.'>
	<meta name='author' content='Brad Greenlee'>
	<meta name='keywords' content='macos,menubar,xbar,bitbar'>
	<meta itemprop='image' content='https://raw.githubusercontent.com/bgreenlee/SunriseBitBar/main/sunrise-bitbar.png'>
	<meta itemprop='name' content='Sunrise in your macOS menu bar'>
	<meta itemprop='description' content='Displays sunrise, sunset, and day length for a location. - install xbar for free to get started.'>
	<meta name='twitter:card' content='summary_large_image'>
	<meta name='twitter:title' content='Sunrise in your macOS menu bar'>
	<meta name='twitter:description' content='Displays sunrise, sunset, and day length for a location. - install xbar for free to get started.'>
	<meta name='twitter:image' content='https://raw.githubusercontent.com/bgreenlee/SunriseBitBar/main/sunrise-bitbar.png'>
	<meta name='twitter:creator' content='matryer'>
	<meta property='og:title' content='Sunrise in your macOS menu bar'>
	<meta property='og:description' content='Displays sunrise, sunset, and day length for a location. - install xbar for free to get started.'>
	<meta property='og:url' content='https://xbarapp.com/plugins/Time/sunrise.4h.swift.html'>
	<meta property='og:site_name' content='xbar lets you put anything into your macOS menu bar'>
	<meta property='og:type' content='article'>
	<meta property='og:image' content='https://raw.githubusercontent.com/bgreenlee/SunriseBitBar/main/sunrise-bitbar.png'>
	<link rel='apple-touch-icon' sizes='180x180' href='https://raw.githubusercontent.com/bgreenlee/SunriseBitBar/main/sunrise-bitbar.png'>
	<link rel='icon' type='image/png' sizes='32x32' href='https://raw.githubusercontent.com/bgreenlee/SunriseBitBar/main/sunrise-bitbar.png'>
	<link rel='shortcut icon' href='https://raw.githubusercontent.com/bgreenlee/SunriseBitBar/main/sunrise-bitbar.png'>
	<meta name='msapplication-TileColor' content='#ffffff'>
	<meta name='msapplication-config' content='/public/browserconfig.xml'>
	<meta name='theme-color' content='#ffffff'>
	<style>
		.code-background {
			background: rgb(255,255,255);
			background: linear-gradient(to right, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.1) 100%);
		}
		.plugin-app-link {
			margin-left: -32px;
		}
	</style>

	</head>
	<body>
		<header class='flex flex-col'>
			<div class='container mx-auto'>
				<div class='flex items-center space-x-8 p-8 text-white'>
					<a href='/' class='inline-block py-2 text-2xl flex items-center space-x-2 font-bold'>
						<img alt='xbar logo: a circle with three dots inside it' src='/public/img/xbar-2048.png' style='width:48px;height:48px;' />
						<span>xbar</span>
					</a>
					<div class='flex-grow'></div>
					<div>
						<a 
							target='github'
							href='https://github.com/sponsors/matryer' 
							class='text-white px-4 py-2 whitespace-nowrap'
						><span class='mr-1'>ðŸ’œ</span> Sponsor</a>
					</div>
					<div class='hidden md:block'>
						<a 
							target='github'
							href='/dl' 
							class='rounded bg-white text-gray-800 hover:text-black px-4 py-2 shadow hover:shadow-lg whitespace-nowrap'
						>Coming soon</a>
					</div>
				</div>
			</div>
		</header>
		<div id='menubar' class='text-white whitespace-nowrap overflow-hidden flex flex-wrap justify-end items-center text-right'>
			
			
				<a 
					
					href='/docs/plugins/AWS.html'
				>
					AWS
				</a>
			
				<a 
					
					href='/docs/plugins/Cryptocurrency.html'
				>
					Cryptocurrency
				</a>
			
				<a 
					
					href='/docs/plugins/Dev.html'
				>
					Dev
				</a>
			
				<a 
					
					href='/docs/plugins/E-Commerce.html'
				>
					E-Commerce
				</a>
			
				<a 
					
					href='/docs/plugins/Email.html'
				>
					Email
				</a>
			
				<a 
					
					href='/docs/plugins/Environment.html'
				>
					Environment
				</a>
			
				<a 
					
					href='/docs/plugins/Finance.html'
				>
					Finance
				</a>
			
				<a 
					
					href='/docs/plugins/Games.html'
				>
					Games
				</a>
			
				<a 
					
					href='/docs/plugins/IoT.html'
				>
					IoT
				</a>
			
				<a 
					
					href='/docs/plugins/Lifestyle.html'
				>
					Lifestyle
				</a>
			
				<a 
					
					href='/docs/plugins/Music.html'
				>
					Music
				</a>
			
				<a 
					
					href='/docs/plugins/Network.html'
				>
					Network
				</a>
			
				<a 
					
					href='/docs/plugins/Politics.html'
				>
					Politics
				</a>
			
				<a 
					
					href='/docs/plugins/Science.html'
				>
					Science
				</a>
			
				<a 
					
					href='/docs/plugins/Sports.html'
				>
					Sports
				</a>
			
				<a 
					
					href='/docs/plugins/System.html'
				>
					System
				</a>
			
				<a 
					 class='rounded selected' 
					href='/docs/plugins/Time.html'
				>
					Time
				</a>
			
				<a 
					
					href='/docs/plugins/Tools.html'
				>
					Tools
				</a>
			
				<a 
					
					href='/docs/plugins/Travel.html'
				>
					Travel
				</a>
			
				<a 
					
					href='/docs/plugins/Weather.html'
				>
					Weather
				</a>
			
				<a 
					
					href='/docs/plugins/Web.html'
				>
					Web
				</a>
			
		</div>
		
	<div class='container mx-auto flex flex-wrap space-x-8 justify-start items-start mt-16'>
		<div class='flex flex-col justify-start'>
			<div class='px-8 py-2 max-w-3xl'>
				<h1 class='fancy-font text-white text-6xl'>Sunrise</h1>
			</div>
			<div class='p-8 text-sm'>
				
					
						
							<div class='flex space-x-4 pb-8'>
								<div class='tiny-photo'>
									<a 
										href='/docs/contributors/bgreenlee.html'
									>
										<img class='rounded shadow primary' src='https://avatars.githubusercontent.com/u/2901?v=4'>
									</a>
								</div>
								<div>
									<a 
										href='/docs/contributors/bgreenlee.html'
										class='light-background rounded-sm shadow-md px-4 py-2 text-white' 
										style='text-decoration: none;'
									>
										Brad Greenlee (<code style='color:white;'>@bgreenlee</code> on GitHub)
									</a>
								</div>
							</div>
						
					
				
				
					<p class='my-8 text-white opacity-75 text-lg max-w-lg'>
						Displays sunrise, sunset, and day length for a location.
					</p>
				
				<div class='plugin-app-link hidden md:flex items-end p-8 m-8 mb-16 bg-black bg-opacity-25 rounded-lg shadow max-w-md'>
					<div>
						<a 
							href='xbar://app.xbarapp.com/openPlugin?path=Time%2fsunrise.4h.swift'
							class='rounded bg-white text-gray-800 hover:text-black px-4 py-2 shadow hover:shadow-lg whitespace-nowrap'
						><span class='mr-1'>ðŸ–¥</span> Open in xbar app</a>
					</div>
					<div class='opacity-50 text-sm text-white ml-3'>Requires <a target='github' href='/dl' class='underline'>xbar app</a></div>
				</div>
				
			</div>
		</div>
		<div 
			class='flex flex-col justify-center mb-16'
		>
			<img 
				class='max-w-md w-full'
				src='https://raw.githubusercontent.com/bgreenlee/SunriseBitBar/main/sunrise-bitbar.png' 
				alt='Image preview of Sunrise plugin.'
				onerror='this.onerror=null;this.src="/public/img/xbar-2048.png";'
			/>
		</div>
	</div>

	
		<div class='code-background text-white p-8 pb-24'>
			<div class='container mx-auto'>
				<div class='flex flex-wrap py-8 space-x-4 justify-end'>
					<div>
						<h2 class='md:text-2xl text-bold'>
							<code>sunrise.4h.swift</code>
						</h2>
					</div>
					<div class='flex-grow'></div>
					<div>
						<a class='text-sm text-white hover:text-black hover:bg-white px-4 py-2 rounded' target='github' href='https://github.com/matryer/bitbar-plugins/edit/master/Time/sunrise.4h.swift'>Edit</a>
					</div>
					<div>
						<a class='text-sm text-gray-700 bg-white hover:bg-gray-100 active:text-black px-4 py-2 rounded' target='github' href='https://github.com/matryer/bitbar-plugins/blob/master/Time/sunrise.4h.swift'>Open on GitHub</a>
					</div>
				</div>
				<div>
					<pre class='text-sm whitespace-pre-wrap'><code class='break-all '>#!/usr/bin/env xcrun swift

/*
 * &lt;bitbar.title&gt;Sunrise&lt;/bitbar.title&gt;
 * &lt;bitbar.version&gt;v1.1.1&lt;/bitbar.version&gt;
 * &lt;bitbar.author&gt;Brad Greenlee&lt;/bitbar.author&gt;
 * &lt;bitbar.author.github&gt;bgreenlee&lt;/bitbar.author.github&gt;
 * &lt;bitbar.desc&gt;Displays sunrise, sunset, and day length for a location.&lt;/bitbar.desc&gt;
 * &lt;bitbar.image&gt;https://raw.githubusercontent.com/bgreenlee/SunriseBitBar/main/sunrise-bitbar.png&lt;/bitbar.image&gt;
 * &lt;bitbar.dependencies&gt;Xcode,swift&lt;/bitbar.dependencies&gt;
 * &lt;bitbar.abouturl&gt;https://github.com/bgreenlee/SunriseBitBar&lt;/bitbar.abouturl&gt;
 */

// Customizations

let LOCATION = &#34;Seattle, WA&#34; // or lat,lon coordinates
let DAYS = 7 // number of days to show
let PAST_DAYS = 0 // number of days in the past to show
let TIME_STYLE:DateFormatter.Style = .short // .short, .medium, .long, .full
let LOCATION_FONT = &#34;Menlo&#34;
let LOCATION_COLOR = &#34;black&#34;
let SUNRISE_FONT = &#34;Menlo&#34;
let SUNRISE_COLOR = &#34;blue&#34;
let SYMBOL_COLOR = &#34;orange&#34;

// Main code

let coordinate = try parseLocation(LOCATION)
// Reverse geocode so we can get the timezone in the location
let coder = CLGeocoder()
let loc = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)
var placemark: CLPlacemark?
var timezone: TimeZone?
coder.reverseGeocodeLocation(loc) { (placemarks, error) in
    placemark = placemarks?.last
    timezone = placemark?.timeZone
    CFRunLoopStop(CFRunLoopGetCurrent())
}
CFRunLoopRun() // wait for reverse geocode to finish

print(&#34;:sunrise:\n---\n&#34;)

if let placemark = placemark {
    if let city = placemark.locality, let administrativeArea = placemark.administrativeArea, let country = placemark.country {
        if country == &#34;United States&#34; {
            print(&#34;\(city), \(administrativeArea)|font=\(LOCATION_FONT) color=\(LOCATION_COLOR)&#34;)
        } else {
            print(&#34;\(city), \(administrativeArea), \(country)|font=\(LOCATION_FONT) color=\(LOCATION_COLOR)&#34;)
        }
    } else {
        print(&#34;\(placemark.name ?? &#34;Unknown&#34;)&#34;)
    }
}

let today = Date()
for i in -PAST_DAYS..&lt;DAYS-PAST_DAYS {
    let date = Calendar.current.date(byAdding: .day, value: i, to: today)!
    if let (sunrise, sunset) = NTSolar.sunRiseAndSet(forDate: date, atLocation: coordinate, inTimeZone: timezone!) {
        let dateFormatter = DateFormatter()
        dateFormatter.setLocalizedDateFormatFromTemplate(&#34;MMMd&#34;)
        print(dateFormatter.string(from: date).padding(toLength: 7, withPad: &#34; &#34;, startingAt: 0), terminator:&#34;&#34;)

        let timeFormatter = DateFormatter()
        timeFormatter.dateStyle = .none
        timeFormatter.timeStyle = TIME_STYLE
        if let timezone = timezone {
            timeFormatter.timeZone = timezone
        }

        let sunriseTime = timeFormatter.string(from: sunrise).lowercased()
        let sunsetTime = timeFormatter.string(from: sunset).lowercased()
        let daylengthFormatter = DateComponentsFormatter()
        daylengthFormatter.unitsStyle = .abbreviated
        daylengthFormatter.allowedUnits = [.minute, .hour]
        let formattedDayLength = daylengthFormatter.string(from: sunrise, to: sunset)!

        print(&#34;:sunrise: \(sunriseTime) :sunset: \(sunsetTime) :clock: \(formattedDayLength)|font=\(SUNRISE_FONT)\(i == 0 ? &#34;-Bold&#34; : &#34;&#34;) color=\(SUNRISE_COLOR) sfcolor=\(SYMBOL_COLOR)&#34;)
    }
}

struct ValidationError: Error, CustomStringConvertible {
    var description:String

    init(_ description:String) {
        self.description = description
    }
}

func parseLocation(_ argument: String) throws -&gt; CLLocationCoordinate2D {
    let parts = argument.components(separatedBy: &#34;,&#34;)
    if parts.count == 2, let latitude = Double(parts[0]), let longitude = Double(parts[1]) {
        return CLLocationCoordinate2D(latitude: latitude, longitude: longitude)
    } else {
        // see if we can geocode it
        let coder = CLGeocoder()
        var location: CLLocation?
        coder.geocodeAddressString(argument) { (placemarks, error) in
            location = placemarks?.last?.location
            CFRunLoopStop(CFRunLoopGetCurrent())
        }
        CFRunLoopRun()
        if let location = location {
            return location.coordinate
        }
        throw ValidationError(&#34;Could not parse location. Provide either a valid place name or latitude,longitude.&#34;)
    }
}

//
//
//    NTSolar.swift
//
//  Created by Neil Tiffin on 5/8/19.
//  Copyright Â© 2019 Performance Champions, Inc.
//  Copyright Â© 2019 Neil Tiffin.
//
//  Released to the public domain by Neil Tiffin, May 2019
//  Released to the public domain by Performance Champions, Inc., May 2019
//

import Foundation
import CoreLocation

var stderr = FileHandle.standardError

extension FileHandle : TextOutputStream {
  public func write(_ string: String) {
    guard let data = string.data(using: .utf8) else { return }
    self.write(data)
  }
}

/// Class to calculate sunrise sunset.
///
/// C code originally from: [http://stjarnhimlen.se/comp/sunriset.c](http://stjarnhimlen.se/comp/sunriset.c)
class NTSolar {
    // MARK: - Public Swift Interface

    /// Calculate the sun rise and set times.
    ///
    /// - Parameters:
    ///   - forDate: The date for the calculation. You should ensure that the date, which is stored as UTC, is the date
    ///         really wanted in the given time zone. It will be converted to the given time zone before being used.
    ///   - atLocation: The latitude and longitude for the calculation.
    ///   - inTimeZone: The time zone for the resulting date and times.
    /// - Returns: If the sun both rises and sets on the day requested and at the
    ///     latitude requested then return sun rise and set times rounded down to the minute, nil othewise.
    class func sunRiseAndSet(forDate: Date,
                             atLocation: CLLocationCoordinate2D,
                             inTimeZone: TimeZone) -&gt; (sunrise: Date, sunset: Date)? {

        var calendar = Calendar(identifier: .gregorian)
        calendar.timeZone = inTimeZone
        var comp = calendar.dateComponents([.day, .year, .month], from: forDate)
        comp.calendar = calendar

        guard let year = comp.year,
            let month = comp.month,
            let day = comp.day else {
                print(&#34;Failed to find date components.&#34;, to:&amp;stderr)
                return nil
        }

        let (riseUTC, setUTC, code) = NTSolar.sun_rise_set(year: year,
                                                           month: month,
                                                           day: day,
                                                           lon: atLocation.longitude,
                                                           lat: atLocation.latitude)

        if code != .RiseAndSet {
            print(&#34;Failed to find rise and set.&#34;, to:&amp;stderr)
            return nil
        }

        // Calc sunrise
        var riseLocalHrs = riseUTC &#43; (Double(inTimeZone.secondsFromGMT()) / 3600.0)
        if riseLocalHrs &gt; 24.0 {
            riseLocalHrs -= 24.0
        }
        let riseHoursInt = Int(riseLocalHrs)
        comp.hour = riseHoursInt

        comp.minute = Int(  (( riseLocalHrs - Double(riseHoursInt) ) * 60.0).rounded() )
        comp.second = 0
        comp.nanosecond = 0
        guard let riseTime = comp.date else {
            print(&#34;\nFailed to calculate rise time hrs: \(riseLocalHrs).\n\(comp)\n&#34;, to:&amp;stderr)
            return nil
        }

        // Calc sunset
        var setLocalHrs = setUTC &#43; (Double(inTimeZone.secondsFromGMT()) / 3600.0)
        if setLocalHrs &gt; 24.0 {
            setLocalHrs -= 24.0
        }
        let setHoursInt = Int(setLocalHrs)
        comp.hour = setHoursInt
        comp.minute = Int( ((setLocalHrs - Double(setHoursInt) ) * 60.0).rounded() )
        comp.second = 0
        comp.nanosecond = 0
        guard let setTime = comp.date else {
            print(&#34;\nFailed to calculate set time hrs: \(setLocalHrs).\n\(comp)\n&#34;, to:&amp;stderr)
            return nil
        }

        return (riseTime, setTime)
    }

    // MARK: - SUNRISET.C

    // C code originally from: [http://stjarnhimlen.se/comp/sunriset.c](http://stjarnhimlen.se/comp/sunriset.c)
    //
    // The conversion process removed pointers in favor of return tuples, converted macros to function calls,
    // added return code enum, and converted
    // comments to work with Xcode.  Of course the C code had to be converted to Swift, but that was minimal.
    //
    // As much as possible the original code was left intact in order to not introduce bugs.
    // In other words, some code was left unfashionable by today&#39;s standards.

    enum ReturnCode: Int {
        /// Sun is below the specified &#34;horizon&#34; 24 hours
        /// &#34;Day&#34; length = 0 hours, trise and tset are
        /// both set to the time when the sun is at south.
        case SunAlwaysBelow = -1

        /// Sun rises/sets this day, times stored at rise and set.
        case RiseAndSet = 0

        /// Sun above the specified &#34;horizon&#34; 24 hours.
        /// trise set to time when the sun is at south,
        /// minus 12 hours while tset is set to the south
        /// time plus 12 hours. &#34;Day&#34; length = 24 hours
        case SunAlwaysAbove = 1
    }

    /* &#43;&#43;&#43;Date last modified: 05-Jul-1997 */
    /* Updated comments, 05-Aug-2013 */
    /*
     SUNRISET.C - computes Sun rise/set times, start/end of twilight, and
     the length of the day at any date and latitude

     Written as DAYLEN.C, 1989-08-16

     Modified to SUNRISET.C, 1992-12-01

     (c) Paul Schlyter, 1989, 1992

     Released to the public domain by Paul Schlyter, December 1992
     */

    /// A macro to compute the number of days elapsed since 2000 Jan 0.0
    /// (which is equal to 1999 Dec 31, 0h UT)
    private class func days_since_2000_Jan_0(y:Int, m:Int, d:Int) -&gt; Int {
        return (367*(y)-((7*((y)&#43;(((m)&#43;9)/12)))/4)&#43;((275*(m))/9)&#43;(d)-730530)
    }

    /* Some conversion factors between radians and degrees */
    private static let PI  =      3.1415926535897932384
    private static let RADEG   =  ( 180.0 / PI )
    private static let DEGRAD  =  ( PI / 180.0 )

    /* The trigonometric functions in degrees */
    private class func sind(x: Double) -&gt; Double  { return sin((x)*DEGRAD) }
    private class func cosd(x: Double) -&gt; Double  { return  cos((x)*DEGRAD) }
    private class func tand(x: Double) -&gt; Double  { return  tan((x)*DEGRAD) }
    private class func atand(x: Double)  -&gt; Double  { return   (RADEG*atan(x)) }
    private class func asind(x: Double)  -&gt; Double  { return   (RADEG*asin(x)) }
    private class func acosd(x: Double)  -&gt; Double  { return   (RADEG*acos(x)) }
    private class func atan2d(y: Double,x: Double)-&gt; Double  { return  (RADEG*atan2(y,x)) }

    /* Following are some macros around the &#34;workhorse&#34; function __daylen__ */
    /* They mainly fill in the desired values for the reference altitude    */
    /* below the horizon, and also selects whether this altitude should     */
    /* refer to the Sun&#39;s center or its upper limb.                         */


    /** This macro computes the length of the day, from sunrise to sunset. */
    /** Sunrise/set is considered to occur when the Sun&#39;s upper limb is    */
    /** 35 arc minutes below the horizon (this accounts for the refraction */
    /** of the Earth&#39;s atmosphere).                                        */
    class func day_length(year: Int, month: Int, day: Int, lon: Double, lat: Double) -&gt; Double {
        return daylen( year: year, month: month, day: day, lon: lon, lat: lat, altit: -35.0/60.0, upper_limb: 1 )
    }

    /** This macro computes the length of the day, including civil twilight. */
    /** Civil twilight starts/ends when the Sun&#39;s center is 6 degrees below  */
    /** the horizon.                                                         */
    class func day_civil_twilight_length(year: Int, month: Int, day: Int, lon: Double, lat: Double) -&gt; Double {
        return daylen( year: year, month: month, day: day, lon: lon, lat: lat, altit: -6.0, upper_limb: 0 )
    }

    /** This macro computes the length of the day, incl. nautical twilight.  */
    /** Nautical twilight starts/ends when the Sun&#39;s center is 12 degrees    */
    /** below the horizon.                                                   */
    class func day_nautical_twilight_length(year: Int, month: Int, day: Int, lon: Double, lat: Double) -&gt; Double {
        return daylen( year: year, month: month, day: day, lon: lon, lat: lat, altit: -12.0, upper_limb: 0 )
    }

    /** This macro computes the length of the day, incl. astronomical twilight. */
    /** Astronomical twilight starts/ends when the Sun&#39;s center is 18 degrees   */
    /** below the horizon.                                                      */
    class func day_astronomical_twilight_length(year: Int, month: Int, day: Int, lon: Double, lat: Double) -&gt; Double {
        return daylen( year: year, month: month, day: day, lon: lon, lat: lat, altit: -18.0, upper_limb: 0 )
    }

    /** This macro computes times for sunrise/sunset.                      */
    /** Sunrise/set is considered to occur when the Sun&#39;s upper limb is    */
    /** 35 arc minutes below the horizon (this accounts for the refraction */
    /** of the Earth&#39;s atmosphere).                                        */
    class func sun_rise_set(year: Int, month: Int, day: Int , lon: Double, lat: Double) -&gt; (trise: Double, tset: Double, code: ReturnCode) {
        let (start, end, code) = sunriset( year: year, month: month, day: day, lon: lon, lat: lat, altit: -35.0/60.0, upper_limb: 1)
        return (start, end, code)
    }

    /** This macro computes the start and end times of civil twilight.       */
    /** Civil twilight starts/ends when the Sun&#39;s center is 6 degrees below  */
    /** the horizon.                                                         */
    class func civil_twilight(year: Int, month: Int, day: Int, lon: Double, lat: Double) -&gt; (trise: Double, tset: Double, code: ReturnCode) {
        let (start, end, code) = sunriset( year: year, month: month, day: day, lon: lon, lat: lat, altit: -6.0, upper_limb: 0)
        return (start, end, code)
    }

    /** This macro computes the start and end times of nautical twilight.    */
    /** Nautical twilight starts/ends when the Sun&#39;s center is 12 degrees    */
    /** below the horizon.                                                   */
    class func nautical_twilight(year: Int, month: Int ,day: Int, lon: Double, lat: Double) -&gt; (trise: Double, tset: Double, code: ReturnCode) {
        let (start, end, code) = sunriset( year: year, month: month, day: day, lon: lon, lat: lat, altit: -12.0, upper_limb: 0)
        return (start, end, code)
    }

    /** This macro computes the start and end times of astronomical twilight.   */
    /** Astronomical twilight starts/ends when the Sun&#39;s center is 18 degrees   */
    /** below the horizon.                                                      */
    class func astronomical_twilight(year: Int, month: Int, day: Int, lon: Double, lat: Double) -&gt; (trise: Double, tset: Double, code: ReturnCode) {
        let (start, end, code) = sunriset( year: year, month: month, day: day, lon: lon, lat: lat, altit: -18.0, upper_limb: 0)
        return (start, end, code)
    }

    /// The &#34;workhorse&#34; function for sun rise/set times
    ///
    /// - Parameters:
    ///   - year: calendar date, 1801-2099 only.
    ///   - month: calendar date, 1801-2099 only.
    ///   - day: calendar date, 1801-2099 only.
    ///   - lon: Eastern longitude positive, Western longitude negative. The longitude value IS critical in this function!
    ///   - lat: Northern latitude positive, Southern latitude negative
    ///   - altit: the altitude which the Sun should cross. Set to -35/60 degrees for rise/set, -6 degrees
    ///       for civil, -12 degrees for nautical and -18 degrees for astronomical twilight.
    ///   - upper_limb: non-zero -&gt; upper limb, zero -&gt; center
    ///       Set to non-zero (e.g. 1) when computing rise/set
    ///       times, and to zero when computing start/end of twilight.
    /// - Returns: rise, set, code.
    ///
    ///     Both times in hours UT are relative to the specified altitude,
    ///     and thus this function can be used to compute
    ///     various twilight times, as well as rise/set times.
    ///
    ///     Code 0 = sun rises/sets this day, times stored at rise and set.
    ///
    ///     Code &#43;1 = sun above the specified &#34;horizon&#34; 24 hours.
    ///     *trise set to time when the sun is at south,
    ///     minus 12 hours while *tset is set to the south
    ///     time plus 12 hours. &#34;Day&#34; length = 24 hours
    ///
    ///     Code -1 = sun is below the specified &#34;horizon&#34; 24 hours
    ///     &#34;Day&#34; length = 0 hours, *trise and *tset are
    ///     both set to the time when the sun is at south.
    private class func sunriset(year: Int,
                                month: Int,
                                day: Int,
                                lon: Double,
                                lat: Double,
                                altit: Double,
                                upper_limb: Int) -&gt; (trise: Double, tset: Double, code: ReturnCode) {

        var altit = altit
        var  d: Double         /* Days since 2000 Jan 0.0 (negative before) */
        var sr: Double         /* Solar distance, astronomical units */
        var sRA: Double        /* Sun&#39;s Right Ascension */
        var sdec: Double       /* Sun&#39;s declination */
        var sradius: Double    /* Sun&#39;s apparent radius */
        var t: Double          /* Diurnal arc */
        var tsouth: Double     /* Time when Sun is at south */
        var sidtime: Double    /* Local sidereal time */

        var rc: ReturnCode = ReturnCode.RiseAndSet     /* Return cde from function - usually 0 */

        /* Compute d of 12h local mean solar time */
        d = Double(days_since_2000_Jan_0(y: year,m: month,d: day)) &#43; 0.5 - lon/360.0;

        /* Compute the local sidereal time of this moment */
        sidtime = revolution( x: GMST0(d: d) &#43; 180.0 &#43; lon )

        /* Compute Sun&#39;s RA, Decl and distance at this moment */
        (sRA, sdec, sr) = sun_RA_dec(d: d)

        /* Compute time when Sun is at south - in hours UT */
        tsouth = 12.0 - rev180(x: sidtime - sRA)/15.0

        /* Compute the Sun&#39;s apparent radius in degrees */
        sradius = 0.2666 / sr

        /* Do correction to upper limb, if necessary */
        if upper_limb != 0 {
            altit -= sradius
        }

        /* Compute the diurnal arc that the Sun traverses to reach */
        /* the specified altitude altit: */
        do {
            let cost: Double = ( sind(x: altit) - sind(x: lat) * sind(x: sdec) ) / ( cosd(x: lat) * cosd(x: sdec) );
            if ( cost &gt;= 1.0 ) {
                rc = ReturnCode.SunAlwaysBelow
                t = 0.0       /* Sun always below altit */
            }
            else if ( cost &lt;= -1.0 ) {
                rc = ReturnCode.SunAlwaysAbove
                t = 12.0      /* Sun always above altit */
            }
            else {
                t = acosd(x: cost)/15.0   /* The diurnal arc, hours */
            }
        }

        /* Store rise and set times - in hours UT */
        let trise = tsouth - t;
        let tset  = tsouth &#43; t;

        return (trise, tset, rc)
    }  /* __sunriset__ */

    /// The &#34;workhorse&#34; function
    ///
    /// - Parameters:
    ///   - year: year,month,date = calendar date, 1801-2099 only.
    ///   - month: year,month,date = calendar date, 1801-2099 only.
    ///   - day: year,month,date = calendar date, 1801-2099 only.
    ///   - lon: Eastern longitude positive, Western longitude negative
    ///   - lat: Northern latitude positive, Southern latitude negative
    ///   - altit: altit = the altitude which the Sun should cross
    ///               Set to -35/60 degrees for rise/set, -6 degrees
    ///               for civil, -12 degrees for nautical and -18
    ///               degrees for astronomical twilight.
    ///   - upper_limb: upper_limb: non-zero -&gt; upper limb, zero -&gt; center
    ///               Set to non-zero (e.g. 1) when computing day length
    ///               and to zero when computing day&#43;twilight length.
    /// - Returns: Day number
    private class func daylen(year: Int, month: Int, day: Int, lon: Double, lat: Double,
                              altit: Double, upper_limb: Int ) -&gt; Double {
        /**********************************************************************/
        /* Note: year,month,date = calendar date, 1801-2099 only.             */
        /*       Eastern longitude positive, Western longitude negative       */
        /*       Northern latitude positive, Southern latitude negative       */
        /*       The longitude value is not critical. Set it to the correct   */
        /*       longitude if you&#39;re picky, otherwise set to to, say, 0.0     */
        /*       The latitude however IS critical - be sure to get it correct */
        /*       altit = the altitude which the Sun should cross              */
        /*               Set to -35/60 degrees for rise/set, -6 degrees       */
        /*               for civil, -12 degrees for nautical and -18          */
        /*               degrees for astronomical twilight.                   */
        /*         upper_limb: non-zero -&gt; upper limb, zero -&gt; center         */
        /*               Set to non-zero (e.g. 1) when computing day length   */
        /*               and to zero when computing day&#43;twilight length.      */
        /**********************************************************************/

        var altit = altit
        var d: Double          /* Days since 2000 Jan 0.0 (negative before) */
        var obl_ecl: Double    /* Obliquity (inclination) of Earth&#39;s axis */
        var sr: Double         /* Solar distance, astronomical units */
        var slon: Double       /* True solar longitude */
        var sin_sdecl: Double  /* Sine of Sun&#39;s declination */
        var cos_sdecl: Double  /* Cosine of Sun&#39;s declination */
        var sradius: Double    /* Sun&#39;s apparent radius */
        var t: Double          /* Diurnal arc */

        /* Compute d of 12h local mean solar time */
        d = Double(days_since_2000_Jan_0(y: year, m: month, d: day)) &#43; 0.5 - lon/360.0;

        /* Compute obliquity of ecliptic (inclination of Earth&#39;s axis) */
        obl_ecl = 23.4393 - 3.563E-7 * d;

        /* Compute Sun&#39;s ecliptic longitude and distance */
        (slon, sr) = sunpos( d: d )

        /* Compute sine and cosine of Sun&#39;s declination */
        sin_sdecl = sind(x: obl_ecl) * sind(x: slon);
        cos_sdecl = sqrt( 1.0 - sin_sdecl * sin_sdecl );

        /* Compute the Sun&#39;s apparent radius, degrees */
        sradius = 0.2666 / sr;

        /* Do correction to upper limb, if necessary */
        if upper_limb != 0 {
            altit -= sradius
        }

        /* Compute the diurnal arc that the Sun traverses to reach */
        /* the specified altitude altit: */
        do {
            let cost: Double = ( sind(x: altit) - sind(x: lat) * sin_sdecl ) / ( cosd(x: lat) * cos_sdecl );
            if cost &gt;= 1.0 {
                t = 0.0     /* Sun always below altit */
            }
            else if cost &lt;= -1.0 {
                t = 24.0;                     /* Sun always above altit */
            }
            else  {
                t = (2.0/15.0) * acosd(x: cost); /* The diurnal arc, hours */
            }
        }

        return t;
    }  /* __daylen__ */


    /// This function computes the Sun&#39;s position at any instant.
    private class func sunpos(d: Double) -&gt; (lon: Double, r: Double ) {
        /******************************************************/
        /* Computes the Sun&#39;s ecliptic longitude and distance */
        /* at an instant given in d, number of days since     */
        /* 2000 Jan 0.0.  The Sun&#39;s ecliptic latitude is not  */
        /* computed, since it&#39;s always very near 0.           */
        /******************************************************/

        var M: Double         /* Mean anomaly of the Sun */
        var w: Double         /* Mean longitude of perihelion */
                              /* Note: Sun&#39;s mean longitude = M &#43; w */
        var e: Double         /* Eccentricity of Earth&#39;s orbit */
        var E: Double         /* Eccentric anomaly */
        var x: Double
        var y: Double         /* x, y coordinates in orbit */
        var v: Double         /* True anomaly */

        /* Compute mean elements */
        M = revolution( x: 356.0470 &#43; 0.9856002585 * d );
        w = 282.9404 &#43; 4.70935E-5 * d;
        e = 0.016709 - 1.151E-9 * d;

        /* Compute true longitude and radius vector */
        E = M &#43; e * RADEG * sind(x: M) * ( 1.0 &#43; e * cosd(x: M) );
        x = cosd(x: E) - e;
        y = sqrt( 1.0 - e*e ) * sind(x: E);
        let r = sqrt( x*x &#43; y*y );              /* Solar distance */
        v = atan2d( y: y, x: x );               /* True anomaly */
        var lon = v &#43; w                         /* True solar longitude */
        if lon &gt;= 360.0 {
            lon -= 360.0                        /* Make it 0..360 degrees */
        }
        return (lon, r)
    }

    private class func sun_RA_dec( d: Double ) -&gt; (RA: Double, dec: Double, r: Double ) {
        /******************************************************/
        /* Computes the Sun&#39;s equatorial coordinates RA, Decl */
        /* and also its distance, at an instant given in d,   */
        /* the number of days since 2000 Jan 0.0.             */
        /******************************************************/

        var obl_ecl: Double
        var x: Double
        var y: Double
        var z: Double

        /* Compute Sun&#39;s ecliptical coordinates */
        let (lon, r) = sunpos( d: d )

        /* Compute ecliptic rectangular coordinates (z=0) */
        x = r * cosd(x: lon)
        y = r * sind(x: lon)

        /* Compute obliquity of ecliptic (inclination of Earth&#39;s axis) */
        obl_ecl = 23.4393 - 3.563E-7 * d

        /* Convert to equatorial rectangular coordinates - x is unchanged */
        z = y * sind(x: obl_ecl)
        y = y * cosd(x: obl_ecl)

        /* Convert to spherical coordinates */
        let RA = atan2d( y: y, x: x )
        let dec = atan2d( y: z, x: sqrt(x*x &#43; y*y) )
        return (RA, dec, r)
    }  /* sun_RA_dec */

    private static let INV360: Double = ( 1.0 / 360.0 )

    /*******************************************************************/
    /** This function reduces any angle to within the first revolution */
    /** by subtracting or adding even multiples of 360.0 until the     */
    /** result is &gt;= 0.0 and &lt; 360.0                                   */
    /*******************************************************************/
    private class func revolution( x: Double ) -&gt; Double {
        /*****************************************/
        /* Reduce angle to within 0..360 degrees */
        /*****************************************/

        return( x - 360.0 * floor( x * INV360 ) );
    }  /* revolution */

    private class func rev180(x: Double ) -&gt; Double {
        /*********************************************/
        /* Reduce angle to within &#43;180..&#43;180 degrees */
        /*********************************************/

        return( x - 360.0 * floor( x * INV360 &#43; 0.5 ) );
    }  /* revolution */

    /********************************************************************/
    /** This function computes GMST0, the Greenwich Mean Sidereal Time  */
    /** at 0h UT (i.e. the sidereal time at the Greenwhich meridian at  */
    /** 0h UT).  GMST is then the sidereal time at Greenwich at any     */
    /** time of the day.  I&#39;ve generalized GMST0 as well, and define it */
    /** as:  GMST0 = GMST - UT  --  this allows GMST0 to be computed at */
    /** other times than 0h UT as well.  While this sounds somewhat     */
    /** contradictory, it is very practical:  instead of computing      */
    /** GMST like:                                                      */
    /**                                                                 */
    /**  GMST = (GMST0) &#43; UT * (366.2422/365.2422)                      */
    /**                                                                 */
    /** where (GMST0) is the GMST last time UT was 0 hours, one simply  */
    /** computes:                                                       */
    /**                                                                 */
    /**  GMST = GMST0 &#43; UT                                              */
    /**                                                                 */
    /** where GMST0 is the GMST &#34;at 0h UT&#34; but at the current moment!   */
    /** Defined in this way, GMST0 will increase with about 4 min a     */
    /** day.  It also happens that GMST0 (in degrees, 1 hr = 15 degr)   */
    /** is equal to the Sun&#39;s mean longitude plus/minus 180 degrees!    */
    /** (if we neglect aberration, which amounts to 20 seconds of arc   */
    /** or 1.33 seconds of time)                                        */
    /**                                                                 */
    /********************************************************************/
    private class func GMST0( d: Double ) -&gt; Double {
        var sidtim0: Double
        /* Sidtime at 0h UT = L (Sun&#39;s mean longitude) &#43; 180.0 degr  */
        /* L = M &#43; w, as defined in sunpos().  Since I&#39;m too lazy to */
        /* add these numbers, I&#39;ll let the C compiler do it for me.  */
        /* Any decent C compiler will add the constants at compile   */
        /* time, imposing no runtime or code overhead.               */
        sidtim0 = revolution( x: ( 180.0 &#43; 356.0470 &#43; 282.9404 ) &#43;
            ( 0.9856002585 &#43; 4.70935E-5 ) * d )
        return sidtim0
    }  /* GMST0 */

}</code></pre>
				</div>
			</div>
		</div>
	

		<footer class='container mx-auto text-white text-lg opacity-75 mt-8'>
			<div class='text-center p-16'>
				<p>
					<div>
						<a target='github' class='underline hover:text-white' href='https://github.com/matryer/xbar'>GitHub project</a>
						â€¢
						<a target='github' class='underline hover:text-white' href='https://github.com/matryer/xbar#writing-plugins'>Writing plugins guide</a>
					</div>
					<div class='mt-8'>
						Copyright &copy;2021 Mat Ryer + contributors â€¢ <a target='twitter' class='underline hover:text-white' href='https://twitter.com/matryer'>@matryer</a>
					</div>
					<div class='opacity-50 mt-2'>
						Last updated on 08 Mar 21 15:22 GMT
					</div>
				</p>
			</div>
		</footer>
	</body>
</html>
