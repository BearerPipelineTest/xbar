{
	"plugin": {
		"files": [
			{
				"path": "Time/sunrise.4h.swift",
				"filename": "sunrise.4h.swift",
				"content": "#!/usr/bin/env xcrun swift\n\n/*\n * \u003cbitbar.title\u003eSunrise\u003c/bitbar.title\u003e\n * \u003cbitbar.version\u003ev1.1.1\u003c/bitbar.version\u003e\n * \u003cbitbar.author\u003eBrad Greenlee\u003c/bitbar.author\u003e\n * \u003cbitbar.author.github\u003ebgreenlee\u003c/bitbar.author.github\u003e\n * \u003cbitbar.desc\u003eDisplays sunrise, sunset, and day length for a location.\u003c/bitbar.desc\u003e\n * \u003cbitbar.image\u003ehttps://raw.githubusercontent.com/bgreenlee/SunriseBitBar/main/sunrise-bitbar.png\u003c/bitbar.image\u003e\n * \u003cbitbar.dependencies\u003eXcode,swift\u003c/bitbar.dependencies\u003e\n * \u003cbitbar.abouturl\u003ehttps://github.com/bgreenlee/SunriseBitBar\u003c/bitbar.abouturl\u003e\n */\n\n// Customizations\n\nlet LOCATION = \"Seattle, WA\" // or lat,lon coordinates\nlet DAYS = 7 // number of days to show\nlet PAST_DAYS = 0 // number of days in the past to show\nlet TIME_STYLE:DateFormatter.Style = .short // .short, .medium, .long, .full\nlet LOCATION_FONT = \"Menlo\"\nlet LOCATION_COLOR = \"black\"\nlet SUNRISE_FONT = \"Menlo\"\nlet SUNRISE_COLOR = \"blue\"\nlet SYMBOL_COLOR = \"orange\"\n\n// Main code\n\nlet coordinate = try parseLocation(LOCATION)\n// Reverse geocode so we can get the timezone in the location\nlet coder = CLGeocoder()\nlet loc = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)\nvar placemark: CLPlacemark?\nvar timezone: TimeZone?\ncoder.reverseGeocodeLocation(loc) { (placemarks, error) in\n    placemark = placemarks?.last\n    timezone = placemark?.timeZone\n    CFRunLoopStop(CFRunLoopGetCurrent())\n}\nCFRunLoopRun() // wait for reverse geocode to finish\n\nprint(\":sunrise:\\n---\\n\")\n\nif let placemark = placemark {\n    if let city = placemark.locality, let administrativeArea = placemark.administrativeArea, let country = placemark.country {\n        if country == \"United States\" {\n            print(\"\\(city), \\(administrativeArea)|font=\\(LOCATION_FONT) color=\\(LOCATION_COLOR)\")\n        } else {\n            print(\"\\(city), \\(administrativeArea), \\(country)|font=\\(LOCATION_FONT) color=\\(LOCATION_COLOR)\")\n        }\n    } else {\n        print(\"\\(placemark.name ?? \"Unknown\")\")\n    }\n}\n\nlet today = Date()\nfor i in -PAST_DAYS..\u003cDAYS-PAST_DAYS {\n    let date = Calendar.current.date(byAdding: .day, value: i, to: today)!\n    if let (sunrise, sunset) = NTSolar.sunRiseAndSet(forDate: date, atLocation: coordinate, inTimeZone: timezone!) {\n        let dateFormatter = DateFormatter()\n        dateFormatter.setLocalizedDateFormatFromTemplate(\"MMMd\")\n        print(dateFormatter.string(from: date).padding(toLength: 7, withPad: \" \", startingAt: 0), terminator:\"\")\n\n        let timeFormatter = DateFormatter()\n        timeFormatter.dateStyle = .none\n        timeFormatter.timeStyle = TIME_STYLE\n        if let timezone = timezone {\n            timeFormatter.timeZone = timezone\n        }\n\n        let sunriseTime = timeFormatter.string(from: sunrise).lowercased()\n        let sunsetTime = timeFormatter.string(from: sunset).lowercased()\n        let daylengthFormatter = DateComponentsFormatter()\n        daylengthFormatter.unitsStyle = .abbreviated\n        daylengthFormatter.allowedUnits = [.minute, .hour]\n        let formattedDayLength = daylengthFormatter.string(from: sunrise, to: sunset)!\n\n        print(\":sunrise: \\(sunriseTime) :sunset: \\(sunsetTime) :clock: \\(formattedDayLength)|font=\\(SUNRISE_FONT)\\(i == 0 ? \"-Bold\" : \"\") color=\\(SUNRISE_COLOR) sfcolor=\\(SYMBOL_COLOR)\")\n    }\n}\n\nstruct ValidationError: Error, CustomStringConvertible {\n    var description:String\n\n    init(_ description:String) {\n        self.description = description\n    }\n}\n\nfunc parseLocation(_ argument: String) throws -\u003e CLLocationCoordinate2D {\n    let parts = argument.components(separatedBy: \",\")\n    if parts.count == 2, let latitude = Double(parts[0]), let longitude = Double(parts[1]) {\n        return CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n    } else {\n        // see if we can geocode it\n        let coder = CLGeocoder()\n        var location: CLLocation?\n        coder.geocodeAddressString(argument) { (placemarks, error) in\n            location = placemarks?.last?.location\n            CFRunLoopStop(CFRunLoopGetCurrent())\n        }\n        CFRunLoopRun()\n        if let location = location {\n            return location.coordinate\n        }\n        throw ValidationError(\"Could not parse location. Provide either a valid place name or latitude,longitude.\")\n    }\n}\n\n//\n//\n//    NTSolar.swift\n//\n//  Created by Neil Tiffin on 5/8/19.\n//  Copyright © 2019 Performance Champions, Inc.\n//  Copyright © 2019 Neil Tiffin.\n//\n//  Released to the public domain by Neil Tiffin, May 2019\n//  Released to the public domain by Performance Champions, Inc., May 2019\n//\n\nimport Foundation\nimport CoreLocation\n\nvar stderr = FileHandle.standardError\n\nextension FileHandle : TextOutputStream {\n  public func write(_ string: String) {\n    guard let data = string.data(using: .utf8) else { return }\n    self.write(data)\n  }\n}\n\n/// Class to calculate sunrise sunset.\n///\n/// C code originally from: [http://stjarnhimlen.se/comp/sunriset.c](http://stjarnhimlen.se/comp/sunriset.c)\nclass NTSolar {\n    // MARK: - Public Swift Interface\n\n    /// Calculate the sun rise and set times.\n    ///\n    /// - Parameters:\n    ///   - forDate: The date for the calculation. You should ensure that the date, which is stored as UTC, is the date\n    ///         really wanted in the given time zone. It will be converted to the given time zone before being used.\n    ///   - atLocation: The latitude and longitude for the calculation.\n    ///   - inTimeZone: The time zone for the resulting date and times.\n    /// - Returns: If the sun both rises and sets on the day requested and at the\n    ///     latitude requested then return sun rise and set times rounded down to the minute, nil othewise.\n    class func sunRiseAndSet(forDate: Date,\n                             atLocation: CLLocationCoordinate2D,\n                             inTimeZone: TimeZone) -\u003e (sunrise: Date, sunset: Date)? {\n\n        var calendar = Calendar(identifier: .gregorian)\n        calendar.timeZone = inTimeZone\n        var comp = calendar.dateComponents([.day, .year, .month], from: forDate)\n        comp.calendar = calendar\n\n        guard let year = comp.year,\n            let month = comp.month,\n            let day = comp.day else {\n                print(\"Failed to find date components.\", to:\u0026stderr)\n                return nil\n        }\n\n        let (riseUTC, setUTC, code) = NTSolar.sun_rise_set(year: year,\n                                                           month: month,\n                                                           day: day,\n                                                           lon: atLocation.longitude,\n                                                           lat: atLocation.latitude)\n\n        if code != .RiseAndSet {\n            print(\"Failed to find rise and set.\", to:\u0026stderr)\n            return nil\n        }\n\n        // Calc sunrise\n        var riseLocalHrs = riseUTC + (Double(inTimeZone.secondsFromGMT()) / 3600.0)\n        if riseLocalHrs \u003e 24.0 {\n            riseLocalHrs -= 24.0\n        }\n        let riseHoursInt = Int(riseLocalHrs)\n        comp.hour = riseHoursInt\n\n        comp.minute = Int(  (( riseLocalHrs - Double(riseHoursInt) ) * 60.0).rounded() )\n        comp.second = 0\n        comp.nanosecond = 0\n        guard let riseTime = comp.date else {\n            print(\"\\nFailed to calculate rise time hrs: \\(riseLocalHrs).\\n\\(comp)\\n\", to:\u0026stderr)\n            return nil\n        }\n\n        // Calc sunset\n        var setLocalHrs = setUTC + (Double(inTimeZone.secondsFromGMT()) / 3600.0)\n        if setLocalHrs \u003e 24.0 {\n            setLocalHrs -= 24.0\n        }\n        let setHoursInt = Int(setLocalHrs)\n        comp.hour = setHoursInt\n        comp.minute = Int( ((setLocalHrs - Double(setHoursInt) ) * 60.0).rounded() )\n        comp.second = 0\n        comp.nanosecond = 0\n        guard let setTime = comp.date else {\n            print(\"\\nFailed to calculate set time hrs: \\(setLocalHrs).\\n\\(comp)\\n\", to:\u0026stderr)\n            return nil\n        }\n\n        return (riseTime, setTime)\n    }\n\n    // MARK: - SUNRISET.C\n\n    // C code originally from: [http://stjarnhimlen.se/comp/sunriset.c](http://stjarnhimlen.se/comp/sunriset.c)\n    //\n    // The conversion process removed pointers in favor of return tuples, converted macros to function calls,\n    // added return code enum, and converted\n    // comments to work with Xcode.  Of course the C code had to be converted to Swift, but that was minimal.\n    //\n    // As much as possible the original code was left intact in order to not introduce bugs.\n    // In other words, some code was left unfashionable by today's standards.\n\n    enum ReturnCode: Int {\n        /// Sun is below the specified \"horizon\" 24 hours\n        /// \"Day\" length = 0 hours, trise and tset are\n        /// both set to the time when the sun is at south.\n        case SunAlwaysBelow = -1\n\n        /// Sun rises/sets this day, times stored at rise and set.\n        case RiseAndSet = 0\n\n        /// Sun above the specified \"horizon\" 24 hours.\n        /// trise set to time when the sun is at south,\n        /// minus 12 hours while tset is set to the south\n        /// time plus 12 hours. \"Day\" length = 24 hours\n        case SunAlwaysAbove = 1\n    }\n\n    /* +++Date last modified: 05-Jul-1997 */\n    /* Updated comments, 05-Aug-2013 */\n    /*\n     SUNRISET.C - computes Sun rise/set times, start/end of twilight, and\n     the length of the day at any date and latitude\n\n     Written as DAYLEN.C, 1989-08-16\n\n     Modified to SUNRISET.C, 1992-12-01\n\n     (c) Paul Schlyter, 1989, 1992\n\n     Released to the public domain by Paul Schlyter, December 1992\n     */\n\n    /// A macro to compute the number of days elapsed since 2000 Jan 0.0\n    /// (which is equal to 1999 Dec 31, 0h UT)\n    private class func days_since_2000_Jan_0(y:Int, m:Int, d:Int) -\u003e Int {\n        return (367*(y)-((7*((y)+(((m)+9)/12)))/4)+((275*(m))/9)+(d)-730530)\n    }\n\n    /* Some conversion factors between radians and degrees */\n    private static let PI  =      3.1415926535897932384\n    private static let RADEG   =  ( 180.0 / PI )\n    private static let DEGRAD  =  ( PI / 180.0 )\n\n    /* The trigonometric functions in degrees */\n    private class func sind(x: Double) -\u003e Double  { return sin((x)*DEGRAD) }\n    private class func cosd(x: Double) -\u003e Double  { return  cos((x)*DEGRAD) }\n    private class func tand(x: Double) -\u003e Double  { return  tan((x)*DEGRAD) }\n    private class func atand(x: Double)  -\u003e Double  { return   (RADEG*atan(x)) }\n    private class func asind(x: Double)  -\u003e Double  { return   (RADEG*asin(x)) }\n    private class func acosd(x: Double)  -\u003e Double  { return   (RADEG*acos(x)) }\n    private class func atan2d(y: Double,x: Double)-\u003e Double  { return  (RADEG*atan2(y,x)) }\n\n    /* Following are some macros around the \"workhorse\" function __daylen__ */\n    /* They mainly fill in the desired values for the reference altitude    */\n    /* below the horizon, and also selects whether this altitude should     */\n    /* refer to the Sun's center or its upper limb.                         */\n\n\n    /** This macro computes the length of the day, from sunrise to sunset. */\n    /** Sunrise/set is considered to occur when the Sun's upper limb is    */\n    /** 35 arc minutes below the horizon (this accounts for the refraction */\n    /** of the Earth's atmosphere).                                        */\n    class func day_length(year: Int, month: Int, day: Int, lon: Double, lat: Double) -\u003e Double {\n        return daylen( year: year, month: month, day: day, lon: lon, lat: lat, altit: -35.0/60.0, upper_limb: 1 )\n    }\n\n    /** This macro computes the length of the day, including civil twilight. */\n    /** Civil twilight starts/ends when the Sun's center is 6 degrees below  */\n    /** the horizon.                                                         */\n    class func day_civil_twilight_length(year: Int, month: Int, day: Int, lon: Double, lat: Double) -\u003e Double {\n        return daylen( year: year, month: month, day: day, lon: lon, lat: lat, altit: -6.0, upper_limb: 0 )\n    }\n\n    /** This macro computes the length of the day, incl. nautical twilight.  */\n    /** Nautical twilight starts/ends when the Sun's center is 12 degrees    */\n    /** below the horizon.                                                   */\n    class func day_nautical_twilight_length(year: Int, month: Int, day: Int, lon: Double, lat: Double) -\u003e Double {\n        return daylen( year: year, month: month, day: day, lon: lon, lat: lat, altit: -12.0, upper_limb: 0 )\n    }\n\n    /** This macro computes the length of the day, incl. astronomical twilight. */\n    /** Astronomical twilight starts/ends when the Sun's center is 18 degrees   */\n    /** below the horizon.                                                      */\n    class func day_astronomical_twilight_length(year: Int, month: Int, day: Int, lon: Double, lat: Double) -\u003e Double {\n        return daylen( year: year, month: month, day: day, lon: lon, lat: lat, altit: -18.0, upper_limb: 0 )\n    }\n\n    /** This macro computes times for sunrise/sunset.                      */\n    /** Sunrise/set is considered to occur when the Sun's upper limb is    */\n    /** 35 arc minutes below the horizon (this accounts for the refraction */\n    /** of the Earth's atmosphere).                                        */\n    class func sun_rise_set(year: Int, month: Int, day: Int , lon: Double, lat: Double) -\u003e (trise: Double, tset: Double, code: ReturnCode) {\n        let (start, end, code) = sunriset( year: year, month: month, day: day, lon: lon, lat: lat, altit: -35.0/60.0, upper_limb: 1)\n        return (start, end, code)\n    }\n\n    /** This macro computes the start and end times of civil twilight.       */\n    /** Civil twilight starts/ends when the Sun's center is 6 degrees below  */\n    /** the horizon.                                                         */\n    class func civil_twilight(year: Int, month: Int, day: Int, lon: Double, lat: Double) -\u003e (trise: Double, tset: Double, code: ReturnCode) {\n        let (start, end, code) = sunriset( year: year, month: month, day: day, lon: lon, lat: lat, altit: -6.0, upper_limb: 0)\n        return (start, end, code)\n    }\n\n    /** This macro computes the start and end times of nautical twilight.    */\n    /** Nautical twilight starts/ends when the Sun's center is 12 degrees    */\n    /** below the horizon.                                                   */\n    class func nautical_twilight(year: Int, month: Int ,day: Int, lon: Double, lat: Double) -\u003e (trise: Double, tset: Double, code: ReturnCode) {\n        let (start, end, code) = sunriset( year: year, month: month, day: day, lon: lon, lat: lat, altit: -12.0, upper_limb: 0)\n        return (start, end, code)\n    }\n\n    /** This macro computes the start and end times of astronomical twilight.   */\n    /** Astronomical twilight starts/ends when the Sun's center is 18 degrees   */\n    /** below the horizon.                                                      */\n    class func astronomical_twilight(year: Int, month: Int, day: Int, lon: Double, lat: Double) -\u003e (trise: Double, tset: Double, code: ReturnCode) {\n        let (start, end, code) = sunriset( year: year, month: month, day: day, lon: lon, lat: lat, altit: -18.0, upper_limb: 0)\n        return (start, end, code)\n    }\n\n    /// The \"workhorse\" function for sun rise/set times\n    ///\n    /// - Parameters:\n    ///   - year: calendar date, 1801-2099 only.\n    ///   - month: calendar date, 1801-2099 only.\n    ///   - day: calendar date, 1801-2099 only.\n    ///   - lon: Eastern longitude positive, Western longitude negative. The longitude value IS critical in this function!\n    ///   - lat: Northern latitude positive, Southern latitude negative\n    ///   - altit: the altitude which the Sun should cross. Set to -35/60 degrees for rise/set, -6 degrees\n    ///       for civil, -12 degrees for nautical and -18 degrees for astronomical twilight.\n    ///   - upper_limb: non-zero -\u003e upper limb, zero -\u003e center\n    ///       Set to non-zero (e.g. 1) when computing rise/set\n    ///       times, and to zero when computing start/end of twilight.\n    /// - Returns: rise, set, code.\n    ///\n    ///     Both times in hours UT are relative to the specified altitude,\n    ///     and thus this function can be used to compute\n    ///     various twilight times, as well as rise/set times.\n    ///\n    ///     Code 0 = sun rises/sets this day, times stored at rise and set.\n    ///\n    ///     Code +1 = sun above the specified \"horizon\" 24 hours.\n    ///     *trise set to time when the sun is at south,\n    ///     minus 12 hours while *tset is set to the south\n    ///     time plus 12 hours. \"Day\" length = 24 hours\n    ///\n    ///     Code -1 = sun is below the specified \"horizon\" 24 hours\n    ///     \"Day\" length = 0 hours, *trise and *tset are\n    ///     both set to the time when the sun is at south.\n    private class func sunriset(year: Int,\n                                month: Int,\n                                day: Int,\n                                lon: Double,\n                                lat: Double,\n                                altit: Double,\n                                upper_limb: Int) -\u003e (trise: Double, tset: Double, code: ReturnCode) {\n\n        var altit = altit\n        var  d: Double         /* Days since 2000 Jan 0.0 (negative before) */\n        var sr: Double         /* Solar distance, astronomical units */\n        var sRA: Double        /* Sun's Right Ascension */\n        var sdec: Double       /* Sun's declination */\n        var sradius: Double    /* Sun's apparent radius */\n        var t: Double          /* Diurnal arc */\n        var tsouth: Double     /* Time when Sun is at south */\n        var sidtime: Double    /* Local sidereal time */\n\n        var rc: ReturnCode = ReturnCode.RiseAndSet     /* Return cde from function - usually 0 */\n\n        /* Compute d of 12h local mean solar time */\n        d = Double(days_since_2000_Jan_0(y: year,m: month,d: day)) + 0.5 - lon/360.0;\n\n        /* Compute the local sidereal time of this moment */\n        sidtime = revolution( x: GMST0(d: d) + 180.0 + lon )\n\n        /* Compute Sun's RA, Decl and distance at this moment */\n        (sRA, sdec, sr) = sun_RA_dec(d: d)\n\n        /* Compute time when Sun is at south - in hours UT */\n        tsouth = 12.0 - rev180(x: sidtime - sRA)/15.0\n\n        /* Compute the Sun's apparent radius in degrees */\n        sradius = 0.2666 / sr\n\n        /* Do correction to upper limb, if necessary */\n        if upper_limb != 0 {\n            altit -= sradius\n        }\n\n        /* Compute the diurnal arc that the Sun traverses to reach */\n        /* the specified altitude altit: */\n        do {\n            let cost: Double = ( sind(x: altit) - sind(x: lat) * sind(x: sdec) ) / ( cosd(x: lat) * cosd(x: sdec) );\n            if ( cost \u003e= 1.0 ) {\n                rc = ReturnCode.SunAlwaysBelow\n                t = 0.0       /* Sun always below altit */\n            }\n            else if ( cost \u003c= -1.0 ) {\n                rc = ReturnCode.SunAlwaysAbove\n                t = 12.0      /* Sun always above altit */\n            }\n            else {\n                t = acosd(x: cost)/15.0   /* The diurnal arc, hours */\n            }\n        }\n\n        /* Store rise and set times - in hours UT */\n        let trise = tsouth - t;\n        let tset  = tsouth + t;\n\n        return (trise, tset, rc)\n    }  /* __sunriset__ */\n\n    /// The \"workhorse\" function\n    ///\n    /// - Parameters:\n    ///   - year: year,month,date = calendar date, 1801-2099 only.\n    ///   - month: year,month,date = calendar date, 1801-2099 only.\n    ///   - day: year,month,date = calendar date, 1801-2099 only.\n    ///   - lon: Eastern longitude positive, Western longitude negative\n    ///   - lat: Northern latitude positive, Southern latitude negative\n    ///   - altit: altit = the altitude which the Sun should cross\n    ///               Set to -35/60 degrees for rise/set, -6 degrees\n    ///               for civil, -12 degrees for nautical and -18\n    ///               degrees for astronomical twilight.\n    ///   - upper_limb: upper_limb: non-zero -\u003e upper limb, zero -\u003e center\n    ///               Set to non-zero (e.g. 1) when computing day length\n    ///               and to zero when computing day+twilight length.\n    /// - Returns: Day number\n    private class func daylen(year: Int, month: Int, day: Int, lon: Double, lat: Double,\n                              altit: Double, upper_limb: Int ) -\u003e Double {\n        /**********************************************************************/\n        /* Note: year,month,date = calendar date, 1801-2099 only.             */\n        /*       Eastern longitude positive, Western longitude negative       */\n        /*       Northern latitude positive, Southern latitude negative       */\n        /*       The longitude value is not critical. Set it to the correct   */\n        /*       longitude if you're picky, otherwise set to to, say, 0.0     */\n        /*       The latitude however IS critical - be sure to get it correct */\n        /*       altit = the altitude which the Sun should cross              */\n        /*               Set to -35/60 degrees for rise/set, -6 degrees       */\n        /*               for civil, -12 degrees for nautical and -18          */\n        /*               degrees for astronomical twilight.                   */\n        /*         upper_limb: non-zero -\u003e upper limb, zero -\u003e center         */\n        /*               Set to non-zero (e.g. 1) when computing day length   */\n        /*               and to zero when computing day+twilight length.      */\n        /**********************************************************************/\n\n        var altit = altit\n        var d: Double          /* Days since 2000 Jan 0.0 (negative before) */\n        var obl_ecl: Double    /* Obliquity (inclination) of Earth's axis */\n        var sr: Double         /* Solar distance, astronomical units */\n        var slon: Double       /* True solar longitude */\n        var sin_sdecl: Double  /* Sine of Sun's declination */\n        var cos_sdecl: Double  /* Cosine of Sun's declination */\n        var sradius: Double    /* Sun's apparent radius */\n        var t: Double          /* Diurnal arc */\n\n        /* Compute d of 12h local mean solar time */\n        d = Double(days_since_2000_Jan_0(y: year, m: month, d: day)) + 0.5 - lon/360.0;\n\n        /* Compute obliquity of ecliptic (inclination of Earth's axis) */\n        obl_ecl = 23.4393 - 3.563E-7 * d;\n\n        /* Compute Sun's ecliptic longitude and distance */\n        (slon, sr) = sunpos( d: d )\n\n        /* Compute sine and cosine of Sun's declination */\n        sin_sdecl = sind(x: obl_ecl) * sind(x: slon);\n        cos_sdecl = sqrt( 1.0 - sin_sdecl * sin_sdecl );\n\n        /* Compute the Sun's apparent radius, degrees */\n        sradius = 0.2666 / sr;\n\n        /* Do correction to upper limb, if necessary */\n        if upper_limb != 0 {\n            altit -= sradius\n        }\n\n        /* Compute the diurnal arc that the Sun traverses to reach */\n        /* the specified altitude altit: */\n        do {\n            let cost: Double = ( sind(x: altit) - sind(x: lat) * sin_sdecl ) / ( cosd(x: lat) * cos_sdecl );\n            if cost \u003e= 1.0 {\n                t = 0.0     /* Sun always below altit */\n            }\n            else if cost \u003c= -1.0 {\n                t = 24.0;                     /* Sun always above altit */\n            }\n            else  {\n                t = (2.0/15.0) * acosd(x: cost); /* The diurnal arc, hours */\n            }\n        }\n\n        return t;\n    }  /* __daylen__ */\n\n\n    /// This function computes the Sun's position at any instant.\n    private class func sunpos(d: Double) -\u003e (lon: Double, r: Double ) {\n        /******************************************************/\n        /* Computes the Sun's ecliptic longitude and distance */\n        /* at an instant given in d, number of days since     */\n        /* 2000 Jan 0.0.  The Sun's ecliptic latitude is not  */\n        /* computed, since it's always very near 0.           */\n        /******************************************************/\n\n        var M: Double         /* Mean anomaly of the Sun */\n        var w: Double         /* Mean longitude of perihelion */\n                              /* Note: Sun's mean longitude = M + w */\n        var e: Double         /* Eccentricity of Earth's orbit */\n        var E: Double         /* Eccentric anomaly */\n        var x: Double\n        var y: Double         /* x, y coordinates in orbit */\n        var v: Double         /* True anomaly */\n\n        /* Compute mean elements */\n        M = revolution( x: 356.0470 + 0.9856002585 * d );\n        w = 282.9404 + 4.70935E-5 * d;\n        e = 0.016709 - 1.151E-9 * d;\n\n        /* Compute true longitude and radius vector */\n        E = M + e * RADEG * sind(x: M) * ( 1.0 + e * cosd(x: M) );\n        x = cosd(x: E) - e;\n        y = sqrt( 1.0 - e*e ) * sind(x: E);\n        let r = sqrt( x*x + y*y );              /* Solar distance */\n        v = atan2d( y: y, x: x );               /* True anomaly */\n        var lon = v + w                         /* True solar longitude */\n        if lon \u003e= 360.0 {\n            lon -= 360.0                        /* Make it 0..360 degrees */\n        }\n        return (lon, r)\n    }\n\n    private class func sun_RA_dec( d: Double ) -\u003e (RA: Double, dec: Double, r: Double ) {\n        /******************************************************/\n        /* Computes the Sun's equatorial coordinates RA, Decl */\n        /* and also its distance, at an instant given in d,   */\n        /* the number of days since 2000 Jan 0.0.             */\n        /******************************************************/\n\n        var obl_ecl: Double\n        var x: Double\n        var y: Double\n        var z: Double\n\n        /* Compute Sun's ecliptical coordinates */\n        let (lon, r) = sunpos( d: d )\n\n        /* Compute ecliptic rectangular coordinates (z=0) */\n        x = r * cosd(x: lon)\n        y = r * sind(x: lon)\n\n        /* Compute obliquity of ecliptic (inclination of Earth's axis) */\n        obl_ecl = 23.4393 - 3.563E-7 * d\n\n        /* Convert to equatorial rectangular coordinates - x is unchanged */\n        z = y * sind(x: obl_ecl)\n        y = y * cosd(x: obl_ecl)\n\n        /* Convert to spherical coordinates */\n        let RA = atan2d( y: y, x: x )\n        let dec = atan2d( y: z, x: sqrt(x*x + y*y) )\n        return (RA, dec, r)\n    }  /* sun_RA_dec */\n\n    private static let INV360: Double = ( 1.0 / 360.0 )\n\n    /*******************************************************************/\n    /** This function reduces any angle to within the first revolution */\n    /** by subtracting or adding even multiples of 360.0 until the     */\n    /** result is \u003e= 0.0 and \u003c 360.0                                   */\n    /*******************************************************************/\n    private class func revolution( x: Double ) -\u003e Double {\n        /*****************************************/\n        /* Reduce angle to within 0..360 degrees */\n        /*****************************************/\n\n        return( x - 360.0 * floor( x * INV360 ) );\n    }  /* revolution */\n\n    private class func rev180(x: Double ) -\u003e Double {\n        /*********************************************/\n        /* Reduce angle to within +180..+180 degrees */\n        /*********************************************/\n\n        return( x - 360.0 * floor( x * INV360 + 0.5 ) );\n    }  /* revolution */\n\n    /********************************************************************/\n    /** This function computes GMST0, the Greenwich Mean Sidereal Time  */\n    /** at 0h UT (i.e. the sidereal time at the Greenwhich meridian at  */\n    /** 0h UT).  GMST is then the sidereal time at Greenwich at any     */\n    /** time of the day.  I've generalized GMST0 as well, and define it */\n    /** as:  GMST0 = GMST - UT  --  this allows GMST0 to be computed at */\n    /** other times than 0h UT as well.  While this sounds somewhat     */\n    /** contradictory, it is very practical:  instead of computing      */\n    /** GMST like:                                                      */\n    /**                                                                 */\n    /**  GMST = (GMST0) + UT * (366.2422/365.2422)                      */\n    /**                                                                 */\n    /** where (GMST0) is the GMST last time UT was 0 hours, one simply  */\n    /** computes:                                                       */\n    /**                                                                 */\n    /**  GMST = GMST0 + UT                                              */\n    /**                                                                 */\n    /** where GMST0 is the GMST \"at 0h UT\" but at the current moment!   */\n    /** Defined in this way, GMST0 will increase with about 4 min a     */\n    /** day.  It also happens that GMST0 (in degrees, 1 hr = 15 degr)   */\n    /** is equal to the Sun's mean longitude plus/minus 180 degrees!    */\n    /** (if we neglect aberration, which amounts to 20 seconds of arc   */\n    /** or 1.33 seconds of time)                                        */\n    /**                                                                 */\n    /********************************************************************/\n    private class func GMST0( d: Double ) -\u003e Double {\n        var sidtim0: Double\n        /* Sidtime at 0h UT = L (Sun's mean longitude) + 180.0 degr  */\n        /* L = M + w, as defined in sunpos().  Since I'm too lazy to */\n        /* add these numbers, I'll let the C compiler do it for me.  */\n        /* Any decent C compiler will add the constants at compile   */\n        /* time, imposing no runtime or code overhead.               */\n        sidtim0 = revolution( x: ( 180.0 + 356.0470 + 282.9404 ) +\n            ( 0.9856002585 + 4.70935E-5 ) * d )\n        return sidtim0\n    }  /* GMST0 */\n\n}"
			}
		],
		"path": "Time/sunrise.4h.swift",
		"filename": "sunrise.4h.swift",
		"dir": "Time",
		"docsPlugin": "Time/sunrise.4h.swift.html",
		"docsCategory": "Time.html",
		"pathSegments": [
			"Time"
		],
		"categoryPathSegments": [
			{
				"path": "Time",
				"text": "Time",
				"isLast": true
			}
		],
		"title": "Sunrise",
		"version": "v1.1.1",
		"author": "Brad Greenlee",
		"authors": [
			{
				"name": "Brad Greenlee",
				"githubUsername": "bgreenlee",
				"imageURL": "https://avatars.githubusercontent.com/u/2901?v=4",
				"bio": "",
				"primary": true
			}
		],
		"desc": "Displays sunrise, sunset, and day length for a location.",
		"imageURL": "https://raw.githubusercontent.com/bgreenlee/SunriseBitBar/main/sunrise-bitbar.png",
		"dependencies": [
			"Xcode",
			"swift"
		],
		"aboutURL": "https://github.com/bgreenlee/SunriseBitBar",
		"lastUpdated": "2021-03-08T15:22:06.477642Z",
		"vars": null
	}
}