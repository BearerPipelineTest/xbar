
<!doctype html>
<html lang='en' style='background: #111;'>
	<head>
		<meta charset='utf-8' />
		<meta name='viewport' content='width=device-width' />
		<meta http-equiv='X-UA-Compatible' content='ie=edge'>
		<title>RSync Backup Bitbar Plugin in your macOS menu bar</title>
		<link rel='stylesheet' href='/public/css/xbar.css?cb=08%20Mar%2021%2015%3a22%20GMT'>
		<link rel='preconnect' href='https://fonts.gstatic.com'>
		<link rel='preconnect' href='https://fonts.googleapis.com'>
		<link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Bodoni+Moda:wght@500&display=swap'>
		
	<meta name='description' content='Schedule and monitor rsync backups via BitBar - install xbar for free to get started.'>
	<meta name='author' content='Gregory S. Read'>
	<meta name='keywords' content='macos,menubar,xbar,bitbar'>
	<meta itemprop='image' content='https://xbarapp.com/public/img/xbar-2048.png'>
	<meta itemprop='name' content='RSync Backup Bitbar Plugin in your macOS menu bar'>
	<meta itemprop='description' content='Schedule and monitor rsync backups via BitBar - install xbar for free to get started.'>
	<meta name='twitter:card' content='summary_large_image'>
	<meta name='twitter:title' content='RSync Backup Bitbar Plugin in your macOS menu bar'>
	<meta name='twitter:description' content='Schedule and monitor rsync backups via BitBar - install xbar for free to get started.'>
	<meta name='twitter:image' content='https://xbarapp.com/public/img/xbar-2048.png'>
	<meta name='twitter:creator' content='matryer'>
	<meta property='og:title' content='RSync Backup Bitbar Plugin in your macOS menu bar'>
	<meta property='og:description' content='Schedule and monitor rsync backups via BitBar - install xbar for free to get started.'>
	<meta property='og:url' content='https://xbarapp.com/plugins/Tools/rsyncbackup.js.html'>
	<meta property='og:site_name' content='xbar lets you put anything into your macOS menu bar'>
	<meta property='og:type' content='article'>
	<meta property='og:image' content='https://xbarapp.com/public/img/xbar-2048.png'>
	<link rel='apple-touch-icon' sizes='180x180' href='https://xbarapp.com/public/img/xbar-2048.png'>
	<link rel='icon' type='image/png' sizes='32x32' href='https://xbarapp.com/public/img/xbar-2048.png'>
	<link rel='shortcut icon' href='https://xbarapp.com/public/img/xbar-2048.png'>
	<meta name='msapplication-TileColor' content='#ffffff'>
	<meta name='msapplication-config' content='/public/browserconfig.xml'>
	<meta name='theme-color' content='#ffffff'>
	<style>
		.code-background {
			background: rgb(255,255,255);
			background: linear-gradient(to right, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.1) 100%);
		}
		.plugin-app-link {
			margin-left: -32px;
		}
	</style>

	</head>
	<body>
		<header class='flex flex-col'>
			<div class='container mx-auto'>
				<div class='flex items-center space-x-8 p-8 text-white'>
					<a href='/' class='inline-block py-2 text-2xl flex items-center space-x-2 font-bold'>
						<img alt='xbar logo: a circle with three dots inside it' src='/public/img/xbar-2048.png' style='width:48px;height:48px;' />
						<span>xbar</span>
					</a>
					<div class='flex-grow'></div>
					<div>
						<a 
							target='github'
							href='https://github.com/sponsors/matryer' 
							class='text-white px-4 py-2 whitespace-nowrap'
						><span class='mr-1'>ðŸ’œ</span> Sponsor</a>
					</div>
					<div class='hidden md:block'>
						<a 
							target='github'
							href='/dl' 
							class='rounded bg-white text-gray-800 hover:text-black px-4 py-2 shadow hover:shadow-lg whitespace-nowrap'
						>Coming soon</a>
					</div>
				</div>
			</div>
		</header>
		<div id='menubar' class='text-white whitespace-nowrap overflow-hidden flex flex-wrap justify-end items-center text-right'>
			
			
				<a 
					
					href='/docs/plugins/AWS.html'
				>
					AWS
				</a>
			
				<a 
					
					href='/docs/plugins/Cryptocurrency.html'
				>
					Cryptocurrency
				</a>
			
				<a 
					
					href='/docs/plugins/Dev.html'
				>
					Dev
				</a>
			
				<a 
					
					href='/docs/plugins/E-Commerce.html'
				>
					E-Commerce
				</a>
			
				<a 
					
					href='/docs/plugins/Email.html'
				>
					Email
				</a>
			
				<a 
					
					href='/docs/plugins/Environment.html'
				>
					Environment
				</a>
			
				<a 
					
					href='/docs/plugins/Finance.html'
				>
					Finance
				</a>
			
				<a 
					
					href='/docs/plugins/Games.html'
				>
					Games
				</a>
			
				<a 
					
					href='/docs/plugins/IoT.html'
				>
					IoT
				</a>
			
				<a 
					
					href='/docs/plugins/Lifestyle.html'
				>
					Lifestyle
				</a>
			
				<a 
					
					href='/docs/plugins/Music.html'
				>
					Music
				</a>
			
				<a 
					
					href='/docs/plugins/Network.html'
				>
					Network
				</a>
			
				<a 
					
					href='/docs/plugins/Politics.html'
				>
					Politics
				</a>
			
				<a 
					
					href='/docs/plugins/Science.html'
				>
					Science
				</a>
			
				<a 
					
					href='/docs/plugins/Sports.html'
				>
					Sports
				</a>
			
				<a 
					
					href='/docs/plugins/System.html'
				>
					System
				</a>
			
				<a 
					
					href='/docs/plugins/Time.html'
				>
					Time
				</a>
			
				<a 
					 class='rounded selected' 
					href='/docs/plugins/Tools.html'
				>
					Tools
				</a>
			
				<a 
					
					href='/docs/plugins/Travel.html'
				>
					Travel
				</a>
			
				<a 
					
					href='/docs/plugins/Weather.html'
				>
					Weather
				</a>
			
				<a 
					
					href='/docs/plugins/Web.html'
				>
					Web
				</a>
			
		</div>
		
	<div class='container mx-auto flex flex-wrap space-x-8 justify-start items-start mt-16'>
		<div class='flex flex-col justify-start'>
			<div class='px-8 py-2 max-w-3xl'>
				<h1 class='fancy-font text-white text-6xl'>RSync Backup Bitbar Plugin</h1>
			</div>
			<div class='p-8 text-sm'>
				
					
						
							<div class='flex space-x-4 pb-8'>
								<div class='tiny-photo'>
									<a 
										href='/docs/contributors/readgs.html'
									>
										<img class='rounded shadow primary' src='https://avatars.githubusercontent.com/u/18175637?v=4'>
									</a>
								</div>
								<div>
									<a 
										href='/docs/contributors/readgs.html'
										class='light-background rounded-sm shadow-md px-4 py-2 text-white' 
										style='text-decoration: none;'
									>
										Gregory S. Read (<code style='color:white;'>@readgs</code> on GitHub)
									</a>
								</div>
							</div>
						
					
				
				
					<p class='my-8 text-white opacity-75 text-lg max-w-lg'>
						Schedule and monitor rsync backups via BitBar
					</p>
				
				<div class='plugin-app-link hidden md:flex items-end p-8 m-8 mb-16 bg-black bg-opacity-25 rounded-lg shadow max-w-md'>
					<div>
						<a 
							href='xbar://app.xbarapp.com/openPlugin?path=Tools%2frsyncbackup.js'
							class='rounded bg-white text-gray-800 hover:text-black px-4 py-2 shadow hover:shadow-lg whitespace-nowrap'
						><span class='mr-1'>ðŸ–¥</span> Open in xbar app</a>
					</div>
					<div class='opacity-50 text-sm text-white ml-3'>Requires <a target='github' href='/dl' class='underline'>xbar app</a></div>
				</div>
				
					<p class='text=sm opacity-75 py-4 max-w-lg mt-8 text-white'>
						<strong>Can you help?</strong>&mdash;This plugin is missing an image.
						Please add one 
						(via <code>&lt;xbar.image&gt;...&lt;/xbar.image&gt;</code> metadata) to enhance this plugin's presence. <a class='underline' target='github' href='https://github.com/matryer/bitbar-plugins/blob/master/Tools/rsyncbackup.js'>View file on GitHub</a>
					</p>
				
			</div>
		</div>
		<div 
			class='flex flex-col justify-center mb-16'
		>
			<img 
				class='max-w-md w-full'
				src='https://xbarapp.com/public/img/xbar-2048.png' 
				alt='Image preview of RSync Backup Bitbar Plugin plugin.'
				onerror='this.onerror=null;this.src="/public/img/xbar-2048.png";'
			/>
		</div>
	</div>

	
		<div class='code-background text-white p-8 pb-24'>
			<div class='container mx-auto'>
				<div class='flex flex-wrap py-8 space-x-4 justify-end'>
					<div>
						<h2 class='md:text-2xl text-bold'>
							<code>rsyncbackup.js</code>
						</h2>
					</div>
					<div class='flex-grow'></div>
					<div>
						<a class='text-sm text-white hover:text-black hover:bg-white px-4 py-2 rounded' target='github' href='https://github.com/matryer/bitbar-plugins/edit/master/Tools/rsyncbackup.js'>Edit</a>
					</div>
					<div>
						<a class='text-sm text-gray-700 bg-white hover:bg-gray-100 active:text-black px-4 py-2 rounded' target='github' href='https://github.com/matryer/bitbar-plugins/blob/master/Tools/rsyncbackup.js'>Open on GitHub</a>
					</div>
				</div>
				<div>
					<pre class='text-sm whitespace-pre-wrap'><code class='break-all '>#!/usr/bin/env /usr/local/bin/node
// jshint esversion: 8
// &lt;bitbar.title&gt;RSync Backup Bitbar Plugin&lt;/bitbar.title&gt;
// &lt;bitbar.version&gt;v1.0&lt;/bitbar.version&gt;
// &lt;bitbar.author&gt;Gregory S. Read&lt;/bitbar.author&gt;
// &lt;bitbar.author.github&gt;readgs&lt;/bitbar.author.github&gt;
// &lt;bitbar.desc&gt;Schedule and monitor rsync backups via BitBar&lt;/bitbar.desc&gt;
// &lt;bitbar.dependencies&gt;node npm/path npm/untildify npm/yargs npm/bitbar npm/mkdirp npm/jsonc npm/lockfile npm/execa npm/moment&lt;/bitbar.dependencies&gt;
// &lt;bitbar.abouturl&gt;&lt;/bitbar.abouturl&gt;

/**
 * Quick Install
 * -Make sure Node is installed (this also installs npm)
 * -Copy script to your bitbar plugins folder.
 *      NOTE: Be sure to name it something like rsyncbackup.5s.js so that it will refresh
 *      backup status (and trigger backups) often enough to be useful.
 * -Open up a terminal and navigate to plugin folder
 * -Install required npm packages...
 *      NOTE: This will only install the required dependencies into the plugins folder.
 *      Specifically, into a subfolder called node_modules.
 * 
 *      From Terminal: npm install --no-package-lock path untildify yargs bitbar mkdirp jsonc lockfile execa moment
 * -Refresh your plugins
 * -Select &#34;Configure&#34; option to open config file up in your default editor
 * -Make whatever changes necessary for your backup needs.
 *      NOTE: It is recommended that you don&#39;t set a schedule for your backup until
 *      you execute a &#34;dry run&#34; to make sure you like what it&#39;s backing up.
 * -Select &#34;Dry Run&#34;
 * -If you like the results, select Back Up Now
 * -If you still like the results, update the schedule in the configuration.
 * -Enjoy.
 */


const path = require(&#39;path&#39;);
const untildify = require(&#39;untildify&#39;);
const yargs = require(&#39;yargs&#39;);
const bitbar = require(&#39;bitbar&#39;);
const fs = require(&#39;fs&#39;);
const mkdirp = require(&#39;mkdirp&#39;);
const jsonc = require(&#39;jsonc&#39;);
const lockFile = require(&#39;lockfile&#39;);
const execa = require(&#39;execa&#39;);
const moment = require(&#39;moment&#39;);

/**
 * Enumeration of valid backup statuses
 */
const BackupStatus = {
    /**
     * No status available on backup (i.e. it hasn&#39;t run ever)
     */
    None: &#39;None&#39;,
    /**
     * Last backup was successful
     */
    Succeeded: &#39;Succeeded&#39;,
    /**
     * Last backup failed
     */
    Failed: &#39;Failed&#39;,
    /**
     * Backup currently in progress
     */
    Running: &#39;Running&#39;
}

/**
 * Values that don&#39;t change :)
 */
const constants = {
    /**
     * Main folder where we store backup related stuff (like lock files, logs, etc)
     */
    WORKINGFOLDER: &#39;~/.backup&#39;,
    /**
     * Name of lockfile we&#39;ll be using
     */
    LOCKFILE: &#39;backup.lock&#39;,
    /**
     * Name of file that will indicate the start of a backup
     */
    STARTFILE: &#39;start.flag&#39;,
    /**
     * Name of file that will indicate an error status
     */
    ERRORFILE: &#39;error.flag&#39;,
    /**
     * Name of file that will indicate a success status
     */
    SUCCESSFILE: &#39;success.flag&#39;,
    /**
     * Config file for user-configurable settings (source, destination, etc.)
     */
    CONFIGFILE: &#39;config.jsonc&#39;,
    /**
     * Name of excludes file for rsync
     */
    EXCLUDESFILE: &#39;excludes.txt&#39;,
    /**
     * Name of file where errors are logged
     */
    ERRORLOGFILE: &#39;errorlog.txt&#39;,
    /**
     * Name of file where rsync output is logged
     */
    LOGFILE: &#39;log.txt&#39;,
    /**
     * Default content for the rsync excludes file
     */
    DEFAULTEXCLUDES: 
`.backup/
.Trash/
.DS_Store`,
    /**
     * Default configuration content to use if no config file exists.
     */
    DEFAULTCONFIG:
`/**
* Configuration settings for backup
*/
{
    /**
     * Path to the rsync program.  The version included with macOS is ancient, so you
     * may want to install a newer version via homebrew.  In this case, you would want
     * to likely change this path to /usr/local/bin/rsync
     */
    &#34;rsyncPath&#34;: &#34;/usr/bin/rsync&#34;,
    /**
     * How often a backup should be executed.  Can expressed as a number, followed
     * by the time unit (seconds, hours or days).  For example...
     *      10s     Every 10 seconds
     *       5m     Every 5 minutes
     *       1h     Every 1 hour
     *       2d     Every 2 days
     *   manual     Backup is only done on-demand
     */
    &#34;frequency&#34;: &#34;1h&#34;,
    /**
     * Source to pass along to rsync for syncing data from
     */
    // ***UNCOMMENT LINE BELOW TO SPECIFY A SOURCE*** 
    //&#34;source&#34;: &#34;~&#34;,
    /**
     * Destination to pass along to rsync for syncing data to
     */
    // ***UNCOMMENT LINE BELOW TO SPECIFY A DESTINATION***
    //&#34;destination&#34;: &#34;/tmp/rsyncbackup/&#34;,
    /**
     * Additional arguments to pass to rsync.  Default arguments are reasonable
     * for a standard archival copy of the source to the destination (excluding
     * permissions, ACLs, etc.).  See documentation for &#39;rsync&#39; for more info
     * on arguments.
     * 
     * NOTE: The rsyncbackup.js script already passed along the --exclude-from
     * argument if the &#39;excludes&#39; configuration is specified above.
     */ 
    &#34;rsyncAdditionalArguments&#34;: [
        &#34;--archive&#34;,
        &#34;--no-perms&#34;,
        &#34;--no-acls&#34;,
        &#34;--stats&#34;,
        &#34;--delete&#34;,
        &#34;--delete-excluded&#34;
    ]
}`
}

/**
 * Variables that we just want accessible from anywhere
 */
const globals = {
    /**
     * Path of main working folder for rsyncbackup script
     */
    workingFolder: untildify(constants.WORKINGFOLDER),
    /**
     * Configuration settings for our script go here.
     */
    configFile: getBackupPath(constants.CONFIGFILE),
    /**
     * Excluded files and folders for rsync will be in this file.
     */
    excludesFile: getBackupPath(constants.EXCLUDESFILE),
    /**
     * Used for ensuring only one instance of the backup is running.
     */
    lockFile: getBackupPath(constants.LOCKFILE),
    /**
     * Created when a backup starts (mostly to figure out when our backup started)
     */
    startFile: getBackupPath(constants.STARTFILE),
    /**
     * If an error occured, this file will exist
     */
    errorFile: getBackupPath(constants.ERRORFILE),
    /**
     * If backup succeeded, this file will exist
     */
    successFile: getBackupPath(constants.SUCCESSFILE),
    /**
     * Logs from rsync go here
     */
    logFile: getBackupPath(constants.LOGFILE),
    /**
     * Any errors that rsync output go here
     */
    errorLogFile: getBackupPath(constants.ERRORLOGFILE),
    /**
     * Arguments retrieved from commandline
     */
    args: {},
    /**
     * Configuration loaded from config.jsonc.  If not loaded or validation error
     * with configuration, then this value will be null.
     */
    configuration: null,
    /**
     * If configuration is null, this value is set to a message indicating why
     * the configuration was not loaded.
     */
    configurationError: &#39;&#39;,
    /**
     * Status of the last completed backup.
     */
    backupStatus: BackupStatus.None,
    /**
     * Last date/time (formatted) of the last backup (regardless of outcome).
     * If null, that means we never started a backup before.
     */
    backupDate: null,
    /**
     * Number of milliseconds the backup has been running, or ran (depending on status)
     */
    backupDuration: 0,
    /**
     * Date and time of the next scheduled backup
     */
    nextScheduledBackup: null,
    /**
     * Arguments to pass to the rsync command
     */
    rsyncArgs: []
}

/**
 * Bitbar items that we show as the main item (shows on menubar) for a given bitBar view
 */
const bitbarHeaders = {
    /**
     * Show when backup is running
     */
    backupRunning: {
        text: &#39;:running:&#39;
    },
    /**
     * Show when last backup ended in error
     */
    backupError: {
        text: &#39;:rage:&#39;
    },
    /**
     * Show if last backup ended in success
     */
    backupSuccess: {
        text: &#39;:smile:&#39;
    },
    /**
     * Show if there is no status for the backup (i.e. it hasn&#39;t run yet) */    
    backupNoStatus: {
        text: &#39;:expressionless:&#39;
    }
}

const bitbarItems = {
    configurationError: {
        text: &#39;Error in config file: &#39;
    }
}

const bitbarActions = {
    /**
     * Shows a &#34;Configure...&#34; option and brings up the config file in a text editor when selected.
     */
    configure: {
        text: &#39;Configure...&#39;,
        bash: &#39;/usr/bin/open&#39;,
        param1: &#39;-t&#39;,
        param2: globals.configFile,
        terminal: false
    },
    /**
     * Shows a &#34;View Logs...&#34; option and brings up the last log in a text when selected.
     */
    viewLog: {
        text: &#39;View Log...&#39;,
        bash: &#39;/usr/bin/open&#39;,
        param1: &#39;-t&#39;,
        param2: globals.logFile,
        terminal: false
    },
    /**
     * Shows a &#34;View Logs...&#34; option and brings up the last log in a text when selected.
     */
    viewErrorLog: {
        text: &#39;View Error Log...&#39;,
        bash: &#39;/usr/bin/open&#39;,
        param1: &#39;-t&#39;,
        param2: globals.errorLogFile,
        terminal: false
    },
    /**
     * Shows a &#34;Start backup&#34; option and manually starts backup process when selected.
     */
    startBackup: {
        text: &#39;Back Up Now&#39;,
        //bash: See init()
        param1: &#39;--start&#39;,
        terminal: false
    },
    /**
     * Shows a &#34;Stop backup&#34; option and manually stops backup process if running, when selected.
     */
    stopBackup: {
        text: &#39;Stop Backup&#39;,
        //bash: See init(),
        param1: &#39;--stop&#39;,
        terminal: false
    },
    /**
     * Starts a backup, but not actually doing the copy.  Will run in a terminal as well
     * so user can observe what will be copied, etc.
     */
    dryRun: {
        text: &#39;Dry Run...&#39;,
        //bash: See init()
        param1: &#39;--start&#39;,
        param2: &#39;--dry-run&#39;,
        terminal: true
    }
}

/**
 * Do any initalization required for the script at startup
 */
async function init() {
    // Pull in commandline arguments
    globals.args = yargs
        .boolean([&#39;start&#39;, &#39;stop&#39;])
        .default(&#39;start&#39;, false)
        .default(&#39;stop&#39;, false)
        .describe(&#39;start&#39;, &#39;Starts the backup&#39;)
        .describe(&#39;stop&#39;, &#39;Stops the backup&#39;)
        .describe(&#39;dry-run&#39;, &#39;If starting backup, runs it in --dry-run rsync mode with a terminal&#39;)
        .argv;

    // Create missing items as needed
    await createFolderIfNeeded(globals.workingFolder);
    createFileIfNeeded(globals.configFile, constants.DEFAULTCONFIG);
    createFileIfNeeded(globals.excludesFile, constants.DEFAULTEXCLUDES);

    // Load in configuration
    loadConfiguration();

    // Initilize the rsync arguments based on configuration
    if(globals.configuration) {
        // Use the source, Luke...
        let source = untildify(globals.configuration.source);
        // If destination includes a colon, we&#39;ll treat it as a ssh server path.
        // Otherwise, make sure the tilde gets translated.
        let destination = globals.configuration.destination.includes(&#39;:&#39;) ?
            globals.configuration.destination
            : untildify(globals.configuration.destination);
        // Merge additional arguments with our default arguments
        globals.rsyncArgs = [
            ...globals.configuration.rsyncAdditionalArguments,
            `--exclude-from=${globals.excludesFile}`,
            source,
            destination
        ];
        // Enable dry-run mode if requested
        if(globals.args.dryRun) {
            globals.rsyncArgs.push(&#39;--dry-run&#39;);
        }
    }

    // Setup any bitbar items with additional info after init
    bitbarActions.startBackup.bash = __filename;
    bitbarActions.stopBackup.bash = __filename;
    bitbarActions.dryRun.bash = __filename;
    bitbarItems.configurationError.text &#43;= globals.configurationError;

    // Get and store our lastest backup status
    getBackupStatus();

    // Figure out when our next backup should occur, if applicable
    getNextScheduledBackup();
}

/**
 * Starts the backup process
 */
async function startBackup() {
    // Ensure we can get a lock on the lockfile before we proceed
    lockFile.lockSync(globals.lockFile, {});
    // Indicate that we&#39;ve started a backup
    touch(globals.startFile);
    // Remove the error and success flags since we are just starting
    untouch(globals.errorFile);
    untouch(globals.successFile);
    // Run rsync
    let exitCode = await executeRsync();
    if(exitCode != 0) {
        // Failed!
        touch(globals.errorFile);
    }
    else {
        // We succeeded!!
        touch(globals.successFile);
    }
    // We&#39;re all done, unlock the lock file
    lockFile.unlockSync(globals.lockFile);
}

/**
 * Stops the backup process, if it&#39;s running
 */
function stopBackup() {
    console.log(&#39;STOP BACKUP!&#39;);
}

/**
 * Returns BitBar-friendly status of the backup.  This is the default when no
 * arguments are passed to the script.
 */
function defaultOutput() {
    const formattedFileDate = !globals.backupDate ? &#39;never&#39; : formatDate(globals.backupDate);
    const formattedNextBackupDate = !globals.nextScheduledBackup ? &#39;never&#39; : formatDate(globals.nextScheduledBackup);
    const backupDurationInMinutes = (globals.backupDuration / 60000).toFixed(2);

    // If lockfile exists, we&#39;re running
    if(globals.backupStatus == BackupStatus.Running) {
        bitbar([
            bitbarHeaders.backupRunning,
            bitbar.separator,
            { text: `Backup running...` },
            { text: `Started at ${formattedFileDate}` },
            { text: `Running for ${backupDurationInMinutes}` },
            bitbar.separator,
            bitbarActions.stopBackup
        ]);
    }
    // If error file exists, something is wrong
    else if(globals.backupStatus == BackupStatus.Failed) {
        bitbar([
            bitbarHeaders.backupError,
            bitbar.separator,
            { text: `Backup failed!` },
            { text: `Started at ${formattedFileDate}` },
            { text: `Ran for ${backupDurationInMinutes} minutes` },
            { text: `Next backup at ${formattedNextBackupDate}` },
            bitbar.separator,
            bitbarActions.configure,
            bitbarActions.viewLog,
            bitbarActions.viewErrorLog,
        ]);
    }
    // If success file exists, the last backup succeeded
    else if (globals.backupStatus == BackupStatus.Succeeded) {
        bitbar([
            bitbarHeaders.backupSuccess,
            bitbar.separator,
            { text: `Backup succeeded!` },
            { text: `Started at ${formattedFileDate}` },
            { text: `Ran for ${backupDurationInMinutes} minutes` },
            { text: `Next backup at ${formattedNextBackupDate}` },
            bitbar.separator,
            bitbarActions.configure,
            bitbarActions.viewLog
        ]);
    }
    // Otherwise, we don&#39;t have any status (i.e. backup has never been run)
    else {
        bitbar([
            bitbarHeaders.backupNoStatus,
            bitbar.separator,
            { text: `Next backup at ${formattedNextBackupDate} minutes` },
            bitbar.separator,
            bitbarActions.configure
        ]);        
    }

    // Always show run/configuration error if we&#39;re in any status other that running
    if (globals.backupStatus != BackupStatus.Running) {
        if(!globals.configuration) {
            bitbar([bitbarItems.configurationError]);
        }
        else {
            bitbar([bitbarActions.dryRun]);
            bitbar([bitbarActions.startBackup]);
        }
    }
}

/**
 * Run the actual rsync program with the configured arguments
 */
async function executeRsync() {
    const subProcess = execa(globals.configuration.rsyncPath, globals.rsyncArgs, {});

    // If not dry run, send output to log files.  Otherwise output will just
    // go to terminal.
    if(!globals.args.dryRun) {
        // Create our error and output logs
        const errStream = fs.createWriteStream(globals.errorLogFile);
        const outStream = fs.createWriteStream(globals.logFile);
        // We don&#39;t want any output from rsync (spit out to our respective files)
        subProcess.stderr.pipe(errStream);
        subProcess.stdout.pipe(outStream);
    } else {
        // We&#39;re interactive dry run, send output to parent process
        subProcess.stderr.pipe(process.stderr);
        subProcess.stdout.pipe(process.stdout);
    }

    return (await subProcess).exitCode;
}

/**
 * Create the folder if it doesn&#39;t exist
 * @param {*} folderPath 
 */
async function createFolderIfNeeded(folderPath) {
    if(!fs.existsSync(folderPath)) {
        await mkdirp(folderPath);
    }
}

/**
 * Creates the specified file with default content, if it doesn&#39;t exist.
 * @param {string} filePath 
 * @param {string} defaultContent 
 */
function createFileIfNeeded(filePath, defaultContent) {
    if(!fs.existsSync(filePath)) {
        fs.writeFileSync(filePath, defaultContent);
    }
}

/**
 * Sets the date/time of when the next backup should take place
 * based on the configuration and status.
 */
function getNextScheduledBackup() {
    let now = new Date();
    let frequencyInMinutes = getFrequencyInMinutes(globals.configuration.frequency);

    // If we haven&#39;t done a backup before, schedule it for now!
    if(!globals.backupDate) {
        globals.nextScheduledBackup = now;
    }
    // If there&#39;s no frequency, assume it&#39;s manual
    else if(!frequencyInMinutes) {
        globals.nextScheduledBackup = null;
    }
    else {
        // Get the date/time for the next scheduled backup
        globals.nextScheduledBackup = moment(globals.backupDate).add(frequencyInMinutes, &#39;minutes&#39;).toDate();
        // If next scheduled backup is in the past, set it to happen now
        if(globals.nextScheduledBackup.getTime() &lt; now.getTime()) {
            globals.nextScheduledBackup = now;
        }
    }
}



/**
 * Starts an instance of the backup if we are scheduled to do so
 * @returns {boolean} True if backup started, otherwise false.
 */
function startBackupIfScheduled() {
    let now = new Date();
    // If the time has come!
    if(globals.nextScheduledBackup &amp;&amp; globals.nextScheduledBackup.getTime() &lt;= now) {
        // Execute ourselves with the &#34;--start&#34; parameter so we start the backup
        // but don&#39;t wait for the process to finish.
        const subProcess = execa(__filename, [&#39;--start&#39;], {
            detached: true,
            cleanup: false
        });

        subProcess.unref();
        return true;
    }

    return false;
}

/**
 * Retrieve and store information related to the last successful, failed or in-progress backup
 */
function getBackupStatus() {
    let now = new Date();
    // Only get modify date for startFile if the file exists
    if(fs.existsSync(globals.startFile)) {
        globals.backupDate = getFileDate(globals.startFile);
    }
    // If no start file exists, then should assume we never did a backup
    else {
        return;
    }

    // If a lockfile exists, then our backup is currently running
    if(fs.existsSync(globals.lockFile)) { 
        // Duration is start of backup to now
        globals.backupStatus = BackupStatus.Running;
        globals.backupDuration = moment(now).diff(globals.backupDate);
    }
    // Else if error file exists, our last backup failed
    else if(fs.existsSync(globals.errorFile)) {
        // Duration is start of backup to date/time of error file
        let errorFileDate = getFileDate(globals.errorFile);
        globals.backupStatus = BackupStatus.Failed;
        globals.backupDuration = moment(errorFileDate).diff(globals.backupDate);
    }
    // Else if success file exists, our last backup succeeded
    else if(fs.existsSync(globals.successFile)) {
        // Duration is start of backup to date/time of error file
        let successFileDate = getFileDate(globals.successFile);
        globals.backupStatus = BackupStatus.Succeeded;
        globals.backupDuration = moment(successFileDate).diff(globals.backupDate);
    }

    // Else, we&#39;re in an unknown state (don&#39;t set any status)
}

/**
 * Loads and verifies 
 */
function loadConfiguration() {
    let content = fs.readFileSync(globals.configFile).toString();
    let configuration = {};
    try {
        configuration = jsonc.parse(content);
    } catch(e) {
        globals.configurationError = &#39;Error parsing configuration file&#39;;
        return;
    }

    // By default, no error
    let error = null;
    
    // If rsync path is bad
    if(!configuration.rsyncPath || !fs.existsSync(configuration.rsyncPath)) {
        error = &#39;rsyncPath is invalid or file does not exist&#39;;
    }
    // If frequency isn&#39;t specified, or it&#39;s not a valid frequency
    else if(!configuration.frequency || !(configuration.frequency === &#39;manual&#39; || getFrequencyInMinutes(configuration.frequency))) {
        error = &#39;frequency is invalid&#39;;
    }
    // Must have a valid source 
    else if(!configuration.source) {
        error = &#39;source must be set&#39;;
    }
    // Must have a valid destination
    else if(!configuration.destination) {
        error = &#39;destination must be set&#39;;
    }
    // Check whether our rsync arguments is a legit string array
    else if(!configuration.rsyncAdditionalArguments ||
        !Array.isArray(configuration.rsyncAdditionalArguments) ||
        !configuration.rsyncAdditionalArguments.reduce((prev, curr) =&gt; typeof prev === &#39;string&#39; || typeof curr === &#39;string&#39;)) {
        error = &#39;rsyncAdditionalArguments is invalid&#39;
    }

    if(error) {
        // Just save the error that we got
        globals.configurationError = error;
    }
    else {
        // Config is good, let&#39;s save it as our actual config
        globals.configuration = configuration;
    }
}

/**
 * Parses a frequency string into number of minutes
 * @param {string} frequency 
 */
function getFrequencyInMinutes(frequency) {
    let values = frequency.match(/^\s*(\d*)\s*([sSmMhHdD])\s*$/);
    // If frequency was in a valid format
    if(values) {
        let unit = values[2].toLowerCase();
        let value = values[1];
        switch(unit) {
            case &#39;s&#39;:
                return value / 60;
            case &#39;m&#39;:
                return value;
            case &#39;h&#39;:
                return value * 60;
            case &#39;d&#39;:
                return value * 1440;
        }
    }

    return null;
}

/**
 * Gets the last time the specified file was modified.
 * @param {string} filePath 
 */
function getFileDate(filePath) {
    const { mtime } = fs.statSync(filePath);
    return mtime;
}

/**
 * Formats specified to display as &#34;M/D/YY h:mm AM/PM&#34;
 * @param {Date} fileDate 
 */
function formatDate(fileDate) {
    return moment(fileDate).format(&#39;M/D/YY h:mm A&#39;);
}

/**
 * Returns a full path and file using the configured backup path ()
 * @param {string} fileName 
 */
function getBackupPath(fileName) {
    return untildify(path.join(constants.WORKINGFOLDER, fileName));
}

/**
 * Creates an empty file and/or updates the modified date.
 * @param {string} filePath 
 */
function touch(filePath) {
    fs.closeSync(fs.openSync(filePath, &#39;w&#39;));
}

/**
 * Removes the file if it exists.
 * @param {string} filePath 
 */
function untouch(filePath) {
    if(fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
    }
}

// START HERE
(async () =&gt; {
    await init();

    if(globals.args.start) {
        await startBackup();
    }
    else if(globals.args.stop) {
        stopBackup();
    }
    else {
        let isBackupStarted = startBackupIfScheduled();
        defaultOutput();
        if(isBackupStarted) {
            // If we started a backup, we want to kill our process.  Otherwise
            // it will wait for the other backup process that we started, which
            // we don&#39;t want (so status gets reported back right away).
            process.exit(0);
        }
    }
})();</code></pre>
				</div>
			</div>
		</div>
	

		<footer class='container mx-auto text-white text-lg opacity-75 mt-8'>
			<div class='text-center p-16'>
				<p>
					<div>
						<a target='github' class='underline hover:text-white' href='https://github.com/matryer/xbar'>GitHub project</a>
						â€¢
						<a target='github' class='underline hover:text-white' href='https://github.com/matryer/xbar#writing-plugins'>Writing plugins guide</a>
					</div>
					<div class='mt-8'>
						Copyright &copy;2021 Mat Ryer + contributors â€¢ <a target='twitter' class='underline hover:text-white' href='https://twitter.com/matryer'>@matryer</a>
					</div>
					<div class='opacity-50 mt-2'>
						Last updated on 08 Mar 21 15:22 GMT
					</div>
				</p>
			</div>
		</footer>
	</body>
</html>
