{
	"plugin": {
		"files": [
			{
				"path": "Tools/rsyncbackup.js",
				"filename": "rsyncbackup.js",
				"content": "#!/usr/bin/env /usr/local/bin/node\n// jshint esversion: 8\n// \u003cbitbar.title\u003eRSync Backup Bitbar Plugin\u003c/bitbar.title\u003e\n// \u003cbitbar.version\u003ev1.0\u003c/bitbar.version\u003e\n// \u003cbitbar.author\u003eGregory S. Read\u003c/bitbar.author\u003e\n// \u003cbitbar.author.github\u003ereadgs\u003c/bitbar.author.github\u003e\n// \u003cbitbar.desc\u003eSchedule and monitor rsync backups via BitBar\u003c/bitbar.desc\u003e\n// \u003cbitbar.dependencies\u003enode npm/path npm/untildify npm/yargs npm/bitbar npm/mkdirp npm/jsonc npm/lockfile npm/execa npm/moment\u003c/bitbar.dependencies\u003e\n// \u003cbitbar.abouturl\u003e\u003c/bitbar.abouturl\u003e\n\n/**\n * Quick Install\n * -Make sure Node is installed (this also installs npm)\n * -Copy script to your bitbar plugins folder.\n *      NOTE: Be sure to name it something like rsyncbackup.5s.js so that it will refresh\n *      backup status (and trigger backups) often enough to be useful.\n * -Open up a terminal and navigate to plugin folder\n * -Install required npm packages...\n *      NOTE: This will only install the required dependencies into the plugins folder.\n *      Specifically, into a subfolder called node_modules.\n * \n *      From Terminal: npm install --no-package-lock path untildify yargs bitbar mkdirp jsonc lockfile execa moment\n * -Refresh your plugins\n * -Select \"Configure\" option to open config file up in your default editor\n * -Make whatever changes necessary for your backup needs.\n *      NOTE: It is recommended that you don't set a schedule for your backup until\n *      you execute a \"dry run\" to make sure you like what it's backing up.\n * -Select \"Dry Run\"\n * -If you like the results, select Back Up Now\n * -If you still like the results, update the schedule in the configuration.\n * -Enjoy.\n */\n\n\nconst path = require('path');\nconst untildify = require('untildify');\nconst yargs = require('yargs');\nconst bitbar = require('bitbar');\nconst fs = require('fs');\nconst mkdirp = require('mkdirp');\nconst jsonc = require('jsonc');\nconst lockFile = require('lockfile');\nconst execa = require('execa');\nconst moment = require('moment');\n\n/**\n * Enumeration of valid backup statuses\n */\nconst BackupStatus = {\n    /**\n     * No status available on backup (i.e. it hasn't run ever)\n     */\n    None: 'None',\n    /**\n     * Last backup was successful\n     */\n    Succeeded: 'Succeeded',\n    /**\n     * Last backup failed\n     */\n    Failed: 'Failed',\n    /**\n     * Backup currently in progress\n     */\n    Running: 'Running'\n}\n\n/**\n * Values that don't change :)\n */\nconst constants = {\n    /**\n     * Main folder where we store backup related stuff (like lock files, logs, etc)\n     */\n    WORKINGFOLDER: '~/.backup',\n    /**\n     * Name of lockfile we'll be using\n     */\n    LOCKFILE: 'backup.lock',\n    /**\n     * Name of file that will indicate the start of a backup\n     */\n    STARTFILE: 'start.flag',\n    /**\n     * Name of file that will indicate an error status\n     */\n    ERRORFILE: 'error.flag',\n    /**\n     * Name of file that will indicate a success status\n     */\n    SUCCESSFILE: 'success.flag',\n    /**\n     * Config file for user-configurable settings (source, destination, etc.)\n     */\n    CONFIGFILE: 'config.jsonc',\n    /**\n     * Name of excludes file for rsync\n     */\n    EXCLUDESFILE: 'excludes.txt',\n    /**\n     * Name of file where errors are logged\n     */\n    ERRORLOGFILE: 'errorlog.txt',\n    /**\n     * Name of file where rsync output is logged\n     */\n    LOGFILE: 'log.txt',\n    /**\n     * Default content for the rsync excludes file\n     */\n    DEFAULTEXCLUDES: \n`.backup/\n.Trash/\n.DS_Store`,\n    /**\n     * Default configuration content to use if no config file exists.\n     */\n    DEFAULTCONFIG:\n`/**\n* Configuration settings for backup\n*/\n{\n    /**\n     * Path to the rsync program.  The version included with macOS is ancient, so you\n     * may want to install a newer version via homebrew.  In this case, you would want\n     * to likely change this path to /usr/local/bin/rsync\n     */\n    \"rsyncPath\": \"/usr/bin/rsync\",\n    /**\n     * How often a backup should be executed.  Can expressed as a number, followed\n     * by the time unit (seconds, hours or days).  For example...\n     *      10s     Every 10 seconds\n     *       5m     Every 5 minutes\n     *       1h     Every 1 hour\n     *       2d     Every 2 days\n     *   manual     Backup is only done on-demand\n     */\n    \"frequency\": \"1h\",\n    /**\n     * Source to pass along to rsync for syncing data from\n     */\n    // ***UNCOMMENT LINE BELOW TO SPECIFY A SOURCE*** \n    //\"source\": \"~\",\n    /**\n     * Destination to pass along to rsync for syncing data to\n     */\n    // ***UNCOMMENT LINE BELOW TO SPECIFY A DESTINATION***\n    //\"destination\": \"/tmp/rsyncbackup/\",\n    /**\n     * Additional arguments to pass to rsync.  Default arguments are reasonable\n     * for a standard archival copy of the source to the destination (excluding\n     * permissions, ACLs, etc.).  See documentation for 'rsync' for more info\n     * on arguments.\n     * \n     * NOTE: The rsyncbackup.js script already passed along the --exclude-from\n     * argument if the 'excludes' configuration is specified above.\n     */ \n    \"rsyncAdditionalArguments\": [\n        \"--archive\",\n        \"--no-perms\",\n        \"--no-acls\",\n        \"--stats\",\n        \"--delete\",\n        \"--delete-excluded\"\n    ]\n}`\n}\n\n/**\n * Variables that we just want accessible from anywhere\n */\nconst globals = {\n    /**\n     * Path of main working folder for rsyncbackup script\n     */\n    workingFolder: untildify(constants.WORKINGFOLDER),\n    /**\n     * Configuration settings for our script go here.\n     */\n    configFile: getBackupPath(constants.CONFIGFILE),\n    /**\n     * Excluded files and folders for rsync will be in this file.\n     */\n    excludesFile: getBackupPath(constants.EXCLUDESFILE),\n    /**\n     * Used for ensuring only one instance of the backup is running.\n     */\n    lockFile: getBackupPath(constants.LOCKFILE),\n    /**\n     * Created when a backup starts (mostly to figure out when our backup started)\n     */\n    startFile: getBackupPath(constants.STARTFILE),\n    /**\n     * If an error occured, this file will exist\n     */\n    errorFile: getBackupPath(constants.ERRORFILE),\n    /**\n     * If backup succeeded, this file will exist\n     */\n    successFile: getBackupPath(constants.SUCCESSFILE),\n    /**\n     * Logs from rsync go here\n     */\n    logFile: getBackupPath(constants.LOGFILE),\n    /**\n     * Any errors that rsync output go here\n     */\n    errorLogFile: getBackupPath(constants.ERRORLOGFILE),\n    /**\n     * Arguments retrieved from commandline\n     */\n    args: {},\n    /**\n     * Configuration loaded from config.jsonc.  If not loaded or validation error\n     * with configuration, then this value will be null.\n     */\n    configuration: null,\n    /**\n     * If configuration is null, this value is set to a message indicating why\n     * the configuration was not loaded.\n     */\n    configurationError: '',\n    /**\n     * Status of the last completed backup.\n     */\n    backupStatus: BackupStatus.None,\n    /**\n     * Last date/time (formatted) of the last backup (regardless of outcome).\n     * If null, that means we never started a backup before.\n     */\n    backupDate: null,\n    /**\n     * Number of milliseconds the backup has been running, or ran (depending on status)\n     */\n    backupDuration: 0,\n    /**\n     * Date and time of the next scheduled backup\n     */\n    nextScheduledBackup: null,\n    /**\n     * Arguments to pass to the rsync command\n     */\n    rsyncArgs: []\n}\n\n/**\n * Bitbar items that we show as the main item (shows on menubar) for a given bitBar view\n */\nconst bitbarHeaders = {\n    /**\n     * Show when backup is running\n     */\n    backupRunning: {\n        text: ':running:'\n    },\n    /**\n     * Show when last backup ended in error\n     */\n    backupError: {\n        text: ':rage:'\n    },\n    /**\n     * Show if last backup ended in success\n     */\n    backupSuccess: {\n        text: ':smile:'\n    },\n    /**\n     * Show if there is no status for the backup (i.e. it hasn't run yet) */    \n    backupNoStatus: {\n        text: ':expressionless:'\n    }\n}\n\nconst bitbarItems = {\n    configurationError: {\n        text: 'Error in config file: '\n    }\n}\n\nconst bitbarActions = {\n    /**\n     * Shows a \"Configure...\" option and brings up the config file in a text editor when selected.\n     */\n    configure: {\n        text: 'Configure...',\n        bash: '/usr/bin/open',\n        param1: '-t',\n        param2: globals.configFile,\n        terminal: false\n    },\n    /**\n     * Shows a \"View Logs...\" option and brings up the last log in a text when selected.\n     */\n    viewLog: {\n        text: 'View Log...',\n        bash: '/usr/bin/open',\n        param1: '-t',\n        param2: globals.logFile,\n        terminal: false\n    },\n    /**\n     * Shows a \"View Logs...\" option and brings up the last log in a text when selected.\n     */\n    viewErrorLog: {\n        text: 'View Error Log...',\n        bash: '/usr/bin/open',\n        param1: '-t',\n        param2: globals.errorLogFile,\n        terminal: false\n    },\n    /**\n     * Shows a \"Start backup\" option and manually starts backup process when selected.\n     */\n    startBackup: {\n        text: 'Back Up Now',\n        //bash: See init()\n        param1: '--start',\n        terminal: false\n    },\n    /**\n     * Shows a \"Stop backup\" option and manually stops backup process if running, when selected.\n     */\n    stopBackup: {\n        text: 'Stop Backup',\n        //bash: See init(),\n        param1: '--stop',\n        terminal: false\n    },\n    /**\n     * Starts a backup, but not actually doing the copy.  Will run in a terminal as well\n     * so user can observe what will be copied, etc.\n     */\n    dryRun: {\n        text: 'Dry Run...',\n        //bash: See init()\n        param1: '--start',\n        param2: '--dry-run',\n        terminal: true\n    }\n}\n\n/**\n * Do any initalization required for the script at startup\n */\nasync function init() {\n    // Pull in commandline arguments\n    globals.args = yargs\n        .boolean(['start', 'stop'])\n        .default('start', false)\n        .default('stop', false)\n        .describe('start', 'Starts the backup')\n        .describe('stop', 'Stops the backup')\n        .describe('dry-run', 'If starting backup, runs it in --dry-run rsync mode with a terminal')\n        .argv;\n\n    // Create missing items as needed\n    await createFolderIfNeeded(globals.workingFolder);\n    createFileIfNeeded(globals.configFile, constants.DEFAULTCONFIG);\n    createFileIfNeeded(globals.excludesFile, constants.DEFAULTEXCLUDES);\n\n    // Load in configuration\n    loadConfiguration();\n\n    // Initilize the rsync arguments based on configuration\n    if(globals.configuration) {\n        // Use the source, Luke...\n        let source = untildify(globals.configuration.source);\n        // If destination includes a colon, we'll treat it as a ssh server path.\n        // Otherwise, make sure the tilde gets translated.\n        let destination = globals.configuration.destination.includes(':') ?\n            globals.configuration.destination\n            : untildify(globals.configuration.destination);\n        // Merge additional arguments with our default arguments\n        globals.rsyncArgs = [\n            ...globals.configuration.rsyncAdditionalArguments,\n            `--exclude-from=${globals.excludesFile}`,\n            source,\n            destination\n        ];\n        // Enable dry-run mode if requested\n        if(globals.args.dryRun) {\n            globals.rsyncArgs.push('--dry-run');\n        }\n    }\n\n    // Setup any bitbar items with additional info after init\n    bitbarActions.startBackup.bash = __filename;\n    bitbarActions.stopBackup.bash = __filename;\n    bitbarActions.dryRun.bash = __filename;\n    bitbarItems.configurationError.text += globals.configurationError;\n\n    // Get and store our lastest backup status\n    getBackupStatus();\n\n    // Figure out when our next backup should occur, if applicable\n    getNextScheduledBackup();\n}\n\n/**\n * Starts the backup process\n */\nasync function startBackup() {\n    // Ensure we can get a lock on the lockfile before we proceed\n    lockFile.lockSync(globals.lockFile, {});\n    // Indicate that we've started a backup\n    touch(globals.startFile);\n    // Remove the error and success flags since we are just starting\n    untouch(globals.errorFile);\n    untouch(globals.successFile);\n    // Run rsync\n    let exitCode = await executeRsync();\n    if(exitCode != 0) {\n        // Failed!\n        touch(globals.errorFile);\n    }\n    else {\n        // We succeeded!!\n        touch(globals.successFile);\n    }\n    // We're all done, unlock the lock file\n    lockFile.unlockSync(globals.lockFile);\n}\n\n/**\n * Stops the backup process, if it's running\n */\nfunction stopBackup() {\n    console.log('STOP BACKUP!');\n}\n\n/**\n * Returns BitBar-friendly status of the backup.  This is the default when no\n * arguments are passed to the script.\n */\nfunction defaultOutput() {\n    const formattedFileDate = !globals.backupDate ? 'never' : formatDate(globals.backupDate);\n    const formattedNextBackupDate = !globals.nextScheduledBackup ? 'never' : formatDate(globals.nextScheduledBackup);\n    const backupDurationInMinutes = (globals.backupDuration / 60000).toFixed(2);\n\n    // If lockfile exists, we're running\n    if(globals.backupStatus == BackupStatus.Running) {\n        bitbar([\n            bitbarHeaders.backupRunning,\n            bitbar.separator,\n            { text: `Backup running...` },\n            { text: `Started at ${formattedFileDate}` },\n            { text: `Running for ${backupDurationInMinutes}` },\n            bitbar.separator,\n            bitbarActions.stopBackup\n        ]);\n    }\n    // If error file exists, something is wrong\n    else if(globals.backupStatus == BackupStatus.Failed) {\n        bitbar([\n            bitbarHeaders.backupError,\n            bitbar.separator,\n            { text: `Backup failed!` },\n            { text: `Started at ${formattedFileDate}` },\n            { text: `Ran for ${backupDurationInMinutes} minutes` },\n            { text: `Next backup at ${formattedNextBackupDate}` },\n            bitbar.separator,\n            bitbarActions.configure,\n            bitbarActions.viewLog,\n            bitbarActions.viewErrorLog,\n        ]);\n    }\n    // If success file exists, the last backup succeeded\n    else if (globals.backupStatus == BackupStatus.Succeeded) {\n        bitbar([\n            bitbarHeaders.backupSuccess,\n            bitbar.separator,\n            { text: `Backup succeeded!` },\n            { text: `Started at ${formattedFileDate}` },\n            { text: `Ran for ${backupDurationInMinutes} minutes` },\n            { text: `Next backup at ${formattedNextBackupDate}` },\n            bitbar.separator,\n            bitbarActions.configure,\n            bitbarActions.viewLog\n        ]);\n    }\n    // Otherwise, we don't have any status (i.e. backup has never been run)\n    else {\n        bitbar([\n            bitbarHeaders.backupNoStatus,\n            bitbar.separator,\n            { text: `Next backup at ${formattedNextBackupDate} minutes` },\n            bitbar.separator,\n            bitbarActions.configure\n        ]);        \n    }\n\n    // Always show run/configuration error if we're in any status other that running\n    if (globals.backupStatus != BackupStatus.Running) {\n        if(!globals.configuration) {\n            bitbar([bitbarItems.configurationError]);\n        }\n        else {\n            bitbar([bitbarActions.dryRun]);\n            bitbar([bitbarActions.startBackup]);\n        }\n    }\n}\n\n/**\n * Run the actual rsync program with the configured arguments\n */\nasync function executeRsync() {\n    const subProcess = execa(globals.configuration.rsyncPath, globals.rsyncArgs, {});\n\n    // If not dry run, send output to log files.  Otherwise output will just\n    // go to terminal.\n    if(!globals.args.dryRun) {\n        // Create our error and output logs\n        const errStream = fs.createWriteStream(globals.errorLogFile);\n        const outStream = fs.createWriteStream(globals.logFile);\n        // We don't want any output from rsync (spit out to our respective files)\n        subProcess.stderr.pipe(errStream);\n        subProcess.stdout.pipe(outStream);\n    } else {\n        // We're interactive dry run, send output to parent process\n        subProcess.stderr.pipe(process.stderr);\n        subProcess.stdout.pipe(process.stdout);\n    }\n\n    return (await subProcess).exitCode;\n}\n\n/**\n * Create the folder if it doesn't exist\n * @param {*} folderPath \n */\nasync function createFolderIfNeeded(folderPath) {\n    if(!fs.existsSync(folderPath)) {\n        await mkdirp(folderPath);\n    }\n}\n\n/**\n * Creates the specified file with default content, if it doesn't exist.\n * @param {string} filePath \n * @param {string} defaultContent \n */\nfunction createFileIfNeeded(filePath, defaultContent) {\n    if(!fs.existsSync(filePath)) {\n        fs.writeFileSync(filePath, defaultContent);\n    }\n}\n\n/**\n * Sets the date/time of when the next backup should take place\n * based on the configuration and status.\n */\nfunction getNextScheduledBackup() {\n    let now = new Date();\n    let frequencyInMinutes = getFrequencyInMinutes(globals.configuration.frequency);\n\n    // If we haven't done a backup before, schedule it for now!\n    if(!globals.backupDate) {\n        globals.nextScheduledBackup = now;\n    }\n    // If there's no frequency, assume it's manual\n    else if(!frequencyInMinutes) {\n        globals.nextScheduledBackup = null;\n    }\n    else {\n        // Get the date/time for the next scheduled backup\n        globals.nextScheduledBackup = moment(globals.backupDate).add(frequencyInMinutes, 'minutes').toDate();\n        // If next scheduled backup is in the past, set it to happen now\n        if(globals.nextScheduledBackup.getTime() \u003c now.getTime()) {\n            globals.nextScheduledBackup = now;\n        }\n    }\n}\n\n\n\n/**\n * Starts an instance of the backup if we are scheduled to do so\n * @returns {boolean} True if backup started, otherwise false.\n */\nfunction startBackupIfScheduled() {\n    let now = new Date();\n    // If the time has come!\n    if(globals.nextScheduledBackup \u0026\u0026 globals.nextScheduledBackup.getTime() \u003c= now) {\n        // Execute ourselves with the \"--start\" parameter so we start the backup\n        // but don't wait for the process to finish.\n        const subProcess = execa(__filename, ['--start'], {\n            detached: true,\n            cleanup: false\n        });\n\n        subProcess.unref();\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Retrieve and store information related to the last successful, failed or in-progress backup\n */\nfunction getBackupStatus() {\n    let now = new Date();\n    // Only get modify date for startFile if the file exists\n    if(fs.existsSync(globals.startFile)) {\n        globals.backupDate = getFileDate(globals.startFile);\n    }\n    // If no start file exists, then should assume we never did a backup\n    else {\n        return;\n    }\n\n    // If a lockfile exists, then our backup is currently running\n    if(fs.existsSync(globals.lockFile)) { \n        // Duration is start of backup to now\n        globals.backupStatus = BackupStatus.Running;\n        globals.backupDuration = moment(now).diff(globals.backupDate);\n    }\n    // Else if error file exists, our last backup failed\n    else if(fs.existsSync(globals.errorFile)) {\n        // Duration is start of backup to date/time of error file\n        let errorFileDate = getFileDate(globals.errorFile);\n        globals.backupStatus = BackupStatus.Failed;\n        globals.backupDuration = moment(errorFileDate).diff(globals.backupDate);\n    }\n    // Else if success file exists, our last backup succeeded\n    else if(fs.existsSync(globals.successFile)) {\n        // Duration is start of backup to date/time of error file\n        let successFileDate = getFileDate(globals.successFile);\n        globals.backupStatus = BackupStatus.Succeeded;\n        globals.backupDuration = moment(successFileDate).diff(globals.backupDate);\n    }\n\n    // Else, we're in an unknown state (don't set any status)\n}\n\n/**\n * Loads and verifies \n */\nfunction loadConfiguration() {\n    let content = fs.readFileSync(globals.configFile).toString();\n    let configuration = {};\n    try {\n        configuration = jsonc.parse(content);\n    } catch(e) {\n        globals.configurationError = 'Error parsing configuration file';\n        return;\n    }\n\n    // By default, no error\n    let error = null;\n    \n    // If rsync path is bad\n    if(!configuration.rsyncPath || !fs.existsSync(configuration.rsyncPath)) {\n        error = 'rsyncPath is invalid or file does not exist';\n    }\n    // If frequency isn't specified, or it's not a valid frequency\n    else if(!configuration.frequency || !(configuration.frequency === 'manual' || getFrequencyInMinutes(configuration.frequency))) {\n        error = 'frequency is invalid';\n    }\n    // Must have a valid source \n    else if(!configuration.source) {\n        error = 'source must be set';\n    }\n    // Must have a valid destination\n    else if(!configuration.destination) {\n        error = 'destination must be set';\n    }\n    // Check whether our rsync arguments is a legit string array\n    else if(!configuration.rsyncAdditionalArguments ||\n        !Array.isArray(configuration.rsyncAdditionalArguments) ||\n        !configuration.rsyncAdditionalArguments.reduce((prev, curr) =\u003e typeof prev === 'string' || typeof curr === 'string')) {\n        error = 'rsyncAdditionalArguments is invalid'\n    }\n\n    if(error) {\n        // Just save the error that we got\n        globals.configurationError = error;\n    }\n    else {\n        // Config is good, let's save it as our actual config\n        globals.configuration = configuration;\n    }\n}\n\n/**\n * Parses a frequency string into number of minutes\n * @param {string} frequency \n */\nfunction getFrequencyInMinutes(frequency) {\n    let values = frequency.match(/^\\s*(\\d*)\\s*([sSmMhHdD])\\s*$/);\n    // If frequency was in a valid format\n    if(values) {\n        let unit = values[2].toLowerCase();\n        let value = values[1];\n        switch(unit) {\n            case 's':\n                return value / 60;\n            case 'm':\n                return value;\n            case 'h':\n                return value * 60;\n            case 'd':\n                return value * 1440;\n        }\n    }\n\n    return null;\n}\n\n/**\n * Gets the last time the specified file was modified.\n * @param {string} filePath \n */\nfunction getFileDate(filePath) {\n    const { mtime } = fs.statSync(filePath);\n    return mtime;\n}\n\n/**\n * Formats specified to display as \"M/D/YY h:mm AM/PM\"\n * @param {Date} fileDate \n */\nfunction formatDate(fileDate) {\n    return moment(fileDate).format('M/D/YY h:mm A');\n}\n\n/**\n * Returns a full path and file using the configured backup path ()\n * @param {string} fileName \n */\nfunction getBackupPath(fileName) {\n    return untildify(path.join(constants.WORKINGFOLDER, fileName));\n}\n\n/**\n * Creates an empty file and/or updates the modified date.\n * @param {string} filePath \n */\nfunction touch(filePath) {\n    fs.closeSync(fs.openSync(filePath, 'w'));\n}\n\n/**\n * Removes the file if it exists.\n * @param {string} filePath \n */\nfunction untouch(filePath) {\n    if(fs.existsSync(filePath)) {\n        fs.unlinkSync(filePath);\n    }\n}\n\n// START HERE\n(async () =\u003e {\n    await init();\n\n    if(globals.args.start) {\n        await startBackup();\n    }\n    else if(globals.args.stop) {\n        stopBackup();\n    }\n    else {\n        let isBackupStarted = startBackupIfScheduled();\n        defaultOutput();\n        if(isBackupStarted) {\n            // If we started a backup, we want to kill our process.  Otherwise\n            // it will wait for the other backup process that we started, which\n            // we don't want (so status gets reported back right away).\n            process.exit(0);\n        }\n    }\n})();"
			}
		],
		"path": "Tools/rsyncbackup.js",
		"filename": "rsyncbackup.js",
		"dir": "Tools",
		"docsPlugin": "Tools/rsyncbackup.js.html",
		"docsCategory": "Tools.html",
		"pathSegments": [
			"Tools"
		],
		"categoryPathSegments": [
			{
				"path": "Tools",
				"text": "Tools",
				"isLast": true
			}
		],
		"title": "RSync Backup Bitbar Plugin",
		"version": "v1.0",
		"author": "Gregory S. Read",
		"authors": [
			{
				"name": "Gregory S. Read",
				"githubUsername": "readgs",
				"imageURL": "https://avatars.githubusercontent.com/u/18175637?v=4",
				"bio": "",
				"primary": true
			}
		],
		"desc": "Schedule and monitor rsync backups via BitBar",
		"imageURL": "https://xbarapp.com/public/img/xbar-2048.png",
		"dependencies": [
			"node npm/path npm/untildify npm/yargs npm/bitbar npm/mkdirp npm/jsonc npm/lockfile npm/execa npm/moment"
		],
		"aboutURL": "",
		"lastUpdated": "2021-03-08T15:22:07.733974Z",
		"vars": null
	}
}