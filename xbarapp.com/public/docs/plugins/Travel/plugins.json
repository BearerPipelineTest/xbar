{
	"plugins": [
		{
			"files": [
				{
					"path": "Travel/commuter.365d.py",
					"filename": "commuter.365d.py",
					"content": "#!/usr/bin/env python\n# -*- encoding: utf-8 -*-\n\n# \u003cbitbar.title\u003eCommuter\u003c/bitbar.title\u003e\n# \u003cbitbar.author\u003eFrak Nuaimy\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003efrakman1\u003c/bitbar.author.github\u003e\n# \u003cbitbar.image\u003ehttps://i.imgur.com/JN8ad03.png\u003c/bitbar.image\u003e\n# \u003cbitbar.desc\u003eShow commute details (GoogleMaps API)\u003c/bitbar.desc\u003e\n# \u003cbitbar.dependencies\u003epython, simplejson\u003c/bitbar.dependencies\u003e\n# \u003cbitbar.version\u003ev1.0\u003c/bitbar.version\u003e\nimport os, sys\nimport argparse\nimport subprocess\nimport simplejson, urllib\nimport json\n\nfullPathFileName = os.path.realpath(__file__)\ncommuterdir = \"commuter_data\"\ncommuterdir_path = os.path.dirname(os.path.abspath(__file__))+'/'+commuterdir\n\nkey_filename = \"google-map-api.txt\"\nkey_path = commuterdir_path+'/'+key_filename\norigin_filename = \"origin.txt\"\norigin_path = commuterdir_path+'/'+origin_filename\ndest_filename = \"dest.txt\"\ndest_path = commuterdir_path+'/'+dest_filename\n\ndef run_script(script):\n    return (subprocess.Popen([script], stdout=subprocess.PIPE, shell=True).communicate()[0].strip()).replace(\"'\", \"‚Äô\")\n\n# Create plugin data folder if it doesn't exist. \n# This is where input is stored (api key, origin, destination)\ncommuterdir_exists = os.path.exists(commuterdir_path) \nif not commuterdir_exists:\n    os.mkdir( commuterdir_path, 0755 );\n\ndebug = False\napi_key = \"\"\norig_coord=\"Earth\"\ndest_coord=\"Mars\"\ndriving_time = \"\"\ndriving_dist = \"\"\norigin = \"\"\ndestination = \"\"\ncommuter_icon = \"iVBORw0KGgoAAAANSUhEUgAAAA8AAAAWCAYAAAAfD8YZAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KTMInWQAABDRJREFUOBF1VH1oHEUUf/O1u5dcmuTyadKmpEdrisRacq0Fob2zYmIwEqUx2EBL/0hShValUFoickpFLYqlLdgUTAxRxICfNK0oeLEUTJprBYUkVrEJxl5TL9bkcpe93Z0ZZy4g8Q9nYee9ee/3e+/te7MI1IqFozQyEvW03HgysW+RkzYOqI4g5M8KuVTlo5PVfjbU2+n/QPuEozE6Eo14KKqEqBJaT88FFzKi7y4t2imAgBQcbM+DEpNBbaGpTgCkt3S5zPT2nzpQPK0JkGYaPvHJ+pfJQ5enrYqa4NIdnsFUcCGFRTDUFlhgYYJdKbDhtwgs2zOVa+7uerujagZr8PYbA/3vJq/UpNJJ+yoxEBOCMMNn1pYWm5bpMxWRogHkpG0b8qz1dxYCfRpHEt379hS5maOlc697LV45u1lwL/rBKsIh5kwXUBiT3KXEsIo97iHAAnObClmcDG7tXDOBWTrVziQG23hc1CePyHMzg6jT/b3/iwcK6wcP+po2ld6sZzzdx0wLgDOQbEEsVwxACk21o/m9T0z6pajLCJm1PNP0grM/+9+8ej9C4MR74yzUHXJjMaDvTdo/uszcvFRyLgtF35o0s3YKAyYBjjmIeSytrYtAW9iYBvZ2xVlDV4N36PQvZiQCHkg8ziuvAM/7DIRzD2DsBjDCwkFpArjKQRCZApY/v1Z/jO7zIRd+PWycObwxq/Vs+YVq2/8RIF4DSAWTAA4WWfQHZQh8rTNYGLP6kz6cvba7QwPQxjM54JGvjz2z5L+0my/rOaKIULVJuEUFJqP0ycSDuGZKSicgCE2qjGR/enTbzjyWid+w14VeWUwecBEFU1XHkVTZYkWBxlDm4lM7zED8eynnFFuekNgDhBAm+WmlV8PZVATO/50PGyQXjg6oGkZVd8po/g6c1/zpKMdlHxI1SYBcTwqKQYAQKe72JrZ7h/7yu8EVoJoT6RkFJpiIDfQ3vjWWmzCXbjnKUxW3iOEaWDEQWMRfZZrZs045bUUuUxHVMbjIpAZK8dkKGTimkgAk48BQCFx7vKnZlFPDIKbhmr2LdyzVkSBSDZISqRvGFZxQTKAE+R99v/HkN+FYdOViyCEg6GngcjzU8yc1TuxPbPYygpIiVaGj+BWHYPkWsWxy/OPH3nkjHAvTkciIl0sbJqKqbSqNbfHXXp3b8mXW56OFSHgKqB5wqd8kdFl+roHaL/xdWOg9B1aXWsRUGvrgLGw6WLQsbnuMMlVoFhnYgDS/vQ5XPqftOt2o8tfySmQlRCJRLzrUZkDTiwmDWD1MTYIAqeqkkEetnlNNPYmGeBcbUX4aqNe/4Jw2cV/OECnZO4iz8jpbY1LkiOta1/aWhiqe8/u/V9tQm/7jQPvFF3rafzou91x6/iWt66h6X73+G3mVhUg2zGfTU35iXNDHG357JFfnKhf4B9JL0GcpEIdSAAAAAElFTkSuQmCC\"\n\nprint \"| image={}\".format(commuter_icon)\nprint \"---\"\n\n# Get inputs from files if they exist\nkeyfile_exists = os.path.isfile(key_path) \nif keyfile_exists:\n    with open(key_path, 'r') as file:\n        api_key = file.read()\n\noriginfile_exists = os.path.isfile(origin_path) \nif originfile_exists:\n    with open(origin_path, 'r') as file:\n        orig_coord = file.read()   \n        origin = orig_coord  \n\ndestfile_exists = os.path.isfile(dest_path) \nif destfile_exists:\n    with open(dest_path, 'r') as file:\n        dest_coord = file.read()  \n        destination = dest_coord\n\n###############################################################################################################################################################################################################################################\n# Handle inputs\nparser = argparse.ArgumentParser()\nparser.add_argument('-k', action='store', dest='localkey',help='Create Google Maps API Key')\nparser.add_argument('-o', action='store', dest='localorigin',help='Origin Street Address')\nparser.add_argument('-d', action='store', dest='localdest',help='Destination Street Address')\nresults = parser.parse_args()\n\nif('-k' in sys.argv):    \n    cmd = \"osascript -e \\'set theString to text returned of (display dialog \\\"Please Enter The Google API Key. \\n\\nIt will be stored in:\\n{}\".format(key_path) + \"  \\\" with icon note default answer \\\"\\\" buttons {\\\"OK\\\",\\\"Cancel\\\"} default button 1) \\'\" \n    api_key = run_script(cmd)\n    with open(key_path, 'w') as f:\n        f.write(api_key)\n    sys.exit(1)\n    \nif('-o' in sys.argv):    \n    cmd = \"osascript -e \\'set theString to text returned of (display dialog \\\"Please Enter Origin Street Address. \\n\\nIt will be stored in:\\n{}\".format(origin_path) + \"  \\\" with icon note default answer \\\"\\\" buttons {\\\"OK\\\",\\\"Cancel\\\"} default button 1) \\'\" \n    orig_coord = run_script(cmd)\n    with open(origin_path, 'w') as f:\n        f.write(orig_coord)\n    sys.exit(1)    \n\nif('-d' in sys.argv):    \n    cmd = \"osascript -e \\'set theString to text returned of (display dialog \\\"Please Enter Destination Street Address. \\n\\nIt will be stored in:\\n{}\".format(dest_path) + \"  \\\" with icon note default answer \\\"\\\" buttons {\\\"OK\\\",\\\"Cancel\\\"} default button 1) \\'\" \n    dest_coord = run_script(cmd)\n    with open(dest_path, 'w') as f:\n        f.write(dest_coord)\n    sys.exit(1)     \n\n###############################################################################################################################################################################################################################################\n# Check API Key\nif api_key == \"\" or api_key == \"invalid\":\n    print(\"üîë Add API KEY | trim=false, color=red font='Lucida Grande Bold' bash=\" + fullPathFileName +  \" param1=-k param2=null terminal=false refresh=true\")\nelse:\n    #print(\"üîë API Key: ‚úÖ \" )\n    key_tooltip = str(key_path)\n    print \"üîë API Key | checked=true color=#179C52 font='Lucida Grande Bold' bash=\" + fullPathFileName +  \" param1=-k param2=null terminal=false refresh=true tooltip=\\\"%s\\\"\" % (key_tooltip) \nprint \"--\" + api_key\n    \n###############################################################################################################################################################################################################################################\n# Make API Call to Google\nurl = \"https://maps.googleapis.com/maps/api/distancematrix/json?key={0}\u0026units=imperial\u0026origins={1}\u0026destinations={2}\u0026mode=driving\u0026language=en-EN\u0026departure_time=now\u0026traffic_model=best_guess\".format(api_key,str(orig_coord),str(dest_coord))\nresult= simplejson.load(urllib.urlopen(url))\nprint \"---\"\nif result['status'] != 'OK':\n    #print(result)\n    debug = True\n    if 'status' in result.keys():\n        print(\"üö´ \" + str(result['status']) + ' üö´| color=red')\n    if 'error_message' in result.keys():\n        print(\"\" + str(result['error_message']) + '| color=red')\n        if str(result['error_message']) == \"The provided API key is invalid.\":\n            api_key = \"invalid\"\n            with open(key_path, 'w') as f:\n                f.write(api_key)\n            \n        \n    print(\"üöÄ From: \" + origin    + \"| trim=false, bash=\" + fullPathFileName +  \" param1=-o param2=null terminal=false refresh=true\")\n    print(\"üèÅ To: \" + destination + \"| trim=false, bash=\" + fullPathFileName +  \" param1=-d param2=null terminal=false refresh=true\")   \n         \nelse:\n###############################################################################################################################################################################################################################################\n    print \"---\"\n    try:\n        driving_time = result['rows'][0]['elements'][0]['duration_in_traffic']['text']\n        driving_dist = result['rows'][0]['elements'][0]['distance']['text']\n        origin = str(result['origin_addresses'][0])\n        with open(origin_path, 'w') as f:\n            f.write(origin)\n        destination = str(result['destination_addresses'][0])\n        with open(dest_path, 'w') as f:\n            f.write(destination)\n    \n    except Exception, e:\n        print '‚ùó Error parsing results- reason \"%s\" | color=red' % str(e)\n        debug = True\n        print 'Result:'\n        print result\n        #sys.exit(1)\n\n    #Print results\n    print(\"üöó Commute | color=red font='Lucida Grande Bold'\")\n    print(\"üöÄ From: \" + origin + \"| trim=false, bash=\" + fullPathFileName +  \" param1=-o param2=null terminal=false refresh=true\")\n    print(\"üèÅ To: \" + destination+ \"| trim=false, bash=\" + fullPathFileName +  \" param1=-d param2=null terminal=false refresh=true\")\n    print(\"‚è±Ô∏è Driving Time: \"+ driving_time)\n    print(\"üìè Driving Dist: \"+ driving_dist)\n    directions = \"https://www.google.com/maps?saddr={}\u0026daddr={}\u0026t=m\u0026z=7\u0026layer=t\".format(origin.replace(\" \",\"+\").replace(\",\",\"\"),destination.replace(\" \",\"+\").replace(\",\",\"\"))\n    print \"üó∫Ô∏è View in Google Maps\" + \"| color =#4285F4 font='Lucida Grande Bold' href=%s \" % (directions)\n\n###############################################################################################################################################################################################################################################\n# When things go wrong...\n#debug = True\nif debug:\n    print \"---\"\n    print \"üêû debug | color=#DB4437\"\n    json_formatted_str = json.dumps(result, indent=2)\n    print('-- Result| color=white')\n    for line in json_formatted_str.split('\\n'):\n        print(\"----\" + '‚Äé‚Äé' + line + \"| color=white size=11 font='Courier New'\")\n    if 'directions' in vars():    \n        print('-- Directions URL | color=white')\n        print('---- ' + directions + '|  color=#4285F4 href=%s ' % (directions))\n###############################################################################################################################################################################################################################################\nprint \"---\"\nprint \"üîÑ Refresh | refresh=true\"\n\n\n"
				}
			],
			"path": "Travel/commuter.365d.py",
			"filename": "commuter.365d.py",
			"dir": "Travel",
			"docsPlugin": "Travel/commuter.365d.py.html",
			"docsCategory": "Travel.html",
			"pathSegments": [
				"Travel"
			],
			"categoryPathSegments": [
				{
					"path": "Travel",
					"text": "Travel",
					"isLast": true
				}
			],
			"title": "Commuter",
			"version": "v1.0",
			"author": "Frak Nuaimy",
			"authors": [
				{
					"name": "Frak",
					"githubUsername": "frakman1",
					"imageURL": "https://avatars.githubusercontent.com/u/5826484?v=4",
					"bio": "",
					"primary": true
				}
			],
			"desc": "Show commute details (GoogleMaps API)",
			"imageURL": "https://i.imgur.com/JN8ad03.png",
			"dependencies": [
				"python",
				"simplejson"
			],
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:22:08.235218Z",
			"vars": null
		},
		{
			"files": [
				{
					"path": "Travel/gwr-wifi-status.1m.py",
					"filename": "gwr-wifi-status.1m.py",
					"content": "#!/usr/local/bin/python\n# -*- coding: utf-8 -*-\n# \u003cbitbar.title\u003eGWR Wifi Status\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev0.1\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003eAdam Marsh\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003eAdam2Marsh\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eShows the WiFi Status when on a GWR train.\u003c/bitbar.desc\u003e\n# \u003cbitbar.image\u003ehttp://gwr.passengerwifi.com/library/images/logo-gwr%402x.png\u003c/bitbar.image\u003e\n# \u003cbitbar.dependencies\u003eGWR-Wifi,python,dryscrape\u003c/bitbar.dependencies\u003e\n\n# GWR Passenger Wifi Page\nurl = \"http://gwr.passengerwifi.com/connected.php\"\n\nimport dryscrape\nimport re\n# import urllib2\n\ntry:\n    # result = urllib2.urlopen(url, timeout = 5).read()\n    session = dryscrape.Session()\n    session.visit(url)\n    result = session.body();\n    print \"üöÇ\"\n    print \"---\"\n\n    try:\n        signalStrength = re.search('\u003cdiv class=\\\"guagevalue\\\" id=\\\"signalvalue\\\"\u003e(\\d+%)\u003c\\/div\u003e', result);\n        print \"Signal Strength:\"\n        print signalStrength.group(1) + \"| href=\" + url\n    except:\n        print \"‚ùå\"\n        print \"---\"\n\n    try:\n        howBusy = re.search('\u003cdiv class=\\\"guagevalue\\\"\u003e([\\w\\s]+)\u003c\\/div\u003e', result);\n        print \"How Busy:\"\n        print howBusy.group(1) + \"| href=\" + url\n    except:\n        print \"‚ùå\"\n        print \"---\"\n\n    try:\n        location = re.search('\u003cdiv class=\\\"description\\\"\u003e[\\t\\n\\r]\\s+\u003ch2\u003e([\\w\\s]+)\u003c\\/h2\u003e', result);\n        print \"Location:\"\n        print location.group(1) + \"| href=\" + url\n    except:\n        print \"‚ùå\"\n        print \"---\"\nexcept:\n    print \"‚ùå\"\n    print \"---\"\n    print \"GWR Passenger Wifi Not Available | color=red\"\n    print \"---\"\n"
				}
			],
			"path": "Travel/gwr-wifi-status.1m.py",
			"filename": "gwr-wifi-status.1m.py",
			"dir": "Travel",
			"docsPlugin": "Travel/gwr-wifi-status.1m.py.html",
			"docsCategory": "Travel.html",
			"pathSegments": [
				"Travel"
			],
			"categoryPathSegments": [
				{
					"path": "Travel",
					"text": "Travel",
					"isLast": true
				}
			],
			"title": "GWR Wifi Status",
			"version": "v0.1",
			"author": "Adam Marsh",
			"authors": [
				{
					"name": "Adam Marsh",
					"githubUsername": "Adam2Marsh",
					"imageURL": "https://avatars.githubusercontent.com/u/7213334?v=4",
					"bio": "",
					"primary": true
				}
			],
			"desc": "Shows the WiFi Status when on a GWR train.",
			"imageURL": "http://gwr.passengerwifi.com/library/images/logo-gwr%402x.png",
			"dependencies": [
				"GWR-Wifi",
				"python",
				"dryscrape"
			],
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:22:08.251763Z",
			"vars": null
		},
		{
			"files": [
				{
					"path": "Travel/leapcard.1h.py",
					"filename": "leapcard.1h.py",
					"content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# \u003cbitbar.title\u003eLeap Card Balance\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev1.2.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003eJack Higgins\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003eskhg\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003eDisplays your current Leap Card balance along with any recent card events.\u003c/bitbar.desc\u003e\n# \u003cbitbar.image\u003ehttps://github.com/skhg/BitBar-Plugins/blob/master/LeapCard/leapcard.jpg?raw=true\u003c/bitbar.image\u003e\n# \u003cbitbar.dependencies\u003epython 2 or 3, pyleapcard, lxml\u003c/bitbar.dependencies\u003e\n# \u003cbitbar.abouturl\u003ehttps://github.com/skhg/BitBar-Plugins/tree/master/LeapCard\u003c/bitbar.abouturl\u003e\n\n\n\n\n\n\n\n# START USER DETAILS\n\n# Enter your leapcard.ie login details here. These are sent only to the leap card\n# website and never stored or transmitted anywhere else.\n\nleap_user = \"MyUserName\"\nleap_pass = \"MyPassword\"\n\n# END USER DETAILS\n\n\n\n\n\nfrom sys import exit\n\n# VERIFY DEPENDENCIES\ntry:\n    from pyleapcard import LeapSession\nexcept ImportError:\n    print(\"Leap Card\")\n    print(\"---\")\n    print(\"Looks like the package 'pyleapcard' isn't installed.\")\n    print(\"You need it to run this tool. To install, click 'Install Now',\")\n    print(\"then click 'Preferences' -\u003e 'Refresh All...'\")\n    print(\"Install Now. | bash='sudo /usr/local/bin/pip install pyleapcard'\")\n    exit()\n\n\n\n# START APP\n\nimport pickle\nimport os\nimport subprocess\nimport sys\n\nclass StateMgmt:\n    \n    def __init__(self):\n        os.chdir(self.get_bitbar_plugins_dir())\n        self.relative_state_dir = \"./.leapcard_state/\"\n        self.state_dump_file = self.relative_state_dir+\"leapcard_last_state.pickle\"\n\n    def get_bitbar_plugins_dir(self):\n        bitbar_defaults = subprocess.check_output([\"defaults\", \"read\", \"com.matryer.BitBar\"]).split(\";\")\n        for entry in bitbar_defaults:\n            if \"pluginsDirectory\" in entry:\n                return entry.split(\"\\\"\")[1]\n\n        raise IOError(\"BitBar plugins directory could not be found\")\n    \n    def check_state_dir_exists(self, state_dir):\n        if os.path.exists(state_dir) is False:\n            os.mkdir(state_dir)\n    \n    def load_state(self):\n        self.check_state_dir_exists(self.relative_state_dir)\n\n        if os.path.exists(self.state_dump_file) is False:\n            return None\n        else:\n            try:\n                with open(self.state_dump_file,\"r\") as f_read:\n                    return pickle.load(f_read)\n            except:\n                return None\n    \n    def dump_state(self, card_state,events_state):\n        self.check_state_dir_exists(self.relative_state_dir)\n\n        current_state = [card_state,events_state]\n\n        with open(self.state_dump_file,\"w\") as f_write:\n            pickle.dump(current_state,f_write)\n\nclass ResultsFormatter:\n    \n    def euro_value_to_str(self, value, highlightNegative=False):\n        balance_string =u\"\"\n        negative_balance = False\n\n        if value \u003c 0:\n            balance_string = u\"- \"\n            negative_balance = True\n\n        balance_string += u'‚Ç¨{:,.2f}'.format(abs(value))\n\n        if negative_balance and highlightNegative:\n            balance_string += \" | color=orange\"\n\n        return balance_string\n    \n    def format_card_event(self, event):\n        styleInfo = \" | font=Courier\"\n\n        if event.was_topup is True:\n            styleInfo += \" color=green\"\n\n        euroVal = self.euro_value_to_str(event.price).encode(\"utf-8\")\n        start = event.date + \" \" + event.time + \" (\" + event.provider + \") \"\n\n        return start.encode(\"utf-8\") + euroVal + styleInfo.encode(\"utf-8\")\n    \n    def print_output(self, card, events, is_live, login_url):\n        print(self.euro_value_to_str(card.balance,True).encode(\"utf-8\"))\n        print(\"---\")\n        if is_live is False:\n            print(\"‚ùå : Using cached data, last update failed\")\n            print(\"---\")\n\n        print(card.card_num+\" (\" + card.card_label + \")\".encode())\n        print(\"---\")\n        print(\"Recent Events\")\n        for e in events:\n            print(self.format_card_event(e))\n        print(\"---\")\n\n        print(\"leapcard.ie | href=\"+login_url)\n    \n    def print_error_message(self, details, login_url):\n        print(\"‚ùå\")\n        print(\"---\")\n        print(\"Error: Unable to retrieve Leap Card state.\")\n        print(\"---\")\n\n        print(\"leapcard.ie | href=\"+login_url)\n\ndef run():\n    login_ok= False\n    login_error = \"\"\n\n    session = LeapSession()\n\n    try:\n        login_ok = session.try_login(leap_user, leap_pass)\n    except Exception:\n        login_error = sys.exc_info()[0]\n\n    state = StateMgmt()\n    formatter = ResultsFormatter()\n\n    if login_ok:\n        card = session.get_card_overview()\n        events = session.get_events()\n        \n        state.dump_state(card,events)\n        formatter.print_output(card,events,True, session.login_url())\n    else:\n        loaded_state = state.load_state()\n        if loaded_state is not None:\n            formatter.print_output(loaded_state[0],loaded_state[1],False, session.login_url())\n        else:\n            formatter.print_error_message(login_error, session.login_url())\n\nrun()\n"
				}
			],
			"path": "Travel/leapcard.1h.py",
			"filename": "leapcard.1h.py",
			"dir": "Travel",
			"docsPlugin": "Travel/leapcard.1h.py.html",
			"docsCategory": "Travel.html",
			"pathSegments": [
				"Travel"
			],
			"categoryPathSegments": [
				{
					"path": "Travel",
					"text": "Travel",
					"isLast": true
				}
			],
			"title": "Leap Card Balance",
			"version": "v1.2.0",
			"author": "Jack Higgins",
			"authors": [
				{
					"name": "Jack Higgins",
					"githubUsername": "skhg",
					"imageURL": "https://avatars.githubusercontent.com/u/1479627?v=4",
					"bio": "Product Manager and Software Engineer",
					"primary": true
				}
			],
			"desc": "Displays your current Leap Card balance along with any recent card events.",
			"imageURL": "https://github.com/skhg/BitBar-Plugins/blob/master/LeapCard/leapcard.jpg?raw=true",
			"dependencies": [
				"python 2 or 3",
				"pyleapcard",
				"lxml"
			],
			"aboutURL": "https://github.com/skhg/BitBar-Plugins/tree/master/LeapCard",
			"lastUpdated": "2021-03-08T15:22:08.320412Z",
			"vars": null
		},
		{
			"files": [
				{
					"path": "Travel/renaultze.10m.py",
					"filename": "renaultze.10m.py",
					"content": "#!/opt/local/bin/python\n# -*- coding: utf-8 -*-\n#\n# \u003cbitbar.title\u003eRenault Zero Emission\u003c/bitbar.title\u003e\n# \u003cbitbar.version\u003ev1.0\u003c/bitbar.version\u003e\n# \u003cbitbar.author\u003eAntoine Coetsier\u003c/bitbar.author\u003e\n# \u003cbitbar.author.github\u003eretrack\u003c/bitbar.author.github\u003e\n# \u003cbitbar.desc\u003ePulls your Renault EV battery status current and estimated\u003c/bitbar.desc\u003e\n# \u003cbitbar.image\u003ehttp://i.imgur.com/Wb1IUoO.png\u003c/bitbar.image\u003e\n#\n# Installation:\n# 1/ adjust your Python Binary location (embedded, Homebrew or Macports)\n# 2/ install request module with \"sudo pip install requests\"\n# 3/ change user and password to your my.renault.com credentials\n\nimport requests\nimport xml.etree.ElementTree as ET\n\nuser = \"email address\"\npassword = \"your password\"\n\n\nheaders = {'Content-Type': 'text/xml'}\n\n# forge the authentication payload\nxml = \"\"\"\n\u003cns1:SmartphoneNewLoginRequest xmlns:ns1=\"urn:com:renault:smartphone.userservices:v1\" xmlns:ns3=\"urn:com:renault:gdc:type:user:v1\" xmlns:ns4=\"urn:com:hitachi:gdc:type:authenticationmanagercommon:v1\" xmlns:ns2=\"urn:com:hitachi:gdc:type:authenticationmanagercommon:v1\"\u003e\n   \u003cSmartphoneNewLoginInfo\u003e\n           \u003cns1:UserNewLoginInfo\u003e\n                   \u003cns4:UserId\u003e{0}\u003c/ns4:UserId\u003e\n                   \u003cns4:Password\u003e{1}\u003c/ns4:Password\u003e\n           \u003c/ns1:UserNewLoginInfo\u003e\n           \u003cns1:DeviceToken\u003e\u003c/ns1:DeviceToken\u003e\n           \u003cns1:UUID\u003e\u003c/ns1:UUID\u003e\n           \u003cns1:Locale\u003eFR\u003c/ns1:Locale\u003e\n           \u003cns1:AppVersion\u003e\u003c/ns1:AppVersion\u003e\n           \u003cns1:SmartphoneType\u003eIPHONE\u003c/ns1:SmartphoneType\u003e\n           \u003cCountryCode\u003eFR\u003c/CountryCode\u003e\n   \u003c/SmartphoneNewLoginInfo\u003e\n\u003c/ns1:SmartphoneNewLoginRequest\u003e\n\"\"\"\n\nurl = \"https://rno-smartgtw.viaaq.eu/aqPortal/B2CSmartphoneProxy/\"\n\n# perform a user/password authentication\nr = requests.post(url + \"UserService\",data=xml.format(user, password), headers=headers)\nsession = r.headers.get('Set-Cookie').split(';')[0]\ncookie = session.split('=')[1]\n\n# extract VIN number for subsequent requests\nroot = ET.fromstring(r.content)\nfor a in root.findall('.//{urn:com:renault:gdc:type:portalcommon:v1}VIN'):\n    vin = a.text\n\n# forge the dashboard payload\nxml = \"\"\"\n\u003cns4:SmartphoneGetNewCurrentDataRequest xmlns:ns3=\"urn:com:renault:gdc:type:portalcommon:v1\" xmlns:ns4=\"urn:com:renault:gdc:type:smartphoneEvDashboard:v1\" xmlns:ns2=\"urn:com:renault:gdc:type:evDashboard:v1\"\u003e\n        \u003cns3:VehicleServiceRequestHeader\u003e\n                \u003cns3:VIN\u003e{0}\u003c/ns3:VIN\u003e\n                \u003cns3:Caller\u003eSMARTPHONE-APP\u003c/ns3:Caller\u003e\n        \u003c/ns3:VehicleServiceRequestHeader\u003e\n\u003c/ns4:SmartphoneGetNewCurrentDataRequest\u003e\n\"\"\"\n\nr1 = requests.post(url + \"EvDashboardService\",data=xml.format(vin), headers=headers, cookies=r.cookies)\n\nroot = ET.fromstring(r1.content)\nfor a in root.findall('.//{urn:com:renault:gdc:type:evDashboard:v1}BatteryRemainingPercent'):\n    BatteryRemainingPercent = a.text\n    print(BatteryRemainingPercent + \" %\")\n    break\nfor a in root.findall('.//{urn:com:renault:gdc:type:evDashboard:v1}CruisingRange'):\n    CruisingRange = a.text\n    print(CruisingRange + \" km\")\nprint(\"---\")\nprint(\"VIN: \" + vin)\n"
				}
			],
			"path": "Travel/renaultze.10m.py",
			"filename": "renaultze.10m.py",
			"dir": "Travel",
			"docsPlugin": "Travel/renaultze.10m.py.html",
			"docsCategory": "Travel.html",
			"pathSegments": [
				"Travel"
			],
			"categoryPathSegments": [
				{
					"path": "Travel",
					"text": "Travel",
					"isLast": true
				}
			],
			"title": "Renault Zero Emission",
			"version": "v1.0",
			"author": "Antoine Coetsier",
			"authors": [
				{
					"name": "Antoine Coetsier",
					"githubUsername": "retrack",
					"imageURL": "https://avatars.githubusercontent.com/u/1295273?v=4",
					"bio": "",
					"primary": true
				}
			],
			"desc": "Pulls your Renault EV battery status current and estimated",
			"imageURL": "http://i.imgur.com/Wb1IUoO.png",
			"dependencies": null,
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:22:08.334108Z",
			"vars": null
		},
		{
			"files": [
				{
					"path": "Travel/travel-time.5m.php",
					"filename": "travel-time.5m.php",
					"content": "#!/usr/bin/env php\n\u003c?php\n/**\n * Provides travel distance and time for your favorite destination, with traffic conditions.\n *\n * A Google Developer Account is required with access to \"Google Maps Distance Matrix API\" and \"Google Maps Geolocation API\"\n *\n * How does it work:\n * - perform a Wifi Access Point scan using airport utility command\n * - Get current position (lat,lng) with Geolocation API using collected AP data\n * - Get distance, time and traffic delay using the Distance Matrix API\n *\n * @link https://console.developers.google.com/apis/enabled\n * @link https://developers.google.com/maps/documentation/geolocation/\n * @link https://developers.google.com/maps/documentation/distance-matrix/\n *\n * \u003cbitbar.title\u003eTravel time\u003c/bitbar.title\u003e\n * \u003cbitbar.version\u003e1.1\u003c/bitbar.version\u003e\n * \u003cbitbar.author\u003eYann Milin\u003c/bitbar.author\u003e\n * \u003cbitbar.author.github\u003eymilin\u003c/bitbar.author.github\u003e\n * \u003cbitbar.desc\u003eProvides travel distance and time to your favorite destination, with traffic conditions. A Google Developer Account is required with access to \"Google Maps Distance Matrix API\" and \"Google Maps Geolocation API\"\u003c/bitbar.desc\u003e\n * \u003cbitbar.image\u003ehttp://i.imgur.com/Ui6I4YH.png\u003c/bitbar.image\u003e\n * \u003cbitbar.dependencies\u003ephp \u003e= 5.4.0\u003c/bitbar.dependencies\u003e\n */\n\nnamespace BitbarPlugins\\Travel;\n\n// Required : Your Google Developer Project's API Key\nconst API_KEY = \"YOUR_API_KEY\";\nconst DESTINATION = \"Tour Eiffel\";\n\n/*\n * Use airport to perform a scan of nearby wifi access points, provides better geolocation accuracy but makes script\n * slower by a few seconds.\n * false: fallback to current IP, resulting in less accurate geolocation\n */\nconst SCAN_NEARBY_WIFI_ACCESS_POINTS = true;\nconst LANGUAGE = \"en\"; // list of supported languages https://developers.google.com/maps/faq#languagesupport\nconst UNITS = \"metric\"; // metric, imperial\n\nconst AIRPORT_PATH = \"/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport\";\nconst DEBUG = false; // optimize output for console instead of bitbar\n\n/**\n * Class TravelTimePlugin\n *\n * Renders plugin output\n *\n * @package BitbarPlugins\\Travel\n */\nclass TravelTimePlugin\n{\n    const GOOGLE_MAP_URL                     = \"https://www.google.com/maps\";\n    const GOOGLE_MAP_URL_SOURCE_ADDRESS      = 'saddr';\n    const GOOGLE_MAP_URL_DESTINATION_ADDRESS = 'daddr';\n\n    const ICON_PIN     = \"üìç\";\n    const ICON_FLAG    = \"üèÅ\";\n    const ICON_CIRCLE  = \"‚≠ïÔ∏è\";\n    const ICON_WARNING = \"‚ö†Ô∏è\";\n    const COLOR_BLACK  = \"#000000\";\n    const COLOR_ORANGE = \"#FF9900\";\n    const COLOR_RED    = \"#FF0000\";\n\n    const ONE_MINUTES_IN_SECONDS     = 60;\n    const FIVE_MINUTES_IN_SECONDS    = 300;\n    const FIFTEEN_MINUTES_IN_SECONDS = 900;\n\n    private $durationInTraffic = [];\n    private $duration = [];\n    private $distance = [];\n    private $delay = null;\n    private $originAddress = null;\n    private $destinationAddress = null;\n    private $latitude = null;\n    private $longitude = null;\n    private $accuracy = null;\n    private $googleMapsLink = null;\n    private $accessPointCount = 0;\n    private $errors = [];\n    private $warnings = [];\n\n    private $distanceMatrixErrorMessages = [\n        DistanceMatrixResponse::STATUS_CODE_INVALID_REQUEST =\u003e \"Invalid Request.\",\n        DistanceMatrixResponse::STATUS_CODE_MAX_ELEMENTS_EXCEEDED =\u003e \"Origins and destinations per-query limit exceeded.\",\n        DistanceMatrixResponse::STATUS_CODE_OVER_QUERY_LIMIT =\u003e \"Too many requests.\",\n        DistanceMatrixResponse::STATUS_CODE_REQUEST_DENIED =\u003e \"Service denied\",\n        DistanceMatrixResponse::STATUS_CODE_UNKNOWN_ERROR =\u003e \"Server error, try again.\",\n    ];\n\n    private $distanceMatrixElementErrorMessages = [\n        DistanceMatrixResponseElement::STATUS_CODE_NOT_FOUND =\u003e \"Destination could not be geocoded.\",\n        DistanceMatrixResponseElement::STATUS_CODE_ZERO_RESULTS =\u003e \"No route could be found.\",\n    ];\n\n    public function __construct()\n    {\n        // Scan and create WifiAccessPoints\n        $wifiAccessPoints = [];\n        if (SCAN_NEARBY_WIFI_ACCESS_POINTS === true) {\n            try {\n                $wifiAccessPoints = WifiAccessPoints::fromAccessPointScannerResponse(AccessPointScanner::scan());\n                $this-\u003eaccessPointCount = count($wifiAccessPoints);\n            } catch (AccessPointScannerException $apse) {\n                $this-\u003ewarnings[] = $apse-\u003egetMessage();\n            }\n\n            if (count($wifiAccessPoints) \u003c 2) {\n                $this-\u003ewarnings[] = \"Less than two Wifi Access Points in proximity.\";\n            }\n        }\n\n        // Geolocation\n        try {\n            $geolocationApi = new GeolocationAPI();\n            $geolocationResponse = $geolocationApi-\u003ecall(GeolocationRequest::fromArrayDefinition([\n                GeolocationRequest::DEFINITION_WIFI_ACCESS_POINTS =\u003e $wifiAccessPoints\n            ]));\n\n            $this-\u003elatitude = $geolocationResponse-\u003egetLatitude();\n            $this-\u003elongitude = $geolocationResponse-\u003egetLongitude();\n            $this-\u003eaccuracy = $geolocationResponse-\u003egetAccuracy();\n        } catch (GeolocationResponseException $gre) {\n            $this-\u003eerrors[] = \"Geolocation API Error status {$gre-\u003egetStatusCode()}: {$gre-\u003egetMessage()}\";\n        }\n\n        if ($this-\u003elatitude \u0026\u0026 $this-\u003elongitude) {\n            // distanceMatrix\n            try {\n                $distanceMatrixAPI = new DistanceMatrixAPI();\n                $distanceMatrixResponse = $distanceMatrixAPI-\u003ecall(DistanceMatrixRequest::fromArrayDefinition([\n                    DistanceMatrixRequest::DEFINITION_ORIGINS =\u003e $this-\u003elatitude . ',' . $this-\u003elongitude,\n                    DistanceMatrixRequest::DEFINITION_DESTINATIONS =\u003e DESTINATION,\n                    DistanceMatrixRequest::DEFINITION_KEY =\u003e API_KEY,\n                    DistanceMatrixRequest::DEFINITION_LANGUAGE =\u003e LANGUAGE,\n                    DistanceMatrixRequest::DEFINITION_UNITS =\u003e UNITS,\n                ]));\n\n                $this-\u003edurationInTraffic = $distanceMatrixResponse-\u003egetRows()-\u003egetDurationInTraffic();\n                $this-\u003eduration = $distanceMatrixResponse-\u003egetRows()-\u003egetDuration();\n                $this-\u003edistance = $distanceMatrixResponse-\u003egetRows()-\u003egetDistance();\n                $this-\u003eoriginAddress = $distanceMatrixResponse-\u003egetOriginAddresses();\n                $this-\u003edestinationAddress = $distanceMatrixResponse-\u003egetDestinationAddresses();\n\n                $this-\u003ecomputeDelay();\n                $this-\u003ecomputeGoogleMapsLink();\n            } catch (DistanceMatrixResponseException $e) {\n                $this-\u003eerrors[] = \"Distance Matrix API Error: \" . $this-\u003edistanceMatrixErrorMessages[$e-\u003egetMessage()];\n            } catch (DistanceMatrixResponseElementException $e) {\n                $this-\u003eerrors[] = \"Distance Matrix API Error: \" . $this-\u003edistanceMatrixElementErrorMessages[$e-\u003egetMessage()];\n            }\n        }\n\n    }\n\n    private function computeDelay()\n    {\n        if (is_array($this-\u003eduration)\n            \u0026\u0026 is_array($this-\u003edurationInTraffic)\n            \u0026\u0026 array_key_exists('value', $this-\u003eduration)\n            \u0026\u0026 array_key_exists('value', $this-\u003edurationInTraffic)\n        ) {\n            $delay = $this-\u003edurationInTraffic['value'] - $this-\u003eduration['value'];\n            $this-\u003edelay = $delay \u003e 0 ? $delay : null;\n        } else {\n            $this-\u003edelay = null;\n        }\n    }\n\n    private function computeGoogleMapsLink()\n    {\n        if (isset($this-\u003eoriginAddress)\n            \u0026\u0026 is_string($this-\u003eoriginAddress)\n            \u0026\u0026 isset($this-\u003edestinationAddress)\n            \u0026\u0026 is_string($this-\u003edestinationAddress)\n        ) {\n            $this-\u003egoogleMapsLink = self::GOOGLE_MAP_URL . \"?\" . http_build_query([\n                    self::GOOGLE_MAP_URL_SOURCE_ADDRESS =\u003e $this-\u003eoriginAddress,\n                    self::GOOGLE_MAP_URL_DESTINATION_ADDRESS =\u003e $this-\u003edestinationAddress,\n                ]);\n        } else {\n            $this-\u003egoogleMapsLink = null;\n        }\n    }\n\n    /**\n     * @return string\n     */\n    public function __toString()\n    {\n        return $this-\u003erender();\n    }\n\n    private function render()\n    {\n        return DEBUG ? $this-\u003erenderConsole() : $this-\u003erenderBitbar();\n    }\n\n    /**\n     * render with Bitbar metadata\n     * @return string\n     */\n    private function renderBitbar()\n    {\n        $return = \"\";\n\n        if ($this-\u003eerrors) {\n            $return .= self::ICON_WARNING . \" Error|color=\" . self::COLOR_RED . \"\\n\";\n            $return .= \"---\\n\";\n            $return .= implode(\"|color=\" . self::COLOR_RED . \"\\n\", $this-\u003eerrors) . \"\\n\";\n            $return .= \"---\\n\";\n            $return .= \"Refresh | refresh=true \\n\";\n            return $return;\n        }\n\n        $durationColor = self::COLOR_BLACK;\n        if ($this-\u003edelay \u003e self::FIVE_MINUTES_IN_SECONDS) {\n            $durationColor = self::COLOR_ORANGE;\n        }\n        if ($this-\u003edelay \u003e self::FIFTEEN_MINUTES_IN_SECONDS) {\n            $durationColor = self::COLOR_RED;\n        }\n\n        $return .= self::ICON_PIN . \" {$this-\u003edurationInTraffic['text']}|color=$durationColor\\n\";\n        $return .= \"---\\n\";\n\n        if ($this-\u003ewarnings) {\n            foreach ($this-\u003ewarnings as $warning) {\n                $return .= self::ICON_WARNING . \" $warning\\n\";\n            }\n            $return .= \"---\\n\";\n        }\n\n        $return .= \"{$this-\u003edurationInTraffic['text']} ({$this-\u003edistance['text']})|color=$durationColor\\n\";\n        if ($this-\u003edelay \u003e self::ONE_MINUTES_IN_SECONDS) {\n            $return .= \"{$this-\u003eduration['text']} without traffic\\n\";\n        }\n        $return .= \"---\\n\";\n\n        $return .= \"Directions\\n\";\n        $return .= self::ICON_CIRCLE . \" {$this-\u003eoriginAddress} | color=\" . self::COLOR_BLACK . \"\\n\";\n        $return .= self::ICON_FLAG . \" {$this-\u003edestinationAddress} | color=\" . self::COLOR_BLACK . \"\\n\";\n        $return .= \"---\\n\";\n\n        $return .= \"Geolocation\\n\";\n        $return .= \"Latitude: {$this-\u003elatitude} | color=\" . self::COLOR_BLACK . \"\\n\";\n        $return .= \"Longitude: {$this-\u003elongitude} | color=\" . self::COLOR_BLACK . \"\\n\";\n        $return .= \"Accuracy: {$this-\u003eaccuracy}m | color=\" . self::COLOR_BLACK . \"\\n\";\n        $return .= \"---\\n\";\n\n        if ($this-\u003egoogleMapsLink) {\n            $return .= \"View on Google maps|href={$this-\u003egoogleMapsLink}\\n\";\n        }\n        $return .= \"Refresh | refresh=true \\n\";\n\n        return $return;\n    }\n\n    /**\n     * render for console output\n     * @return string\n     */\n    private function renderConsole()\n    {\n        $return = \"\";\n        if ($this-\u003eerrors) {\n            return implode(\"\\n\", $this-\u003eerrors);\n        }\n\n        if ($this-\u003ewarnings) {\n            $return .= \"---\\nWarning(s):\\n\";\n            $return .= implode(\"\\n\", $this-\u003ewarnings);\n            $return .= \"\\n---\\n\\n\";\n        }\n\n        $return .= \"Duration: {$this-\u003edurationInTraffic['text']}\\n\";\n        $return .= \"Distance: {$this-\u003edistance['text']}\\n\";\n        $return .= $this-\u003edelay ? \"Traffic Delay: {$this-\u003edelay}s\" : \"No Traffic Delay\";\n        $return .= \"\\n\\n\";\n\n        $return .= \"Directions:\\n\";\n        $return .= \"\\tFrom: {$this-\u003eoriginAddress}\\n\";\n        $return .= \"\\tTo: {$this-\u003edestinationAddress}\\n\\n\";\n\n        $return .= \"Geolocation:\\n\";\n        $return .= \"\\tLatitude: {$this-\u003elatitude}\\n\";\n        $return .= \"\\tLongitude: {$this-\u003elongitude}\\n\";\n        $return .= \"\\tAccuracy: {$this-\u003eaccuracy}\\n\\n\";\n\n        if ($this-\u003egoogleMapsLink) {\n            $return .= \"Google Maps URL: {$this-\u003egoogleMapsLink}\\n\\n\";\n        };\n\n        return $return;\n    }\n\n}\n\n/**\n * Class AccessPointScanner\n * @package BitbarPlugins\\Travel\n */\nfinal class AccessPointScanner\n{\n    /**\n     * use `airport` utility command with --scan option : Perform a wireless broadcast scan.\n     *\n     * @return string raw command output\n     * @throws AccessPointScannerException\n     */\n    public static function scan()\n    {\n        if (!self::airportProgramFound()) {\n            throw new AccessPointScannerException(\"Airport utility command not found. Please check path.\");\n        }\n\n        return shell_exec(AIRPORT_PATH . \" -s\");\n    }\n\n    private static function airportProgramFound()\n    {\n        if (!(is_file(AIRPORT_PATH)\n            \u0026\u0026 file_exists(AIRPORT_PATH)\n            \u0026\u0026 is_executable(AIRPORT_PATH))\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\nfinal class AccessPointScannerException extends \\Exception\n{\n\n}\n\nfinal class WifiAccessPoints implements \\Countable, \\JsonSerializable\n{\n\n    const PATTERN_AIRPORT_LINE_SCAN = '/^\\s*(.+?)\\s((?:[0-9A-Fa-f]{2}[:-]){5}(?:[0-9A-Fa-f]{2}))\\s(.+?)\\s+(\\d+).+$/';\n\n    /**\n     * @var WifiAccessPoint[]\n     */\n    private $accessPoints = [];\n\n    /**\n     * {@inheritDoc}\n     */\n    public function count()\n    {\n        return count($this-\u003eaccessPoints);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    function jsonSerialize()\n    {\n        return $this-\u003eaccessPoints;\n    }\n\n    /**\n     * @param string $response\n     *\n     * @return self\n     */\n    public static function fromAccessPointScannerResponse($response)\n    {\n        $instance = new self();\n\n        foreach (explode(\"\\n\", $response) as $airportAccessPoint) {\n            if (preg_match(self::PATTERN_AIRPORT_LINE_SCAN, $airportAccessPoint, $matches)) {\n                $instance-\u003eaccessPoints[] = WifiAccessPoint::fromArrayDefinition([\n                    WifiAccessPoint::DEFINITION_MAC_ADDRESS =\u003e $matches[2],\n                    WifiAccessPoint::DEFINITION_SIGNAL_TO_NOISE_RATION =\u003e intval($matches[3]),\n                    WifiAccessPoint::DEFINITION_CHANNEL =\u003e intval($matches[4]),\n                ]);\n            }\n        }\n\n        return $instance;\n    }\n\n}\n\nfinal class WifiAccessPoint implements \\JsonSerializable\n{\n    const DEFINITION_MAC_ADDRESS = \"macAddress\";\n    const DEFINITION_SIGNAL_STRENGTH = \"signalStrength\";\n    const DEFINITION_AGE = \"age\";\n    const DEFINITION_CHANNEL = \"channel\";\n    const DEFINITION_SIGNAL_TO_NOISE_RATION = \"signalToNoiseRatio\";\n\n    const PATTERN_MAC_ADDRESS = '/^(?:[0-9A-Fa-f]{2}[:-]){5}(?:[0-9A-Fa-f]{2})$/';\n\n    /**\n     * @var string\n     */\n    private $macAddress = null;\n\n    /**\n     * @var int\n     */\n    private $signalStrength = null;\n\n    /**\n     * @var int\n     */\n    private $age = null;\n\n    /**\n     * @var int\n     */\n    private $channel = null;\n\n    /**\n     * @var int\n     */\n    private $signalToNoiseRatio = null;\n\n    /**\n     * {@inheritDoc}\n     */\n    function jsonSerialize()\n    {\n        $return = [self::DEFINITION_MAC_ADDRESS =\u003e $this-\u003emacAddress];\n\n        if ($this-\u003esignalStrength !== null) {\n            $return[self::DEFINITION_SIGNAL_STRENGTH] = $this-\u003esignalStrength;\n        }\n\n        if ($this-\u003eage !== null) {\n            $return[self::DEFINITION_AGE] = $this-\u003eage;\n        }\n\n        if ($this-\u003echannel !== null) {\n            $return[self::DEFINITION_CHANNEL] = $this-\u003echannel;\n        }\n\n        if ($this-\u003esignalToNoiseRatio !== null) {\n            $return[self::DEFINITION_SIGNAL_TO_NOISE_RATION] = $this-\u003esignalToNoiseRatio;\n        }\n\n        return $return;\n    }\n\n    /**\n     * @param array $definition\n     * @return WifiAccessPoint\n     */\n    public static function fromArrayDefinition(array $definition)\n    {\n        $instance = new self();\n\n        $instance-\u003emacAddress = self::getMacAddressFromDefinition($definition);\n        $instance-\u003esignalStrength = self::getSignalStrengthFromDefinition($definition);\n        $instance-\u003eage = self::getAgeFromDefinition($definition);\n        $instance-\u003echannel = self::getChannelFromDefinition($definition);\n        $instance-\u003esignalToNoiseRatio = self::getSignalToNoiseRatioFromDefinition($definition);\n\n        return $instance;\n    }\n\n    private static function getMacAddressFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_MAC_ADDRESS])\n            \u0026\u0026 is_string($definition[self::DEFINITION_MAC_ADDRESS])\n            \u0026\u0026 preg_match(self::PATTERN_MAC_ADDRESS, $definition[self::DEFINITION_MAC_ADDRESS]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_MAC_ADDRESS];\n    }\n\n    private static function getSignalStrengthFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_SIGNAL_STRENGTH])\n            \u0026\u0026 is_int($definition[self::DEFINITION_SIGNAL_STRENGTH]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_SIGNAL_STRENGTH];\n    }\n\n    private static function getAgeFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_AGE])\n            \u0026\u0026 is_int($definition[self::DEFINITION_AGE]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_AGE];\n    }\n\n    private static function getChannelFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_CHANNEL])\n            \u0026\u0026 is_int($definition[self::DEFINITION_CHANNEL]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_CHANNEL];\n    }\n\n    private static function getSignalToNoiseRatioFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_SIGNAL_TO_NOISE_RATION])\n            \u0026\u0026 is_int($definition[self::DEFINITION_SIGNAL_TO_NOISE_RATION]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_SIGNAL_TO_NOISE_RATION];\n    }\n\n\n}\n\n/**\n * Class GeolocationAPI\n *\n * @link https://developers.google.com/maps/documentation/geolocation/\n * @package BitbarPlugins\\Travel\n */\nfinal class GeolocationAPI\n{\n    const GEOLOCATION_URL = \"https://www.googleapis.com/geolocation/v1/geolocate\";\n    const METHOD = \"POST\";\n\n    /**\n     * @var resource curl handler\n     */\n    private $ch;\n\n    private $headers = [\n        \"content-type: application/json\",\n        \"Accept: application/json\",\n        \"Cache-Control: no-cache\",\n        \"Pragma: no-cache\",\n    ];\n\n    public function __construct()\n    {\n        $this-\u003einitCurl();\n    }\n\n    private function initCurl()\n    {\n        $this-\u003ech = curl_init();\n\n        curl_setopt($this-\u003ech, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($this-\u003ech, CURLOPT_HTTPHEADER, $this-\u003eheaders);\n        curl_setopt($this-\u003ech, CURLOPT_CUSTOMREQUEST, self::METHOD);\n        curl_setopt($this-\u003ech, CURLOPT_POSTFIELDS, $this-\u003eheaders);\n    }\n\n    /**\n     * Sends a Geolocation request\n     *\n     * @param GeolocationRequest $request\n     * @return GeolocationResponse\n     */\n    public function call(GeolocationRequest $request)\n    {\n        $url = self::GEOLOCATION_URL . '?' . http_build_query(['key' =\u003e API_KEY]);\n\n        curl_setopt($this-\u003ech, CURLOPT_POSTFIELDS, json_encode($request));\n        curl_setopt($this-\u003ech, CURLOPT_URL, $url);\n\n        $response = curl_exec($this-\u003ech);\n\n        return GeolocationResponse::fromApiResponse($response);\n    }\n\n}\n\n/**\n * Class GeolocationRequest\n *\n * @todo make cellTower definition as an object and sanitize data\n * @link https://developers.google.com/maps/documentation/geolocation/intro#body\n * @package BitbarPlugins\\Travel\n */\nfinal class GeolocationRequest implements \\JsonSerializable\n{\n    const DEFINITION_MMC = \"homeMobileCountryCode\";\n    const DEFINITION_MNC = \"homeMobileNetworkCode\";\n    const DEFINITION_RADIO_TYPE = \"radioType\";\n    const DEFINITION_CARRIER = \"carrier\";\n    const DEFINITION_CONSIDER_IP = \"considerIp\";\n    const DEFINITION_CELL_TOWERS = \"cellTowers\";\n    const DEFINITION_WIFI_ACCESS_POINTS = \"wifiAccessPoints\";\n\n    /**\n     * The mobile country code (MCC) for the device's home network.\n     * @var int\n     */\n    private $homeMobileCountryCode = null;\n\n    /**\n     * The mobile network code (MNC) for the device's home network.\n     * @var int\n     */\n    private $homeMobileNetworkCode = null;\n\n    /**\n     * The mobile radio type. Supported values are lte, gsm, cdma, and wcdma. While this field is optional,\n     * it should be included if a value is available, for more accurate results.\n     * @var string\n     */\n    private $radioType = null;\n\n    /**\n     * The carrier name.\n     * @var string\n     */\n    private $carrier = null;\n\n    /**\n     * Specifies whether to fall back to IP geolocation if wifi and cell tower signals are not available.\n     * Note that the IP address in the request header may not be the IP of the device. Defaults to true.\n     * Set considerIp to false to disable fall back.\n     * @var boolean\n     */\n    private $considerIp = true;\n\n    /**\n     * An array of cell tower objects.\n     *\n     * @var array\n     */\n    private $cellTowers;\n\n    /**\n     * An array of WiFi access point objects.\n     * @var WifiAccessPoints\n     */\n    private $wifiAccessPoints;\n\n    function jsonSerialize()\n    {\n        $return = [];\n\n        if ($this-\u003ehomeMobileCountryCode !== null) {\n            $return[self::DEFINITION_MMC] = $this-\u003ehomeMobileCountryCode;\n        }\n\n        if ($this-\u003ehomeMobileNetworkCode !== null) {\n            $return[self::DEFINITION_MNC] = $this-\u003ehomeMobileNetworkCode;\n        }\n\n        if (in_array($this-\u003eradioType, ['lte', 'gsm', 'cdma', 'wcdma'], true)) {\n            $return[self::DEFINITION_RADIO_TYPE] = $this-\u003eradioType;\n        }\n\n        if ($this-\u003ecarrier) {\n            $return[self::DEFINITION_CARRIER] = $this-\u003ecarrier;\n        }\n\n        if ($this-\u003econsiderIp === false) {\n            $return[self::DEFINITION_CONSIDER_IP] = 'false';\n        }\n\n        if (count($this-\u003ecellTowers)) {\n            $return[self::DEFINITION_CELL_TOWERS] = $this-\u003ecellTowers;\n        }\n\n        if (count($this-\u003ewifiAccessPoints)) {\n            $return[self::DEFINITION_WIFI_ACCESS_POINTS] = $this-\u003ewifiAccessPoints;\n        }\n\n        return $return;\n    }\n\n    /**\n     * @param array $definition\n     *\n     * @return self\n     */\n    public static function fromArrayDefinition(array $definition)\n    {\n        $instance = new self();\n\n        $instance-\u003ehomeMobileCountryCode = self::getMMCFromDefinition($definition);\n        $instance-\u003ehomeMobileNetworkCode = self::getMNCFromDefinition($definition);\n        $instance-\u003eradioType = self::getRadioTypeFromDefinition($definition);\n        $instance-\u003ecarrier = self::getCarrierFromDefinition($definition);\n        $instance-\u003econsiderIp = self::getConsiderIpFromDefinition($definition);\n        $instance-\u003ecellTowers = self::getCellTowersFromDefinition($definition);\n        $instance-\u003ewifiAccessPoints = self::getWifiAccessPointsFromDefinition($definition);\n\n        return $instance;\n    }\n\n    private static function getMMCFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_MMC])\n            \u0026\u0026 is_int($definition[self::DEFINITION_MMC]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_MMC];\n    }\n\n    private static function getMNCFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_MNC])\n            \u0026\u0026 is_int($definition[self::DEFINITION_MNC]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_MNC];\n    }\n\n    private static function getRadioTypeFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_RADIO_TYPE])\n            \u0026\u0026 is_string($definition[self::DEFINITION_RADIO_TYPE])\n            \u0026\u0026 in_array($definition[self::DEFINITION_RADIO_TYPE], ['lte', 'gsm', 'cdma', 'wcdma'], true))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_RADIO_TYPE];\n    }\n\n    private static function getCarrierFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_CARRIER])\n            \u0026\u0026 is_string($definition[self::DEFINITION_CARRIER]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_CARRIER];\n    }\n\n    private static function getConsiderIpFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_CONSIDER_IP])\n            \u0026\u0026 is_bool($definition[self::DEFINITION_CONSIDER_IP]))\n        ) {\n            return true;\n        }\n\n        return $definition[self::DEFINITION_CONSIDER_IP];\n    }\n\n    private static function getCellTowersFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_CELL_TOWERS])\n            \u0026\u0026 is_array($definition[self::DEFINITION_CELL_TOWERS]))\n        ) {\n            return [];\n        }\n\n        return $definition[self::DEFINITION_CELL_TOWERS];\n    }\n\n    private static function getWifiAccessPointsFromDefinition(array $definition)\n    {\n\n        if (!(isset($definition[self::DEFINITION_WIFI_ACCESS_POINTS])\n            \u0026\u0026 $definition[self::DEFINITION_WIFI_ACCESS_POINTS] instanceof WifiAccessPoints\n            \u0026\u0026 count($definition[self::DEFINITION_WIFI_ACCESS_POINTS]) \u003e= 2)\n        ) {\n            return [];\n        }\n\n        return $definition[self::DEFINITION_WIFI_ACCESS_POINTS];\n    }\n\n    /**\n     * @param string $carrier\n     * @return GeolocationRequest\n     */\n    public function setCarrier($carrier)\n    {\n        $this-\u003ecarrier = $carrier;\n        return $this;\n    }\n\n    /**\n     * @param array $cellTowers\n     * @return GeolocationRequest\n     */\n    public function setCellTowers($cellTowers)\n    {\n        $this-\u003ecellTowers = $cellTowers;\n        return $this;\n    }\n\n    /**\n     * @param boolean $considerIp\n     * @return GeolocationRequest\n     */\n    public function setConsiderIp($considerIp)\n    {\n        $this-\u003econsiderIp = $considerIp;\n        return $this;\n    }\n\n    /**\n     * @param int $homeMobileCountryCode\n     * @return GeolocationRequest\n     */\n    public function setHomeMobileCountryCode($homeMobileCountryCode)\n    {\n        $this-\u003ehomeMobileCountryCode = $homeMobileCountryCode;\n        return $this;\n    }\n\n    /**\n     * @param int $homeMobileNetworkCode\n     * @return GeolocationRequest\n     */\n    public function setHomeMobileNetworkCode($homeMobileNetworkCode)\n    {\n        $this-\u003ehomeMobileNetworkCode = $homeMobileNetworkCode;\n        return $this;\n    }\n\n    /**\n     * @param string $radioType\n     * @return GeolocationRequest\n     */\n    public function setRadioType($radioType)\n    {\n        $this-\u003eradioType = $radioType;\n        return $this;\n    }\n\n    /**\n     * @param WifiAccessPoints $wifiAccessPoints\n     * @return GeolocationRequest\n     */\n    public function setWifiAccessPoints($wifiAccessPoints)\n    {\n        $this-\u003ewifiAccessPoints = $wifiAccessPoints;\n        return $this;\n    }\n}\n\n/**\n * Class GeolocationResponse\n * @package BitbarPlugins\\Travel\n */\nfinal class GeolocationResponse\n{\n    const DEFINITION_LOCATION = 'location';\n    const DEFINITION_LATITUDE = 'lat';\n    const DEFINITION_LONGITUDE = 'lng';\n    const DEFINITION_ACCURACY = 'accuracy';\n    const DEFINITION_ERROR = 'error';\n    const DEFINITION_MESSAGE = 'message';\n    const DEFINITION_CODE = 'code';\n\n    /**\n     * @var float\n     */\n    private $latitude = null;\n\n    /**\n     * @var float\n     */\n    private $longitude = null;\n\n    /**\n     * @var float\n     */\n    private $accuracy = null;\n\n    /**\n     * Creates an instance of GeolocationResponse from raw API response in json\n     * @param $response\n     * @return GeolocationResponse\n     * @throws GeolocationResponseException\n     */\n    public static function fromApiResponse($response)\n    {\n        $instance = new self();\n\n        $geolocation = json_decode($response, true);\n\n        if ($geolocationError = self::getErrorFromResponse($geolocation)) {\n            throw $geolocationError;\n        }\n\n        $instance-\u003elatitude = self::getLatitudeFromResponse($geolocation);\n        $instance-\u003elongitude = self::getLongitudeFromResponse($geolocation);\n        $instance-\u003eaccuracy = self::getAccuracyFromResponse($geolocation);\n\n        return $instance;\n    }\n\n    private static function getErrorFromResponse(array $geolocation)\n    {\n        if (!(is_array($geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_ERROR, $geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_MESSAGE, $geolocation[self::DEFINITION_ERROR])\n            \u0026\u0026 array_key_exists(self::DEFINITION_CODE, $geolocation[self::DEFINITION_ERROR])\n            \u0026\u0026 is_string($geolocation[self::DEFINITION_ERROR][self::DEFINITION_MESSAGE])\n            \u0026\u0026 is_int($geolocation[self::DEFINITION_ERROR][self::DEFINITION_CODE]))\n        ) {\n            return null;\n        }\n\n        return new GeolocationResponseException(\n            $geolocation[self::DEFINITION_ERROR][self::DEFINITION_MESSAGE],\n            $geolocation[self::DEFINITION_ERROR][self::DEFINITION_CODE]\n        );\n    }\n\n    private static function getLatitudeFromResponse(array $geolocation)\n    {\n        if (!(is_array($geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_LOCATION, $geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_LATITUDE, $geolocation[self::DEFINITION_LOCATION])\n            \u0026\u0026 is_float($geolocation[self::DEFINITION_LOCATION][self::DEFINITION_LATITUDE]))\n        ) {\n            return null;\n        }\n\n        return $geolocation[self::DEFINITION_LOCATION][self::DEFINITION_LATITUDE];\n    }\n\n    private static function getLongitudeFromResponse(array $geolocation)\n    {\n        if (!(is_array($geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_LOCATION, $geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_LONGITUDE, $geolocation[self::DEFINITION_LOCATION])\n            \u0026\u0026 is_float($geolocation[self::DEFINITION_LOCATION][self::DEFINITION_LONGITUDE]))\n        ) {\n            return null;\n        }\n\n        return $geolocation[self::DEFINITION_LOCATION][self::DEFINITION_LONGITUDE];\n    }\n\n    private static function getAccuracyFromResponse(array $geolocation)\n    {\n        if (!(is_array($geolocation)\n            \u0026\u0026 array_key_exists(self::DEFINITION_ACCURACY, $geolocation)\n            \u0026\u0026 is_float($geolocation[self::DEFINITION_ACCURACY]))\n        ) {\n            return null;\n        }\n\n        return $geolocation[self::DEFINITION_ACCURACY];\n    }\n\n    /**\n     * @return float\n     */\n    public function getAccuracy()\n    {\n        return $this-\u003eaccuracy;\n    }\n\n    /**\n     * @return float\n     */\n    public function getLatitude()\n    {\n        return $this-\u003elatitude;\n    }\n\n    /**\n     * @return float\n     */\n    public function getLongitude()\n    {\n        return $this-\u003elongitude;\n    }\n}\n\nfinal class GeolocationResponseException extends \\Exception\n{\n    /**\n     * @var int\n     */\n    private $statusCode;\n\n    public function __construct($message, $code)\n    {\n        $this-\u003estatusCode = $code;\n        $this-\u003emessage = $message;\n    }\n\n    /**\n     * @return int\n     */\n    public function getStatusCode()\n    {\n        return $this-\u003estatusCode;\n    }\n}\n\n/**\n * Class DistanceMatrixAPI\n *\n * @link https://developers.google.com/maps/documentation/distance-matrix/\n * @package BitbarPlugins\\Travel\n */\nfinal class DistanceMatrixAPI\n{\n    const DISTANCE_MATRIX_URL = \"https://maps.googleapis.com/maps/api/distancematrix/json\";\n\n    /**\n     * @var resource curl handler\n     */\n    private $ch;\n\n    private $headers = [\n        \"Accept: application/json\",\n        \"Cache-Control: no-cache\",\n        \"Pragma: no-cache\",\n    ];\n\n    public function __construct()\n    {\n        $this-\u003einitCurl();\n    }\n\n    private function initCurl()\n    {\n        $this-\u003ech = curl_init();\n\n        curl_setopt($this-\u003ech, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($this-\u003ech, CURLOPT_HTTPHEADER, $this-\u003eheaders);\n    }\n\n    /**\n     * Send a DistanceMatrix Request\n     *\n     * @param DistanceMatrixRequest $request\n     * @return DistanceMatrixResponse\n     * @throws DistanceMatrixResponseException\n     */\n    public function call(DistanceMatrixRequest $request)\n    {\n        $url = self::DISTANCE_MATRIX_URL . '?' . $request-\u003etoQueryParameters();\n        curl_setopt($this-\u003ech, CURLOPT_URL, $url);\n        $response = curl_exec($this-\u003ech);\n\n        return DistanceMatrixResponse::fromApiResponse($response);\n    }\n\n}\n\n/**\n * Class DistanceMatrixRequest\n * @todo handle departure_time with unix timestamps\n * @package BitbarPlugins\\Travel\n */\nfinal class DistanceMatrixRequest\n{\n    const DEFINITION_ORIGINS = \"origins\";\n    const DEFINITION_DESTINATIONS = \"destinations\";\n    const DEFINITION_KEY = \"key\";\n    const DEFINITION_MODE = \"mode\";\n    const DEFINITION_LANGUAGE = \"language\";\n    const DEFINITION_UNITS = \"units\";\n    const DEFINITION_DEPARTURE_TIME = \"departure_time\";\n\n    const PATTERN_LATITUDE_LONGITUDE = '/^\\-?\\d+(?:\\.\\d+)?,\\-?\\d+(?:\\.\\d+)?$/';\n\n    /**\n     * One or more addresses and/or textual latitude/longitude values, separated with the pipe (|) character,\n     * from which to calculate distance and time.\n     * @var string\n     */\n    private $origins = null;\n\n    /**\n     * One or more addresses and/or textual latitude/longitude values, separated with the pipe (|) character,\n     * to which to calculate distance and time.\n     * @var string\n     */\n    private $destinations = null;\n\n    /**\n     * Your application's API key. This key identifies your application for purposes of quota management.\n     * @var string\n     */\n    private $key = null;\n\n    /**\n     * Optional\n     * Specifies the mode of transport to use when calculating distance.\n     * @var string\n     */\n    private $mode = 'driving'; // 'driving', 'walking', 'cycling', 'transit'\n\n    /**\n     * Optional\n     * The language in which to return results.\n     * @var string\n     */\n    private $language = 'en';\n\n    /**\n     * Optional\n     * Specifies the unit system to use when expressing distance as text.\n     * @var string\n     */\n    private $units = 'metric'; // 'metric', 'imperial'\n\n    /**\n     * Optional\n     * The desired time of departure. You can specify the time as an integer in seconds since midnight,\n     * January 1, 1970 UTC. Alternatively, you can specify a value of now\n     * @var string\n     */\n    private $departureTime = 'now';\n\n    /**\n     * Convert Request Object to URL-encoded query string\n     *\n     * @return string\n     */\n    public function toQueryParameters()\n    {\n        return http_build_query([\n            self::DEFINITION_ORIGINS =\u003e $this-\u003eorigins,\n            self::DEFINITION_DESTINATIONS =\u003e $this-\u003edestinations,\n            self::DEFINITION_KEY =\u003e $this-\u003ekey,\n            self::DEFINITION_MODE =\u003e $this-\u003emode,\n            self::DEFINITION_LANGUAGE =\u003e $this-\u003elanguage,\n            self::DEFINITION_UNITS =\u003e $this-\u003eunits,\n            self::DEFINITION_DEPARTURE_TIME =\u003e $this-\u003edepartureTime,\n        ]);\n    }\n\n    /**\n     * @param array $definition\n     *\n     * @return self\n     */\n    public static function fromArrayDefinition(array $definition)\n    {\n        $instance = new self();\n\n        $instance-\u003eorigins = self::getOriginsFromDefinition($definition);\n        $instance-\u003edestinations = self::getDestinationsFromDefinition($definition);\n        $instance-\u003ekey = self::getKeyFromDefinition($definition);\n        $instance-\u003emode = self::getModeFromDefinition($definition);\n        $instance-\u003elanguage = self::getLanguageFromDefinition($definition);\n        $instance-\u003eunits = self::getUnitsFromDefinition($definition);\n        $instance-\u003edepartureTime = self::getDepartureTimeFromDefinition($definition);\n\n        return $instance;\n    }\n\n    private static function getOriginsFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_ORIGINS])\n            \u0026\u0026 is_string($definition[self::DEFINITION_ORIGINS])\n            \u0026\u0026 preg_match(self::PATTERN_LATITUDE_LONGITUDE, $definition[self::DEFINITION_ORIGINS]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_ORIGINS];\n    }\n\n    private static function getDestinationsFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_DESTINATIONS])\n            \u0026\u0026 is_string($definition[self::DEFINITION_DESTINATIONS]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_DESTINATIONS];\n    }\n\n    private static function getKeyFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_KEY])\n            \u0026\u0026 is_string($definition[self::DEFINITION_KEY]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_KEY];\n    }\n\n    private static function getModeFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_MODE])\n            \u0026\u0026 is_string($definition[self::DEFINITION_MODE])\n            \u0026\u0026 in_array($definition[self::DEFINITION_MODE], ['driving', 'walking', 'cycling', 'transit']))\n        ) {\n            return 'driving';\n        }\n\n        return $definition[self::DEFINITION_MODE];\n    }\n\n    private static function getLanguageFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_LANGUAGE])\n            \u0026\u0026 is_string($definition[self::DEFINITION_LANGUAGE])\n            \u0026\u0026 in_array($definition[self::DEFINITION_LANGUAGE], ['ar', 'kn', 'bg', 'ko', 'bn', 'lt', 'ca', 'lv', 'cs',\n                'ml', 'da', 'mr', 'de', 'nl', 'el', 'no', 'en', 'pl', 'en-AU', 'pt', 'en-GB', 'pt-BR', 'es', 'pt-PT',\n                'eu', 'ro', 'eu', 'ru', 'fa', 'sk', 'fi', 'sl', 'fil', 'sr', 'fr', 'sv', 'gl', 'ta', 'gu', 'te', 'hi',\n                'th', 'hr', 'tl', 'hu', 'tr', 'id', 'uk', 'it', 'vi', 'iw', 'zh-CN', 'ja', 'zh-TW',]))\n        ) {\n            return 'en';\n        }\n\n        return $definition[self::DEFINITION_LANGUAGE];\n    }\n\n    private static function getUnitsFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_UNITS])\n            \u0026\u0026 is_string($definition[self::DEFINITION_UNITS])\n            \u0026\u0026 in_array($definition[self::DEFINITION_UNITS], ['metric', 'imperial']))\n        ) {\n            return 'metric';\n        }\n\n        return $definition[self::DEFINITION_UNITS];\n    }\n\n    private static function getDepartureTimeFromDefinition(array $definition)\n    {\n        if (!(isset($definition[self::DEFINITION_DEPARTURE_TIME])\n            \u0026\u0026 is_string($definition[self::DEFINITION_DEPARTURE_TIME])\n            \u0026\u0026 $definition[self::DEFINITION_DEPARTURE_TIME] === 'now')\n        ) {\n            return 'now';\n        }\n\n        return $definition[self::DEFINITION_DEPARTURE_TIME];\n    }\n}\n\n/**\n * Class DistanceMatrixResponse\n * @package BitbarPlugins\\Travel\n */\nfinal class DistanceMatrixResponse\n{\n    const DEFINITION_STATUS = 'status';\n    const DEFINITION_ORIGIN_ADDRESSES = 'origin_addresses';\n    const DEFINITION_DESTINATION_ADDRESSES = 'destination_addresses';\n    const DEFINITION_ROWS = 'rows';\n\n    const STATUS_CODE_OK = 'OK';\n    const STATUS_CODE_INVALID_REQUEST = 'INVALID_REQUEST';\n    const STATUS_CODE_MAX_ELEMENTS_EXCEEDED = 'MAX_ELEMENTS_EXCEEDED';\n    const STATUS_CODE_OVER_QUERY_LIMIT = 'OVER_QUERY_LIMIT';\n    const STATUS_CODE_REQUEST_DENIED = 'REQUEST_DENIED';\n    const STATUS_CODE_UNKNOWN_ERROR = 'UNKNOWN_ERROR';\n\n    /**\n     * Contains metadata on the request.\n     * @var string\n     */\n    private $status;\n\n    /**\n     * Contains an array of addresses as returned by the API from your original request.\n     * These are formatted by the geocoder and localized according to the language parameter passed with the request.\n     * @var string\n     */\n    private $originAddresses;\n\n    /**\n     * Contains an array of addresses as returned by the API from your original request.\n     * As with origin_addresses, these are localized if appropriate.\n     * @var string\n     */\n    private $destinationAddresses;\n\n    /**\n     * Contains an array of elements\n     * @var DistanceMatrixResponseElement\n     */\n    private $rows;\n\n    /**\n     * Creates an instance of DistanceMatrixResponse from raw API response in json\n     * @param $response\n     * @return DistanceMatrixResponse\n     * @throws DistanceMatrixResponseException\n     */\n    public static function fromApiResponse($response)\n    {\n        $instance = new self();\n\n        $distanceMatrix = json_decode($response, true);\n\n        if ($distanceMatrixError = self::getErrorFromResponse($distanceMatrix)) {\n            throw $distanceMatrixError;\n        }\n\n        $instance-\u003estatus = self::getStatusFromResponse($distanceMatrix);\n        $instance-\u003eoriginAddresses = self::getOriginAddressesFromResponse($distanceMatrix);\n        $instance-\u003edestinationAddresses = self::getDestinationAddressesFromResponse($distanceMatrix);\n        $instance-\u003erows = DistanceMatrixResponseElement::fromArrayDefinition(self::getRowsFromResponse($distanceMatrix));\n\n        return $instance;\n    }\n\n    private static function getErrorFromResponse(array $distanceMatrix)\n    {\n        if (!(is_array($distanceMatrix)\n            \u0026\u0026 array_key_exists(self::DEFINITION_STATUS, $distanceMatrix)\n            \u0026\u0026 $distanceMatrix[self::DEFINITION_STATUS] === self::STATUS_CODE_OK)\n        ) {\n            return new DistanceMatrixResponseException($distanceMatrix[self::DEFINITION_STATUS]);\n        }\n\n        return null;\n    }\n\n    private static function getStatusFromResponse(array $distanceMatrix)\n    {\n        if (!(is_array($distanceMatrix)\n            \u0026\u0026 array_key_exists(self::DEFINITION_STATUS, $distanceMatrix)\n            \u0026\u0026 is_string($distanceMatrix[self::DEFINITION_STATUS]))\n        ) {\n            return null;\n        }\n\n        return $distanceMatrix[self::DEFINITION_STATUS];\n    }\n\n    private static function getOriginAddressesFromResponse(array $distanceMatrix)\n    {\n        if (!(is_array($distanceMatrix)\n            \u0026\u0026 array_key_exists(self::DEFINITION_ORIGIN_ADDRESSES, $distanceMatrix)\n            \u0026\u0026 is_array($distanceMatrix[self::DEFINITION_ORIGIN_ADDRESSES])\n            \u0026\u0026 count($distanceMatrix[self::DEFINITION_ORIGIN_ADDRESSES]) === 1)\n        ) {\n            return null;\n        }\n\n        return $distanceMatrix[self::DEFINITION_ORIGIN_ADDRESSES][0];\n    }\n\n    private static function getDestinationAddressesFromResponse(array $distanceMatrix)\n    {\n        if (!(is_array($distanceMatrix)\n            \u0026\u0026 array_key_exists(self::DEFINITION_DESTINATION_ADDRESSES, $distanceMatrix)\n            \u0026\u0026 is_array($distanceMatrix[self::DEFINITION_DESTINATION_ADDRESSES])\n            \u0026\u0026 count($distanceMatrix[self::DEFINITION_DESTINATION_ADDRESSES]) === 1)\n        ) {\n            return null;\n        }\n\n        return $distanceMatrix[self::DEFINITION_DESTINATION_ADDRESSES][0];\n    }\n\n    private static function getRowsFromResponse(array $distanceMatrix)\n    {\n        if (!(is_array($distanceMatrix)\n            \u0026\u0026 array_key_exists(self::DEFINITION_ROWS, $distanceMatrix)\n            \u0026\u0026 is_array($distanceMatrix[self::DEFINITION_ROWS])\n            \u0026\u0026 count($distanceMatrix[self::DEFINITION_ROWS]) === 1)\n        ) {\n            return null;\n        }\n\n        return $distanceMatrix[self::DEFINITION_ROWS][0];\n    }\n\n    /**\n     * @return string\n     */\n    public function getDestinationAddresses()\n    {\n        return $this-\u003edestinationAddresses;\n    }\n\n    /**\n     * @return string\n     */\n    public function getOriginAddresses()\n    {\n        return $this-\u003eoriginAddresses;\n    }\n\n    /**\n     * @return DistanceMatrixResponseElement\n     */\n    public function getRows()\n    {\n        return $this-\u003erows;\n    }\n\n    /**\n     * @return string\n     */\n    public function getStatus()\n    {\n        return $this-\u003estatus;\n    }\n\n}\n\nfinal class DistanceMatrixResponseElement\n{\n    const DEFINITION_ELEMENTS = 'elements';\n    const DEFINITION_STATUS = 'status';\n    const DEFINITION_DURATION = 'duration';\n    const DEFINITION_DISTANCE = 'distance';\n    const DEFINITION_DURATION_IN_TRAFFIC = 'duration_in_traffic';\n\n    const STATUS_CODE_OK = 'OK';\n    const STATUS_CODE_NOT_FOUND = 'NOT_FOUND';\n    const STATUS_CODE_ZERO_RESULTS = 'ZERO_RESULTS';\n\n    /**\n     * Element level status of the request\n     * @var string\n     */\n    private $status = null;\n\n    /**\n     * The length of time it takes to travel this route, expressed in seconds (the value field) and as text.\n     * The textual representation is localized according to the query's language parameter.\n     * @var array\n     */\n    private $duration = [];\n\n    /**\n     * The total distance of this route, expressed in meters (value) and as text. The textual value uses the unit\n     * system specified with the unit parameter of the original request, or the origin's region.\n     * @var array\n     */\n    private $distance = [];\n\n    /**\n     * The length of time it takes to travel this route, based on current and historical traffic conditions.\n     * @var array\n     */\n    private $durationInTraffic = [];\n\n    /**\n     * @param array $definition\n     * @return DistanceMatrixResponseElement\n     * @throws DistanceMatrixResponseElementException\n     */\n    public static function fromArrayDefinition(array $definition)\n    {\n        $instance = new self();\n\n        if ($distanceMatrixElementError = self::getErrorFromDefinition($definition)) {\n            throw $distanceMatrixElementError;\n        }\n\n        $instance-\u003estatus = self::getStatusFromDefinition($definition);\n        $instance-\u003eduration = self::getDurationFromDefinition($definition);\n        $instance-\u003edistance = self::getDistanceFromDefinition($definition);\n        $instance-\u003edurationInTraffic = self::getDurationInTrafficFromDefinition($definition);\n\n        return $instance;\n    }\n\n    public static function getErrorFromDefinition(array $definition)\n    {\n        if (!(is_array($definition)\n            \u0026\u0026 array_key_exists(self::DEFINITION_ELEMENTS, $definition)\n            \u0026\u0026 is_array($definition[self::DEFINITION_ELEMENTS])\n            \u0026\u0026 count($definition[self::DEFINITION_ELEMENTS]) === 1\n            \u0026\u0026 is_array($definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 array_key_exists(self::DEFINITION_STATUS, $definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 $definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_STATUS] === self::STATUS_CODE_OK)\n        ) {\n            return new DistanceMatrixResponseElementException($definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_STATUS]);\n        }\n\n        return null;\n    }\n\n    public static function getStatusFromDefinition(array $definition)\n    {\n        if (!(is_array($definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 array_key_exists(self::DEFINITION_STATUS, $definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 is_string($definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_STATUS]))\n        ) {\n            return null;\n        }\n\n        return $definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_STATUS];\n    }\n\n    public static function getDurationFromDefinition(array $definition)\n    {\n        if (!(is_array($definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 array_key_exists(self::DEFINITION_DURATION, $definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 is_array($definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DURATION]))\n        ) {\n            return [];\n        }\n\n        return $definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DURATION];\n    }\n\n    public static function getDistanceFromDefinition(array $definition)\n    {\n        if (!(is_array($definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 array_key_exists(self::DEFINITION_DISTANCE, $definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 is_array($definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DISTANCE]))\n        ) {\n            return [];\n        }\n\n        return $definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DISTANCE];\n    }\n\n    public static function getDurationInTrafficFromDefinition(array $definition)\n    {\n        if (!(is_array($definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 array_key_exists(self::DEFINITION_DURATION_IN_TRAFFIC, $definition[self::DEFINITION_ELEMENTS][0])\n            \u0026\u0026 is_array($definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DURATION_IN_TRAFFIC]))\n        ) {\n            return [];\n        }\n\n        return $definition[self::DEFINITION_ELEMENTS][0][self::DEFINITION_DURATION_IN_TRAFFIC];\n    }\n\n    /**\n     * @return array\n     */\n    public function getDistance()\n    {\n        return $this-\u003edistance;\n    }\n\n    /**\n     * @return array\n     */\n    public function getDuration()\n    {\n        return $this-\u003eduration;\n    }\n\n    /**\n     * @return array\n     */\n    public function getDurationInTraffic()\n    {\n        return $this-\u003edurationInTraffic;\n    }\n\n    /**\n     * @return string\n     */\n    public function getStatus()\n    {\n        return $this-\u003estatus;\n    }\n}\n\nfinal class DistanceMatrixResponseException extends \\Exception\n{\n\n}\n\nfinal class DistanceMatrixResponseElementException extends \\Exception\n{\n\n}\n\necho new TravelTimePlugin();\n"
				}
			],
			"path": "Travel/travel-time.5m.php",
			"filename": "travel-time.5m.php",
			"dir": "Travel",
			"docsPlugin": "Travel/travel-time.5m.php.html",
			"docsCategory": "Travel.html",
			"pathSegments": [
				"Travel"
			],
			"categoryPathSegments": [
				{
					"path": "Travel",
					"text": "Travel",
					"isLast": true
				}
			],
			"title": "Travel time",
			"version": "1.1",
			"author": "Yann Milin",
			"authors": [
				{
					"name": "Yann Milin",
					"githubUsername": "ymilin",
					"imageURL": "https://avatars.githubusercontent.com/u/3737075?v=4",
					"bio": "",
					"primary": true
				}
			],
			"desc": "Provides travel distance and time to your favorite destination, with traffic conditions. A Google Developer Account is required with access to \"Google Maps Distance Matrix API\" and \"Google Maps Geolocation API\"",
			"imageURL": "http://i.imgur.com/Ui6I4YH.png",
			"dependencies": [
				"php \u003e= 5.4.0"
			],
			"aboutURL": "",
			"lastUpdated": "2021-03-08T15:22:08.333314Z",
			"vars": null
		}
	]
}